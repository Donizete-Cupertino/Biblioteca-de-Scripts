########### Infra AB ###########

-- QVX9 - R7KI

-- Abrir chamado no click:

--1- Clicar em "+ Novo Evento' (Canto direito superior)

3- Identificar o "Usuário Solicitante"

4- Preencher a "Descrição da Solicitação/Incidente"

5- Em Serviços, clicar em"Tecnologia da Informação e Comunicação" >> "TIC Serviços Internos" >> "Investigação de Falhas em Serviços Internos"

6 - Preencher o campo "Resumo"

7- Preencher o Campo "Descrição Detalhada"

8- No campo "Grupo de Serv. Atribuido" informar a mesa para onde o Registro deve ser enviado.

9- Marcar o BOX " Confirma que alterou valor do campo 'Grupo Serv. Atribuído' para uma mesa válida? "

10 - Salvar o registro (Icone do "Disquete" abaixo do "Campo de Pesquisa")

O mais importante é do item 5 para baixo


-- subir a base com o init
logar no banco:
startup nomount pfile='/u01/app/oracle/product/11.2.0.4/db_1/dbs/inits11ph.ora';
startup nomount pfile='/u01/app/oracle/product/11.2.0.4/db_1/inits11ph.ora';

pfile='/u01/app/oracle/product/11.2.0.4/db_1/dbs/initrcmentort.ora';

startup nomount pfile='/u01/app/oracle/product/19/db_1/dbs/initintegrat.ora';

startup mount pfile='/u01/app/oracle/product/19/db_1/dbs/michael.ora';

+DG_DAT01/parameter/spfiledepbr.ora

+DG_DAT01/spfldepbr.ora

S11PH

-- criar um spfile 
logar no banco:
create spfile='+DG_DAT01/MENTORT/PARAMETERFILE/spfilementor.ora' from pfile;
create spfile='+DG_DAT01/MENTORT/PARAMETERFILE/spfilementor.ora' from pfile='/u01/app/oracle/product/11.2.0.4/db_1/dbs/initrcmentort.ora';

create spfile ='+DG_DAT01/APLABDG1/PARAMETERFILE/spfile.ora' from memory; 

startup pfile='/u01/app/oracle/product/11.2.0.4/db_1/dbs/initrcmentort.ora';

--Alocação de memoria:

Página inicial	>	Infraestrutura de TI	>	Servidor Virtual	>	Alterar	>	Alterar Recursos

--Alocação de disco:
Página inicial	>	Infraestrutura de TI	>	Servidor Virtual	>	Alterar	>	Adicionar Disco

--limpeza backup avamar
C:\Program Files\avs\var\

--limpa back
mofcomp "%programfiles(x86)%\Microsoft SQL Server\100\Shared\sqlmgmproviderxpsp2up.mof"

desativar serviço backup

1 - download de versao
https://ava2-ut-cipd.petrobras.com.br/dtlt/home.html#downloads
AvamarClient-windows-x86_64-7.4.101-58
AvamarSQL-windows-x86_64-7.4.101-58

2 instala nova versao cliente, sem remover anterior
3 remoção apenas do modulo SQL
4 instala novo modulo SQL

-- Enterprise Manager - OEM 
	https://npaa3809:7799/em/faces/core-uifwk-console-overview
https://monitgrid:7799/em/faces/logon/core-uifwk-console-login
	
	Usuário: oem_sysman
	Senha: oracle17
	Usuario: grid_appab_rj
	Senha: Entub#d0sh
	Usuario: grid_appab_seal
	Senha: oracle123
	Usuario: grid_rnce
	Usuario: oracle123
	
	
Cast: informações sobre servidores, caminhos e Jobs.
	Caminho: https://cast.petrobras.com.br/
	
#############################################################################

----- Queries do Mentor -----
	Registros da equipe:
	(('Grupo Designado*+'="N3-INFRA-APLICACOES_AB")) AND (('Status*'="Em Andamento") OR ('Status*'="Pendente")OR ('Status*'="Designado") )

	Meus Registros:
	(('Grupo Designado*+'="N3-INFRA-APLICACOES_AB")) AND ('Designado+'="ADRIAN L DELLATORRE") AND (('Status*'="Em Andamento") OR ('Status*'="Pendente") OR ('Status*'="Designado"))

	Tarefas da Equipe:
	(('Grupo a Designar+'="N3-INFRA-APLICACOES_AB")) AND (('Status*'="Em Andamento") OR ('Status*'="Pendente")OR ('Status*'="Designado"))

	Minhas Tarefas:
	(('Grupo a Designar+'="N3-INFRA-APLICACOES_AB")) AND ('Designado+'="ADRIAN L DELLATORRE") AND (('Status*'="Em Andamento") OR ('Status*'="Pendente")OR ('Status*'="Designado") OR ('Status*'="Em Planejamento"))

	Registros da Equipe de BD:
	(('Grupo Designado*+'="N3-INFRA-APLICACOES_AB")) AND (('Status*'="Em Andamento") OR ('Status*'="Pendente")OR ('Status*'="Designado") ) AND (('Designado+'="ADRIAN L DELLATORRE") OR ('Designado+'="RENATA D PFALTZGRAFF") OR ('Designado+'="PAULO C ARAUZ") OR ('Designado+'="VINICIUS P SOARES") OR ('Designado+'="ALEXANDRE F PIRES") OR ('Designado+'="AFONSO C PINHO") OR ('Designado+'="FLAVIO L PIRES") OR ('Designado+'="KAROL GURNIAK") OR ('Designado+'="WILLIAM ROBATINO"))
	
	Tarefas da Equipe de BD:
	(('Grupo a Designar+'="N3-INFRA-SUPORTE_AB") OR ('Grupo a Designar+'="N3-INFRA-APLICACOES_AB")) AND (('Designado+'="ADRIAN L DELLATORRE") OR ('Designado+'="RENATA D PFALTZGRAFF") OR ('Designado+'="PAULO C ARAUZ") OR ('Designado+'="VINICIUS P SOARES") OR ('Designado+'="ALEXANDRE F PIRES") OR ('Designado+'="AFONSO C PINHO") OR ('Designado+'="FLAVIO L PIRES") OR ('Designado+'="KAROL GURNIAK") OR ('Designado+'="WILLIAM ROBATINO")) AND (('Status*'="Em Andamento") OR ('Status*'="Pendente") OR ('Status*'="Designado"))

	(('Grupo a Designar+'="N3-INFRA-APLICACOES_AB")) AND ('Designado+'="ADRIAN L DELLATORRE") AND ('Status*'="Finalizado") AND ('Chave*+'='MONITORACAO')
	

----- Usuários e Acessos -----

-- rodar script PWASTI
	npaa4287
	
	-- GRID - utilizado no Monit Grid:
	Usuário: GRID_APPAB_RJ
	Senha: 

	https://monitgrid:7799/em/faces/logon/core-uifwk-console-login
	Usuário: oem_sysman
	Senha: oracle17
	

	-- Snapadmin - utilizado para criar as mviews:
	Usuário: snapadmin
	Senha: brsnap
	@pepbr

-- mudar o sys para owner de aplicação:

conn apr/EPPBDI#3P

-- caminho do init:

cd $ORACLE_HOME/dbs

-- para sanar o erro do ASMNET1LSNR_ASM
lsnrctl status ASMNET1LSNR_ASM e colocar o iP do description. Ex: (HOST=192.168.1.1)

Listening Endpoints Summary...
(DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=ASMNET1LSNR_ASM)))
(DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=192.168.1.1)(PORT=1525)))

grant execute on dbms_rls to BDEMQ;

	-- drop user 
	
	DROPUSERASCZCACASCADE; - CCP, EXAPRD01, EXAPRD03 e PEPRSV
	DROPUSERCMQ4CASCADE; - APLABP, APLABP08, EXAPRD01, EXAPRD02, EXAPRD03, ODSCP, PEPBR, PEPRSV e SISTP,
	DROPUSERCWBGCASCADE;
	DROPUSERCWD5CASCADE;
	DROPUSERCYCZCASCADE;
	DROPUSERELSBCASCADE;
	DROPUSERUQN6CASCADE;
	DROPUSERXVEOCASCADE;
	exec dbms_session.set_identifier('S3064632');

	--INFORMAR o acesso ao Banco de Dados
	
	exec dbms_session.set_identifier('8908929');
	
	begin
	dbms_session.set_identifier('T3686525');
	end; 
	
	 
	begin
		dbms_session.set_identifier('Atendimento ao Chamado: S599721' || to_char (sysdate, 'dd/mm/yyyy HH24:MI'));
	end;
	
	begin
		dbms_session.set_identifier('Atendimento ao ALM: 276244' || to_char (sysdate, 'dd/mm/yyyy HH24:MI'));
	end;
	
	begin
		dbms_session.set_identifier('Atendimento à Tarefa: TAS000004162735' || to_char (sysdate, 'dd/mm/yyyy HH24:MI'));
	end;
	
	-- Comando para remover espaços em branco antes de executar um CREATE VIEW, para evitar erros por conta de espaços (e-mail Cláudio 21/01/2019 16:49):
	SET SQLBLANKLINES ON;

	-- Executar script
	1 - Verificar validade e gerências do DIP
	2 - Verificar formulário de acesso anexado ao DIP
	3 - Acessar a Base (informações podem estar no Conecte)
	4 - Inserir informação de qual chamado está sendo tratado na sessão. (dbms_session)
	5 - Confirmar que o Owner informado existe na Base
	6 - Confirmar que pelo menos uma das tabelas mencionadas no Script existe no Owner informado
	7 - Comentar o(s) COMMIT(s) que existirem no Script antes da sua execução
	8 - Após a execução:
		8.1 - Sucesso: executar COMMIT
		8.2 - Erro: executar ROLLBACK
	9 - Copiar e colar LOG de Execução no Chamado/Tarefa.
	
	-- Comando para alterar senha de usuário no BD
	alter user ASJ7M1 identified by "senha_padrao04##";

	-- Comando para consultar usuários do BD
	select * from dba_users where username like '%J7M1%' 
	
	-- analisar privilegios de GRANT:
	select 'grant '||privilege||' on '||owner||'.'||table_name||' to YN42_ETL '||decode(grantable,'YES',' with grant option;',';')
	from dab_tab_privs where grantee = 'SAPGRM01';
	
	-- analisar privilegios de sinonimo:
	select 'create synonym YN42_ETL.'||synonym_name||' for '||table_owner||'.'||table_name||';'
	from dba_synonyms where owner = 'BDEMQ_INTEGRACAO_YN42';
	
	-- Chamado de SCRIPT sem OWNER
	Receber o usuário do Banco
	Executar o comando:
	Comando: alter user XPTO grant connect through asj7m1;
	Login no PLSQL: asj7m1[XPTO]
	
	-- Alterar senha de Usuário no BD
	DIP autorizando troca de senha
	"Verificar o Profile"
Renata da Silva Pfaltzgraff - PrestServ: alter user USR_STAB profile default identified by xxxx account unlock;
alter user USR_STAB profile PFL_ADM_APPLICATION; 

	-- Chave de Aplicação com problema de acesso expirado no Banco de Dados
	Provavelmente colocaram no perfil errado
	Alterar para o perfil "profile application"

	-- Criar scheduler jobs em um BD
	usuário snapadmin
	tem as uos - PEPBR, PEPBA 
	Andre Felipe Marques Baptista dos Santos - PrestServ: então 
	Andre Felipe Marques Baptista dos Santos - PrestServ: a senha é o nome da uo, sempre sem o PEP 
	Andre Felipe Marques Baptista dos Santos - PrestServ: exemplo, PEPBA, será BA 
	Andre Felipe Marques Baptista dos Santos - PrestServ: nome da uo + snap 
	Andre Felipe Marques Baptista dos Santos - PrestServ: exemplos:
		PEPBR - brsnap
		PEPBA - basnap
		PEPRNCE - rncesnap 
		
	-- Verificar/excluir execução de uma procedure em um Banco SQl Server
	Acessar o servidor
	Abrir o Management Studio
	Entrar no Activity Monitor (https://docs.microsoft.com/en-us/sql/relational-databases/performance-monitor/open-activity-monitor-sql-server-management-studio?view=sql-server-2017)
	
	
	-- Criar JOB de View Materializada 
	BEGIN
	 DBMS_SCHEDULER.CREATE_JOB(JOB_NAME => 'ACO.JOB_BLOCO_AIOP',
	 JOB_TYPE => 'PLSQL_BLOCK',
	 JOB_ACTION => 'BEGIN DBMS_MVIEW.REFRESH(LIST => ''ACO.BLOCO_AIOP'', METHOD => ''?''); END;',
	 START_DATE => TRUNC(SYSDATE) + 22 / 24,
	 REPEAT_INTERVAL => 'FREQ=DAILY;BYHOUR=22',
	 ENABLED => TRUE,
	 AUTO_DROP => FALSE,
	 COMMENTS => 'ATUALIZACAO DA TABELA ACO.BLOCO_AIOP ()');
	END;
	
	Onde:
	- ACO.BLOCO_AIOP é a view materializada informada no chamado
	- "FREQ=DAILY" atualização DIÁRIA solicitada no chamado
	- "BYHOUR=22" é o horário designado para a atualização diária
	
	-- Sobre estatísticas de BD (Performance)
	https://docs.microsoft.com/pt-br/sql/relational-databases/statistics/statistics?view=sql-server-2017
	
	SELECT name AS index_name,
	STATS_DATE(OBJECT_ID, object_id) AS StatsUpdated
	FROM sys.tables 
	WHERE OBJECT_ID = OBJECT_ID('VZFQ_BO.MESA') 
	
	-- Sobre lock em Banco
	https://www.sqlshack.com/locking-sql-server/
	
	SELECT 
 SessionID = s.Session_id,
 resource_type, 
 DatabaseName = DB_NAME(resource_database_id),
 request_mode,
 request_type,
 login_time,
 host_name,
 program_name,
 client_interface_name,
 login_name,
 nt_domain,
 nt_user_name,
 s.status,
 last_request_start_time,
 last_request_end_time,
 s.logical_reads,
 s.reads,
 request_status,
 request_owner_type,
 objectid,
 dbid,
 a.number,
 a.encrypted ,
 a.blocking_session_id,
 a.text 
	 FROM 
		 sys.dm_tran_locks l
		 JOIN sys.dm_exec_sessions s ON l.request_session_id = s.session_id
		 LEFT JOIN 
		 (
			 SELECT*
			 FROMsys.dm_exec_requests r
			 CROSS APPLY sys.dm_exec_sql_text(sql_handle)
		 ) a ON s.session_id = a.session_id;
	
	-- Verificar Backups de um BD
	SELECT 
	CONVERT(CHAR(100), SERVERPROPERTY('Servername')) AS Server, 
	msdb.dbo.backupset.database_name, 
	msdb.dbo.backupset.backup_start_date, 
	msdb.dbo.backupset.backup_finish_date, 
	msdb.dbo.backupset.expiration_date, 
	CASE msdb..backupset.type 
	WHEN 'D' THEN 'Database' 
	WHEN 'L' THEN 'Log' 
	END AS backup_type, 
	msdb.dbo.backupset.backup_size, 
	msdb.dbo.backupmediafamily.logical_device_name, 
	msdb.dbo.backupmediafamily.physical_device_name, 
	msdb.dbo.backupset.name AS backupset_name, 
	msdb.dbo.backupset.description 
	FROM msdb.dbo.backupmediafamily 
	INNER JOIN msdb.dbo.backupset ON msdb.dbo.backupmediafamily.media_set_id = msdb.dbo.backupset.media_set_id 
	WHERE (CONVERT(datetime, msdb.dbo.backupset.backup_start_date, 102) >= GETDATE() - 7) 
	ORDER BY 
	msdb.dbo.backupset.database_name, 
	msdb.dbo.backupset.backup_finish_date 
	
	-- Verificar o andamento dos processos
	SELECT command,

'EstimatedEndTime' = Dateadd(ms,estimated_completion_time,Getdate()),

'EstimatedSecondsToEnd' = estimated_completion_time / 1000,

'EstimatedMinutesToEnd' = estimated_completion_time / 1000 / 60,

'BackupStartTime' = start_time,

'PercentComplete' = percent_complete

FROM sys.dm_exec_requests
	WHERE session_id = SPID
	
	-- Instância Nomeada e Instância Padrão
	https://jvilar.wordpress.com/2017/02/13/estancia-padrao-x-estancia-nomeada-sql-server/
	
	-- Status e Descrição de cada dos TASK STATES do Activity Monitor (SQL Server)
	Status 	Meaning
	Background 	The SPID is running a background task, such as deadlock detection.
	Sleeping 	The SPID is not currently executing. This usually indicates that the SPID is awaiting a command from the application.
	Running 	The SPID is currently running on a scheduler.
	Runnable 	The SPID is in the runnable queue of a scheduler and waiting to get scheduler time.
	Sos_scheduler_yield 	The SPID was running, but it has voluntarily yielded its time slice on the scheduler to allow another SPID to acquire scheduler time.
	Suspended 	The SPID is waiting for an event, such as a lock or a latch.
	Rollback 	The SPID is in rollback of a transaction.
	Defwakeup 	Indicates that the SPID is waiting for a resource that is in the process of being freed. The waitresource field should indicate the resource in question.
	
	-- Sobre lock em Banco, como identificar e tratar
	https://solutioncenter.apexsql.com/techniques-to-identify-blocking-queries-and-other-causes-of-sql-server-blocks/
	
	-- Pesquisar por objetos (Procedure, Functions, Packages, etc)
	SELECT * FROM ALL_OBJECTS WHERE OBJECT_TYPE IN ('FUNCTION','PROCEDURE','PACKAGE')
	
	-- Solicitação de criação de usuários em BD
	Os DBAs da aplicação referente a base integrada (PEPBR, PEPRIO, PEPBC, PEPBS, PEPES, PEPBSOL, PEPRNCE, PEPSEAL, PEPBA): 
	 Y16N - Alexandre, Y2GA - MAGALI, Y9MX- DIEGO, XDAE-Claudio 
	
	-- Criar tablespace em BD
	- Usar chave SYS
	tablespace nome_tablespace
	logging
	datafile '+DG_DAT01' 
	size 1g 
	autoextend on 
	next 16m maxsize 30g
	extent management local; 
	
-- comando para dropar dados de um schema
SELECT 'DROP TABLE '|| OWNER||'.'||TABLE_NAME || ' CASCADE CONSTRAINTS PURGE;' FROM DBA_TABLES WHERE OWNER IN ('SCH_SEAN');
SELECT 'DROP ' || OBJECT_TYPE || ' ' || OWNER||'.'||OBJECT_NAME || ';' FROM DBA_OBJECTS WHERE OWNER IN ('SCH_SEAN')
AND OBJECT_TYPE NOT IN ('TABLE','INDEX') AND OBJECT_NAME NOT LIKE 'BIN$%' AND OBJECT_NAME NOT LIKE '%$$' ORDER BY object_name;
SELECT 'DROP ' || OBJECT_TYPE || ' ' || OWNER||'.'||OBJECT_NAME || ';' FROM DBA_OBJECTS WHERE OWNER IN ('SCH_SEAN') AND OBJECT_TYPE='SYNONYM';
	
-- query para verificar eventos/sessões que estão com o status "Failed Logon Delay"
select s.sid,w.event,s.machine, s.usernamefrom gv$session_wait w,
gv$session s
where w.sid = s.sid
and s.event like '%Failed Logon Delay%'
order by 1, 2, 3
	
--TBS Alocar espaço emtablespace - TBS
	alter tablespace ORASTATUS_D_01 add datafile '/oracle/sicarhmg/dbf/sicarhmg_orastatus_02.ora' size 8m autoextend on next 16m maxsize 30g;
	ALTER TABLESPACE PJUR_D_01  ADD DATAFILE '+DG_DAT01' size 1024M reuse autoextend on next 16M maxsize 32767m;
	alter tablespace UE6JO_DADOS add tempfile '+DG_DAT01' size 1024m autoextend on next 200m maxsize 32767m;
	alter tablespace TEMP add tempfile '+DATAC1' size 1024m autoextend on next 200m maxsize 32767m;
	alter tablespace TEMP add tempfile '+DATAC1' size 1024m autoextend on next 200m maxsize unlimited;
	alter tablespace APR_DADOS add datafile '+DATAC3' size 8m autoextend on next 16m maxsize 32767m;
	alter tablespace ORASTATUS_D_01 add datafile '+DATAC1' size 8m autoextend on next 16m maxsize 32767m;
	
erro ORA-01630: max # extents (505) reached in temp segment in tablespace RSV_DADOS
ALTER TABLESPACE RSV_DADOS DEFAULT STORAGE ( MAXEXTENTS UNLIMITED);

exec dbms_session.set_identifier('8924955');
	
SELECT TBS.TABLESPACE_NAME,
TBS.PERC_USED,
TBS.MB_FREE,
(CASE WHEN TBS.PERC_USED > 90 THEN (CASE WHEN TBS.MB_FREE < 10240 THEN 2
WHEN TBS.MB_FREE < 12288 THEN 1
ELSE 0 END)
ELSE 0 END ) STATUS
FROM (SELECT DFE.TABLESPACE_NAME,
ROUND(((DFE.ALOCADO - DFE.LIVRE) / DFE.TAM_MAXIMO) * 100, 2) PERC_USED,
(DFE.TAM_MAXIMO - (DFE.ALOCADO - DFE.LIVRE)) MB_FREE
FROM (SELECT DF.TABLESPACE_NAME,
DF.ALOCADO,
DF.TAM_MAXIMO,
ROUND(SUM(nvl(DFS.BYTES,0)) /1024/1024, 2) LIVRE
FROM DBA_FREE_SPACE DFS,
DBA_TABLESPACES DT,
(SELECT TABLESPACE_NAME,
ROUND(SUM(BYTES) /1024/1024, 2) ALOCADO,
ROUND(SUM(GREATEST(BYTES, MAXBYTES)) /1024/1024, 2) TAM_MAXIMO
FROM DBA_DATA_FILES
GROUP BY TABLESPACE_NAME) DF
WHERE DFS.TABLESPACE_NAME(+) = DF.TABLESPACE_NAME
AND DF.TABLESPACE_NAME = DT.TABLESPACE_NAME
AND DT.CONTENTS NOT IN ('TEMPORARY','UNDO')
AND DF.TABLESPACE_NAME = 'ORASTATUS_D_01'
GROUP BY DF.TABLESPACE_NAME, DF.ALOCADO, DF.TAM_MAXIMO) DFE) TBS;

-- select para filtrar a TEMP:
select a.TEMP tablespace,
d.TEMP_TOTAL_GB,
sum (a.used_blocks * d.block_size) / 1024 / 1024TEMP_USED_MB,
d.TEMP_TOTAL_GB - sum (a.used_blocks * d.block_size) / 1024 / 1024TEMP_FREE_GB
from v$sort_segment a,
(
select b.name, c.block_size, sum (c.bytes) / 1024 / 1024 TEMP_TOTAL_GB
from v$tablespace b, v$tempfile c
where b.ts#= c.ts#
group by b.name, c.block_size
) d
where a.tablespace_name = d.name
group by a.tablespace_name, d.TEMP_TOTAL_GB;

-- Verificar quais são os datafiles de uma tbs:
set lines 200
column file_name format a55
select file_name,(bytes/1024/1024) from dba_data_files where tablespace_name like '%UNDO%';
	
-- Verificar se uma tablespace está como Autoextend
select TABLESPACE_NAME, FILE_NAME,AUTOEXTENSIBLE,MAXBYTES/1024/1024/1024 from dba_Data_files where TABLESPACE_NAME like '%SYSTEMPRIM%';

-- todas as TBS do banco:	
SELECT t.tablespace
,t.totalspace AS " Totalspace(MB)"
,round((t.totalspace - fs.freespace), 2) AS "Used Space(MB)"
,fs.freespace AS "Freespace(MB)"
,round(((t.totalspace - fs.freespace) / t.totalspace) * 100, 2) AS "% Used"
,round((fs.freespace / t.totalspace) * 100, 2) AS "% Free"
FROM (SELECT round(SUM(d.bytes) / (1024 * 1024)) AS totalspace
,d.tablespace_name tablespace
FROM dba_data_files d
GROUP BY d.tablespace_name) t
,(SELECT round(SUM(f.bytes) / (1024 * 1024)) AS freespace
,f.tablespace_name tablespace
FROM dba_free_space f
GROUP BY f.tablespace_name) fs
WHERE t.tablespace = fs.tablespace and t.tablespace like '%TEMP%'
ORDER BY t.tablespace;


SELECT tbm.TABLESPACE_NAME,
round(tbm.USED_SPACE * tb.BLOCK_SIZE /(1024*1024*1024),2) USED_SPACE_GB,
round(tbm.TABLESPACE_SIZE * tb.BLOCK_SIZE /(1024*1024*1024),2) TABLESPACE_SIZE_GB,
ROUND((TBM.TABLESPACE_SIZE - TBM.USED_SPACE) * TB.BLOCK_SIZE /(1024*1024*1024),2) TABLESPACE_FREE_GB,
round(tbm.USED_PERCENT ,2) AS "USED_%"
FROM dba_tablespace_usage_metrics tbm,
dba_tablespaces tb
where TB.TABLESPACE_NAME = TBM.TABLESPACE_NAME
AND TBM.TABLESPACE_NAME like '%' ORDER BY TB.TABLESPACE_NAME;
	
SELECT tbm.TABLESPACE_NAME,
round(tbm.USED_SPACE * tb.BLOCK_SIZE /(1024*1024),2) USED_SPACE_GB,
round(tbm.TABLESPACE_SIZE * tb.BLOCK_SIZE /(1024*1024),2) TABLESPACE_SIZE_GB,
ROUND((TBM.TABLESPACE_SIZE - TBM.USED_SPACE) * TB.BLOCK_SIZE /(1024*1024),2) TABLESPACE_FREE_SIZE_GB,
round(tbm.USED_PERCENT ,2)
FROM dba_tablespace_usage_metrics tbm,
dba_tablespaces tb
where TB.TABLESPACE_NAME = TBM.TABLESPACE_NAME 
AND TBM.TABLESPACE_NAME like '%TEMP%' ORDER BY TBM.TABLESPACE_NAME;

-----------------------------------------

set lines 2000
SELECT t.tablespace
,t.totalspace AS " Totalspace(MB)"
,round((t.totalspace - fs.freespace), 2) AS "Used Space(MB)"
,fs.freespace AS "Freespace(MB)"
,round(((t.totalspace - fs.freespace) / t.totalspace) * 100, 2) AS "% Used"
,round((fs.freespace / t.totalspace) * 100, 2) AS "% Free"
FROM (SELECT round(SUM(d.bytes) / (1024 * 1024)) AS totalspace
,d.tablespace_name tablespace
FROM dba_data_files d
GROUP BY d.tablespace_name) t
,(SELECT round(SUM(f.bytes) / (1024 * 1024)) AS freespace
,f.tablespace_name tablespace
FROM dba_free_space f
GROUP BY f.tablespace_name) fs
WHERE t.tablespace = fs.tablespace and t.tablespace like '%SYSAUX%'
ORDER BY t.tablespace;

SELECT tablespace_name, encrypted, status FROM dba_tablespaces where tablespace_name like '%CFORM%';

-- verificar bigfile:
select tablespace_name, bigfile from dba_tablespaces;

select BIGFILE from dba_tablespaces where tablespace_name='FPSOREPL_PMDB_DAT1';

select TABLESPACE_NAME, FILE_NAME,AUTOEXTENSIBLE,MAXBYTES/1024/1024/1024 from dba_Data_files where TABLESPACE_NAME like '%FPSOREPL_PMDB_DAT1%';

alter database datafile '+DG_DAT01/vcxlh/datafile/vcxlh_spp_eod_data_01.ora' resize 550600m;

ALTER TABLESPACE FPSOREPL_PMDB_DAT1 RESIZE 50G;

-- As maiores tabelas do banco:
column SEGMENT_NAME format a30
column SEGMENT_TYPE format a15
column TABLESPACE_NAME format a30
SELECT * FROM
(select
SEGMENT_NAME,
SEGMENT_TYPE,
BYTES/1024/1024/1024 GB,
TABLESPACE_NAME
from
dba_segments
order by 3 desc ) WHERE
ROWNUM <= 20;


--tempfile usada
SELECT A.tablespace_name tablespace, D.mb_total,
SUM (A.used_blocks * D.block_size) / 1024 / 1024 mb_used,
D.mb_total - SUM (A.used_blocks * D.block_size) / 1024 / 1024 mb_free
FROM v$sort_segment A,
(
SELECT B.name, C.block_size, SUM (C.bytes) / 1024 / 1024 mb_total
FROM v$tablespace B, v$tempfile C
WHERE B.ts#= C.ts#
GROUP BY B.name, C.block_size) D
WHERE A.tablespace_name = D.name
GROUP by A.tablespace_name, D.mb_total;

-- mudar tablspace default do banco
ALTER DATABASE DEFAULT TEMPORARY TABLESPACE temp;

-- tempfiles
select file_name,tablespace_name,bytes/1024/1024/1024, maxbytes/1024/1024/1204,autoextensible from dba_temp_files;

-- comando para criar uma TBS temp:
CREATE TEMPORARY TABLESPACE TEMP TEMPFILE '+DG_DAT01' size 8m reuse autoextend on next 16m maxsize 30G;
		
	-- Script SQL para verificar backups de um Banco
	select
		to_char(j.start_time, 'yyyy-mm-dd hh24:mi:ss') Início,
		to_char(j.end_time, 'yyyy-mm-dd hh24:mi:ss') Fim,
		j.status, j.input_type Tipo_de_BKP,
		decode(to_char(j.start_time, 'd'), 1, 'Domingo', 2, 'Segunda-Feira',
						 3, 'Terça-Feira', 4, 'Quarta-Feira',
						 5, 'Quinta-Feira', 6, 'Sexta-Feira',
						 7, 'Sábado') Dia_da_semana
	from V$RMAN_BACKUP_JOB_DETAILS j
		left outer join (select
				 d.session_recid, d.session_stamp,
				 sum(case when d.controlfile_included = 'YES' then d.pieces else 0 end) CF,
				 sum(case when d.controlfile_included = 'NO'
					 and d.backup_type||d.incremental_level = 'D' then d.pieces else 0 end) DF,
				 sum(case when d.backup_type||d.incremental_level = 'D0' then d.pieces else 0 end) I0,
				 sum(case when d.backup_type||d.incremental_level = 'I1' then d.pieces else 0 end) I1,
				 sum(case when d.backup_type = 'L' then d.pieces else 0 end) L
				 from
				 V$BACKUP_SET_DETAILS d
				 join V$BACKUP_SET s on s.set_stamp = d.set_stamp and s.set_count = d.set_count
				 where s.input_file_scan_only = 'NO'
				 group by d.session_recid, d.session_stamp) x
		on x.session_recid = j.session_recid and x.session_stamp = j.session_stamp
		left outer join (select o.session_recid, o.session_stamp, min(inst_id) inst_id
				 from GV$RMAN_OUTPUT o
				 group by o.session_recid, o.session_stamp)
		ro on ro.session_recid = j.session_recid and ro.session_stamp = j.session_stamp
	where j.start_time > trunc(sysdate)-50
	--and j.input_type = 'DB FULL'
	order by j.start_time desc; 
	
	-- Query para verificar o que está rodando na Base de Dados.
	W: -> query_sessao
	
	-- Query para encontrar o caminho para os arquivos de trace
	SELECT VALUE FROM V$DIAG_INFO
	https://docs.oracle.com/cd/B28359_01/server.111/b28310/diag006.htm#ADMIN12484
	
	-- Resolvendo problemas de conexão com o servidor LDAP (ORA28030)
	https://blog.pythian.com/troubleshoot-ora-28030-error/
	
	-- Explicando o nome dos arquivos trace
	https://gerardnico.com/db/oracle/trace_file
	
	-- SELECT para encontrar o caminho do Trace
	SELECT p.tracefile
	FROM v$session s
		 JOIN v$process p ON s.paddr = p.addr
	WHEREs.sid = 337;
	Link: https://oracle-base.com/articles/misc/sql-trace-10046-trcsess-and-tkprof
	
	-- SELECT para verificar o conteúdo do trace file
	SELECT payload
	FROM v$diag_trace_file_contents
	WHEREtrace_filename = 'depbc_w00b_87624.trc'
	ORDER BY line_number;
	
	-- Comando para criar uma trigger de logon para gerar Trace
	DROP TRIGGER "UCFORM"."TRACE_LOGON" 

		CREATE OR REPLACE TRIGGER "UCFORM"."TRACE_LOGON" 
		 AFTER LOGON ON UCFORM.SCHEMA
		BEGIN
		/*
		ESTE TRIGGER DESTINA-SE A GERAR TRACE DAS SESSOES DURANTE O TESTE DE PERFORMANCE.
		CRIADO EM17/12/2018 POR Y6QT BRUNO SOUZA
		*/

		EXECUTE IMMEDIATE 'ALTER SESSION SET TRACEFILE_IDENTIFIER='||CHR(39)||'UCFORM_'||CHR(39);
		EXECUTE IMMEDIATE 'ALTER SESSION SET SQL_TRACE = TRUE';
		EXECUTE IMMEDIATE 'ALTER SESSION SET EVENTS ''17_12 trace UCFORM''';

		END;
		/ 

	
	-- Gerar Trace em uma sessão
	--LIGAR
	-- No SQLPLUS, direto no servidor
	EXECUTE dbms_system.set_sql_trace_in_session (SID, SERIAL#, TRUE);
	--DESLIGAR
	EXECUTE dbms_system.set_sql_trace_in_session (SID, SERIAL#, FALSE); 
	--The values for SID and SERIAL# can be found using the V$SESSION view.
	--No PLSQL (IDE)
	begin
	dbms_system.set_sql_trace_in_session (SID, SERIAL#, TRUE);
	end;
	
	-- Descobrir e logar no SQL direto do servidor
	ps -ef | grep pmon 
	echo $ORACLE_SID 
	export ORACLE_SID= nome da instância 
	sqlplus / as sysdba
	
	-- Verificar GRANTS e Privilégios ORACLE
	https://stackoverflow.com/questions/1298473/how-can-i-list-all-grants-a-user-received
	
	Direct grants to tables/views:
	SELECT owner, table_name, select_priv, insert_priv, delete_priv, update_priv, references_priv, alter_priv, index_priv 
	FROM table_privileges
	 WHERE grantee = <theUser>
	 ORDER BY owner, table_name;
	 
	-- Oracle Network Configuration
	https://oracle-base.com/articles/misc/oracle-network-configuration	
	
	-- Query para coletar o texto de um PACKAGE
	Link: https://stackoverflow.com/questions/14212295/how-to-see-pl-sql-stored-function-body-in-oracle
	select text from all_source where name = <nome_do_pacote> 
	and type = 'PACKAGE BODY'
	order by line;
	
	-- CPU e Memoria:
	sar 2 10
	free -g
	
--Nota para verificar a configuração do -huge pages
401749.1
	
logado com root -vi hugepages_settings.sh

#!/bin/bash
#
# hugepages_settings.sh
#
# Linux bash script to compute values for the
# recommended HugePages/HugeTLB configuration
# on Oracle Linux
#
# Note: This script does calculation for all shared memory
# segments available when the script is run, no matter it
# is an Oracle RDBMS shared memory segment or not.
#
# This script is provided by Doc ID 401749.1 from My Oracle Support
# http://support.oracle.com

# Welcome text
echo "
This script is provided by Doc ID 401749.1 from My Oracle Support
(http://support.oracle.com) where it is intended to compute values for
the recommended HugePages/HugeTLB configuration for the current shared
memory segments on Oracle Linux. Before proceeding with the execution please note following:
 * For ASM instance, it needs to configure ASMM instead of AMM.
 * The 'pga_aggregate_target' is outside the SGA and
 you should accommodate this while calculating the overall size.
 * In case you changes the DB SGA size,
 as the new SGA will not fit in the previous HugePages configuration,
 it had better disable the whole HugePages,
 start the DB with new SGA size and run the script again.
And make sure that:
 * Oracle Database instance(s) are up and running
 * Oracle Database 11g Automatic Memory Management (AMM) is not setup
 (See Doc ID 749851.1)
 * The shared memory segments can be listed by command:
 # ipcs -m


Press Enter to proceed..."

read

# Check for the kernel version
KERN=`uname -r | awk -F. '{ printf("%d.%d\n",$1,$2); }'`

# Find out the HugePage size
HPG_SZ=`grep Hugepagesize /proc/meminfo | awk '{print $2}'`
if [ -z "$HPG_SZ" ];then
echo "The hugepages may not be supported in the system where the script is being executed."
exit 1
fi

# Initialize the counter
NUM_PG=0

# Cumulative number of pages required to handle the running shared memory segments
for SEG_BYTES in `ipcs -m | cut -c44-300 | awk '{print $1}' | grep "[0-9][0-9]*"`
do
MIN_PG=`echo "$SEG_BYTES/($HPG_SZ*1024)" | bc -q`
if [ $MIN_PG -gt 0 ]; then
NUM_PG=`echo "$NUM_PG+$MIN_PG+1" | bc -q`
fi
done

RES_BYTES=`echo "$NUM_PG * $HPG_SZ * 1024" | bc -q`

# An SGA less than 100MB does not make sense
# Bail out if that is the case
if [ $RES_BYTES -lt 100000000 ]; then
echo "***********"
echo "** ERROR **"
echo "***********"
echo "Sorry! There are not enough total of shared memory segments allocated for
HugePages configuration. HugePages can only be used for shared memory segments
that you can list by command:

# ipcs -m

of a size that can match an Oracle Database SGA. Please make sure that:
 * Oracle Database instance is up and running
 * Oracle Database 11g Automatic Memory Management (AMM) is not configured"
exit 1
fi

# Finish with results
case $KERN in
'2.4') HUGETLB_POOL=`echo "$NUM_PG*$HPG_SZ/1024" | bc -q`;
 echo "Recommended setting: vm.hugetlb_pool = $HUGETLB_POOL" ;;
'2.6') echo "Recommended setting: vm.nr_hugepages = $NUM_PG" ;;
'3.8') echo "Recommended setting: vm.nr_hugepages = $NUM_PG" ;;
'3.10') echo "Recommended setting: vm.nr_hugepages = $NUM_PG" ;;
'4.1') echo "Recommended setting: vm.nr_hugepages = $NUM_PG" ;;
'4.14') echo "Recommended setting: vm.nr_hugepages = $NUM_PG" ;;
'4.18') echo "Recommended setting: vm.nr_hugepages = $NUM_PG" ;;
'5.4') echo "Recommended setting: vm.nr_hugepages = $NUM_PG" ;;
*) echo "Kernel version $KERN is not supported by this script (yet). Exiting." ;;
esac

# End
	
da a permissão: chmod +x hugepages_settings.sh - para soltar o comando é ./hugepages_settings.sh

pega o valor recomendado e multiplica por 2048 para verificar o que esta sendo consumido

vi /etc/sysctl.conf e coloca o valor recomendado.
	
Validação: grep HugePages_ /proc/meminfo
comando para validar novo valor da hugepages - logado com root para diminuir o valor: sysctl -p

vm.nr_hugepages = 10243
vm.nr_hugepages = 10245

cat /etc/sysctl.conf|grep huge

-- shared memory:

ipcs -m

lsof | egrep "287604742|COMMAND"

ps -ef|egrep "325733|325737|325739|325740|325741" aqui foi realizado o kill -9 nessas sessões.

		
	-- caminho dos scripts do netbkp funcional: oracle@s6006db326:/u01/app/oracle/admin/hepba/scripts/backup
		
	-- tamanho da base:
	select sum(bytes) / 1024 / 1024 / 1024 tamanho_GB from dba_segments;
	select sum(bytes) /1073741824TAMANHO_GB from dba_segments;
	select sum(bytes/1024/1024/1024) GB from v$datafile;
	
	-- tamanho do banco por tablespace
	select tablespace_name, sum(bytes) / 1024 / 1024 / 1024 tamanho_GB from dba_segments group by tablespace_name;
	
	-- Tabelas com Privilégios e GRANTS
	dba_tab_privs
	dba_role_privs
	
	-- Regras e informações sobre todos os tipos de Joins
	https://docs.oracle.com/cd/B19306_01/server.102/b14200/queries006.htm#sthref3178
	
	-- Verificar objetos de um Owner
	select * fromdba_objects WHERE owner = 'ASDF';

	
	-- Exemplo de query que concatena uma coluna de várias linhas diferentes com GROUP BY
	-- Essa query, por exemplo, retorna todo o comando de um SQL Statement específico
	-- O delimitador (segundo parâmetro de LISTAGG) é opcional
	SELECT
	SQL_ID,
	LISTAGG(SQL_TEXT)
	WITHIN GROUP (ORDER BY PIECE) "SQL_TEXT"
	FROM V$SQLTEXT
	where sql_id = '3f93xchb7n88g'
	GROUP BY SQL_ID;
	
	-- Ou esse
	select sql_text
	from DBA_HIST_SQLTEXT
	where sql_id = '3f93xchb7n88g';
	
	-- Select para verificar o tamanho de cada Disk Group (DG_DAT01, por exemplo)
	-- O "G" antes de "v$asm_diskgroup" serve para pesquisar em todas as pernas do servidor RAC
	select name, BLOCK_SIZE, TOTAL_MB, FREE_MB,USABLE_FILE_MB from gv$asm_diskgroup; 
	
	-- Select para mostrar o consumo do UNDO
	select ee.owner,
 tablespace_name tablespace,
 status,
 sum(bytes) / 1024 / 1024 sum_in_mb,
 count(*) counts
	 from dba_undo_extentsee
	 group by tablespace_name, status,ee.owner
	 order by 1, 2;
	
	-- Link foda sobre consumo de UNDO
	http://www.oraclenerd.com/2009/11/undo-brain-damage.html
	
	-- Select para ver o Nome do Banco e da Instância
	select * from gv$database
	select * from gv$instance
	
	-- Histórico da Undo
	select * from DBA_HIST_UNDOSTAT where begin_time > trunc(sysdate)
	
	-- Alterar duração máxima de execução de um JOB
	BEGIN
	sys.dbms_scheduler.set_attribute('JOB_ADM_ANALYZE_FULL','max_run_duration',INTERVAL '0 4:00:00' DAY TO SECOND);
	END;
	
	
	set long 9999999
	select dbms_metadata.get_ddl('USER','UCFORM')||';' from dual;
	SELECT DBMS_METADATA.GET_GRANTED_DDL('ROLE_GRANT','REDOTRANS')||';' FROM DUAL;
	SELECT DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','REDOTRANS')||';' FROM DUAL;
	SELECT DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','REDOTRANS') ||';' FROM DUAL;
	
	-- Localização do TNS no servidor de Banco
	cd /u01/app/oracle/product/11.2.0.4/db_1/network/admin
	cat tnsnames.ora
	
	-- Select para encontrar os SERVICE NAMES do Banco
	select * from dba_services;
	
	-- Select para pegar o DDL de Objetos
	select dbms_metadata.get_ddl('MATERIALIZED_VIEW', 'nomeObjeto' ,'Owner') from dual;
	
	-- Comando para verificar se tem mais de um Import rodando no SO
	ps -ef | grep -i impdp
	
	-- Verificar o uso das Tablespaces
	select df.tablespace_name "Tablespace",
	totalusedspace "Used MB",
	(df.totalspace - tu.totalusedspace) "Free MB",
	df.totalspace "Total MB",
	round(100 * ( (df.totalspace - tu.totalusedspace)/ df.totalspace))
	"Pct. Free"
	from
	(select tablespace_name,
	round(sum(bytes) / 1048576) TotalSpace
	from dba_data_files
	group by tablespace_name) df,
	(select round(sum(bytes)/(1024*1024)) totalusedspace, tablespace_name
	from dba_segments
	group by tablespace_name) tu
	where df.tablespace_name = tu.tablespace_name 
	order by "Free MB";
	
	--Objetos Inválidos no dba_errors
	Verificar o status na tabela dba_objects
	Consultar qual o servidor em v$instance
	Acessa o servidor via SO
	cd $ORACLE_HOME/RDBMS/admin 
	Logar no sqlplus
	Executar: @utlrp
	
	-- SELECT ACL 
	select * from dba_network_acl_privileges;
select * from dba_network_acls;

	-- Create ACL
	begin
	dbms_network_acl_admin.create_acl (
		acl => 'usp_sga_envia_email.xml',
		description => 'Permitir envio de email USAG',
		principal => 'USAG',
		is_grant=> TRUE,
		privilege => 'connect'
		);
		commit;
	end;

	begin
	dbms_network_acl_admin.add_privilege (
	acl => 'usp_sga_envia_email.xml',
	principal => 'USAG',
	is_grant=> TRUE,
	privilege => 'resolve'
	);
	commit;
	end;

	begin
	dbms_network_acl_admin.assign_acl(
	acl=> 'usp_sga_envia_email.xml',
	host => 'mailhost.ep.petrobras.com.br',
	lower_port => 25
	 );
	commit;
	end;
	
	-- ACL
	begin
		dbms_network_acl_admin.add_privilege (
		acl => '/sys/acls/usp_sga_envia_email.xml',
		principal => 'USAG',
		is_grant=> TRUE,
		privilege => 'resolve'
		);
		commit;
end; 

	begin
		dbms_network_acl_admin.add_privilege (
		acl => '/sys/acls/usp_sga_envia_email.xml',
		principal => 'USAG',
		is_grant=> TRUE,
		privilege => 'connect'
		);
		commit;
	end;
	
	-- DROP ACL
	BEGIN
	DBMS_NETWORK_ACL_ADMIN.drop_acl (acl => 'usp_sga_envia_email.xml');
	COMMIT;
	END;
	
	-- Teste envio de E-mail
	begin 
	SCH_P299.USP_SGA_ENVIA_EMAIL('adrian.dellatorre.indra@petrobras.com.br', 'adrian.dellatorre.indra@petrobras.com.br',' adrian.', 'Dellatorre');
		dbms_output.put_line(sqlerrm);
	exception
	 when others then 
		dbms_output.put_line(sqlerrm);
	end; 
		
	-- Local do TNS no servidor ORACLE SQL
	cd $ORACLE_HOME/network/admin
	
	-- Encontrar caminho do listener.ora
	lsnrctl status
	
	-- Incluir Quota para o usuário
	alter user xxxx quota 100M on tablespace
	alter user ASRTAR quota 50m on USERS;
	
	-- Tabela que guarda o HASH da senha dos usuários (PASSWORD)
	SELECT * FROM sys.user$ WHERE NAME = 'ADUPNZ';
	
	-- dblink
	
	-- Comando para pesquisar DB Links disponíveis
	set linesize 500
	set pagesize 1000
	col DB_LINK for a40
	col HOST for a20
	select OWNER, DB_LINK, USERNAME, HOST,
	to_char(CREATED,'MM/DD/YYYY HH24:MI:SS') Criacao
	from dba_db_links
	order by OWNER, DB_LINK;
	
	COL OWNER FORMAT a10
	COL USERNAME FORMAT A8 HEADING "USER"
	COL DB_LINK FORMAT A30
	COL HOST FORMAT A7 HEADING "SERVICE"
	SELECT * FROM DBA_DB_LINKS
	/
	
	COL DB_LINK FORMAT A25
	COL OWNER_ID FORMAT 99999 HEADING "OWNID"
	COL LOGGED_ON FORMAT A5 HEADING "LOGON"
	COL HETEROGENEOUS FORMAT A5 HEADING "HETER"
	COL PROTOCOL FORMAT A8
	COL OPEN_CURSORS FORMAT 999 HEADING "OPN_CUR"
	COL IN_TRANSACTION FORMAT A3 HEADING "TXN"
	COL UPDATE_SENT FORMAT A6 HEADING "UPDATE"
	COL COMMIT_POINT_STRENGTH FORMAT 99999 HEADING "C_P_S"
	SELECT * FROM V$DBLINK
	/
	
	-- Comando para criar um DB Link
	CREATE DATABASE LINK nome_do_dblink
	CONNECT TO usuário_banco_remoto IDENTIFIED BY senha
	USING 'connect_string';
	-- Connect_String é o nome da conexão dentro do TNS
	-- "Identifed BY é opcional" A senha do Identifed BY é a senha do destino. Por ex: 
	CREATE DATABASE LINK HEPBR
	CONNECT TO SNAPADMIN IDENTIFIED BY brsnap
	USING 'HEPBR';
	-- significa que a senha do SNAPADMIN tem que ser a da base HEPBR que é o destino. 
	
	-- Validar DBLINK
	select sysdate from dual@REP_EPBA;
	select * from dual@select * from dual@"SYS_HUB"
	
	-- Validar DBLINK senha criptografado:
	set long 9999999
	select dbms_metadata.get_ddl('USER','E002_LNK')||';' from dual;

	SELECT DBMS_METADATA.GET_GRANTED_DDL('ROLE_GRANT','E002_LNK')||';' FROM DUAL;
	SELECT DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','E002_LNK')||';' FROM DUAL;
	SELECT DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','E002_LNK') ||';' FROM DUAL;
	
	ALTER USER "MCOR" IDENTIFIED BY VALUES 'S:3C79B5DA132517CE58C253CAC7F590744399E1C151B0E48461D2E0FD9785;7317103D8D4B9A20' account unlock;
	
	-- usuario dblink - sicar
	CREATE USER "RPREV_LNK" IDENTIFIED BY VALUES 'S:1D3F8877BF6D80F2097A7854B08D03E0FFD1306E0CE03AA8779EBC87A441;3BFE3F48EE9A6A9D'
DEFAULT TABLESPACE "USERS"
TEMPORARY TABLESPACE "TEMP"
PROFILE "PFL_ADM_APPLICATION";
	
	CREATE USER "E002_LNK" IDENTIFIED BY VALUES 'S:CA37983DB794F3641F783DCE8528EDC2A695BDB38FCFAB2B10BB3BE7E435;F136BC7A112340AB'
DEFAULT TABLESPACE "USERS"
TEMPORARY TABLESPACE "TEMP"
PROFILE "PFL_ADM_APPLICATION";

	
	-- Exemplo de Connection String no TNS
	(DESCRIPTION =
(ADDRESS = (PROTOCOL = TCP)(HOST = NOME_SERVIDOR_DE_BANCO)(PORT = 1521))
(CONNECT_DATA =
(SERVER = DEDICATED)
(SERVICE_NAME = TESTE)
)
	)
	
	-- A SYS.LINK$ é uma tabela interna do banco de dados que contém todas as informações sobre db_links do banco de dados
	SELECT NAME,HOST,USERID,PASSWORD FROM SYS.LINK$;
	
	-- Verificar entrada do TNS de um DBLink
	1 - Logar no Servidor
	2 - Ir no diretório/u01/app/oracle/product/12.2.0.1/db_1/network/admin
	3 - more tnsnames.ora
	
	
	-- Links úteis
	https://vidadba.wordpress.com/2016/11/24/criando-e-administrando-dblinks-no-oracle/
	http://cooperati.com.br/2013/02/22/oracle-criando-um-dblink/
	https://www.devmedia.com.br/criacao-de-database-links/2748
	
	--------------------------------------------------------
	
	----------Realizar cópia de BD entre ambientes----------
	- Acessar a base de produção e verificar o tamanho do export
	select sum(bytes)/1024/1024/1024 as GB from dba_segments where owner = 'SGER' 
	
	
	
	--------------------------------------------------------
------------------------------

--Atualização de Versão do Oracle--
https://www.oracle.com/technetwork/pt/articles/database-performance/banco-de-dados-oracle-11g-a-12c-2996704-ptb.html
https://www.oracle.com/technetwork/pt/articles/database-performance/upgrade-oracle-db-11gr2-para-12c-2181146-ptb.html
-----------------------------------

https://oer.petrobras.com.br/oer/index.jsp


-- NAS
mount -o rw,bg,hard,rsize=32768,wsize=32768,vers=3,nointr,timeo=600,tcp s6006fs14:/vol/DBA_NFS_DUMP_SPSCO /oracle_dump
mount -o rw,bg,hard,rsize=32768,wsize=32768,vers=3,nointr,timeo=600,tcp s6006vfs0601:/PRD_PWSATI_002/PRD_PWSATI_002 /oracle_bkp/cipd
mount -o rw,bg,hard,rsize=32768,wsize=32768,vers=3,nointr,timeo=600,tcp cipdss01.ep.petrobras.com.br:/ep01/bd/ep_dba_oracle_bkp /oracle_bkp3/cipd

-- servidor PWSATI
npaa4287

-- NAS Windows 
\\s6006vfs0601\prd_bcomp_003$

-- Servidor de Restore
npaa2392

-- Connect Through do SQL SERVER
EXECUTE AS LOGIN = 'usuário'

-- Contato para pedir Criptografia
Jose Antonio Vianna da Rocha - HRD6 

-- Queries para verificação de JOB
SELECT * from dba_jobs;

SELECT job_name, job_action, enabled
FROM dba_scheduler_jobs;

SELECT job_name, job_action, enabled
FROM dba_scheduler_jobs
WHERE job_name = 'BINDIPRD0310.bat';

select log_date, status from dba_scheduler_job_run_details where job_name like '%BINDIPRD0310.bat%';

select owner, mview_name, last_refresh_type, last_refresh_date from dba_mviews/user_mviews;

Origem: https://dba.stackexchange.com/questions/172115/oracle-materialized-view-error-log-table

-- Relatório mensal Clarity
TYNL
Relatório Mensal GDPT.
Relatório Mensal Z5MG.

Relatório gerado e enviado.

-- Aumentar o tamanho do output do SQLPLUS
SET LIN 2000

-- Parar o Banco de Dados
srvctl stop database -d gdptt

-- Subir o Banco de Dados com Mount
srvctl start database -d gdptt -o mount
ou

srvctl start database -d abastp -n sanddb04

srvctl start database -d pepes1 -n monsaras1
srvctl start database -d pepes2 -n monsaras2

srvctl start instance -d pepes -i pepes1
srvctl start instance -d pepes -i pepes2

srvctl start database -d heprsvti -i heprsvti2

ou
srvctl stopinstance -d heprsvti -n onyxdb08 -o immediate

srvctl stopinstance -d pepes1 -n monsaras1 -o immediate 
srvctl stopinstance -d pepes2 -n monsaras2 -o immediate

ou 
srvctl stopinstance -d heprsvti -n onyxdb08 -o immediate -force
ou
srvctl stopinstance -d heprsvti -n onyxdb08 -o abort
e
srvctl start instance -d heprsvti -n onyxdb08

-- Alterar local de armazenamento do ARCHIVE
ALTER system SET log_archive_dest_1='LOCATION=/u01/app/oracle/diag/arch MANDATORY';
alter system switch logfile

-- Parar e subir o CRS
crsctl shutdown crs (logado na pasta bin do Oracle)

--Lista
crontab -l

-- Edita
crontab -e

-- Colocar na crontab
-- MIN HORA,HORACAMINHO
50 02,22 * * */u01/app/oracle/admin/tepqa/scripts/adm/resize_tablespaces.sh
00 21 * * */u01/app/oracle/admin/tepqa/scripts/backup/scrRmanTapeArchive.sh


-- Colocar BKP na Crontab
00 06,12,18 * * */u01/app/oracle/admin/tepqa/scripts/backup/scrRmanDDBoostArchive.sh
00 20 * * */u01/app/oracle/admin/tepqa/scripts/backup/scrRmanDDBoostFullOnline.sh

-- Problema com o DUMP que ficou com 8888 
Aplicar o CHMOD da máquina que originou os arquivos de DUMP, para que as alterações sejam permitidas

-- Erro Backup ambiente oclo
Enviar para a equipe de Storage verificar

-- Conferir Desenvolvedores da GDGAS-US
net group gg_infra_dba_dsv /domain

-- Caminho do Spool do PL/SQL-
Stopped spooling to C:\Program Files (x86)\PLSQL Developer\OBJBDI_EP.LOG

-- Sobre Jobs e Scheduler Jobs
https://www.mandsconsulting.com/oracle-dbms_scheduler-vs-dbms_job-create-run-monitor-remove/

-- Para realizar manutenção de Jobs
DBMS_IJOB.

-- DB SAPE produção
S6004DB41\I6004SQL04

--s6006db273 - S6006DB273\MSSQLSERVER Job [kill_zombie_procedures] - Last run fail 
Executar novamente o JOB

-- Limpar o FRA quando não puder rodar o ARCHIVE
Logar como GRID
Logar no asmcmd
cd DG_FRA01
ls (para ver os Bancos/Pastas que estão lá)
cd PASTA
ls
cd ARCHIVELOG
rm -rf 2019_05_28
vai executando o lsdg para verificar o espaço
du . (verifica qual ocupa mais espaço, executado dentro da pasta onde deseja verificar o tamanho)

-- Renomear uma pasta dentro do ASMCMD do DG_FRA
ALTER DISKGROUP DG_FRA01 RENAME DIRECTORY '+DG_FRA01/peprnce' to '+DG_FRA01/recrnce';
ALTER DISKGROUP DG_DAT01 RENAME DIRECTORY '+DG_DAT01/peprnce' to '+DG_DAT01/recrnce';

-- Caminhos ClearCase
\\s6005as273\Sistemas2\TI_DS
\\s6005as273\Sistemas4\TI_ADS
\\s6005as277\Sistemas\TRANSPETRO
\\s6005as277\Sistemas\TI_ENG
\\s6006as749\Sistemas2\TI_DS

--Tablespace XPTO com mais de 90 por cento de ocupacao
Inserir um Datafile

-- Para acessar como ORACLE nos servidores S3150DB05 e 06
sudosu oracle

-- Mudar versão do oracle no Servidor
. /u01/app/oracle/scripts/oraenv_18_oracle_db_1.sh

-- refresh de uma MView
DBMS_REFRESH.REFRESH (name);

-- Alarme Falhas em Jobs e com status Failed
select b.* from dba_scheduler_job_log b 
where b.job_name in ( select c.job_name from dba_scheduler_jobs c where c.failure_count <>0 )
and b.status <> 'SUCCEEDED' ORDER BY LOG_DATE DESC;

Pega o nome do executao mais recentemente e coloca na query:

select * from dba_scheduler_job_run_details where job_name in ('SU_CONTROL_MDU_DIV') ORDER BY LOG_DATE DESC;

A coluna "Additional Info" geralmente coleta o motivo do erro ter ocorrido.

-- Init do banco
cd $ORACLE_HOME/dbs

-- BACKUP are overdue
-----------------------------------------
-- Ir para o Service dar um stop e start
-----------------------------------------
 -- stop nos serviços
- NetBackup Client Service
- NetBackup Legacy Client Service
- NetBackup Legacy Network Service
 -- Start nos serviços
- NetBackup Legacy Network Service
- NetBackup Legacy Client Service
- NetBackup Client Service

*obs solicitar a equipe de Backup para executar o backup (N3-BACKUP)

 Avamar
stop no serviço Backup Agent
Start no serviço Backup Agent

-- Em bases que der problema de Access Denied ao entrar com a senha
Logar no NPAA1243
ssh asj7m1@servidor

-- Procurar dentro de execução de JOBS
SELECT * FROM DBA_JOBS WHERE WHAT LIKE '%VM_SIP_POCO_ATIVO%';

-- Verificar quais JOBs estão rodando
SELECT * FROM DBA_JOBS_RUNNING;

-- Executar um JOB que não é SCHEDULER
EXEC dbms_job.run(job_number);

-- DDL do job:

set pagesize 299
set long 999
select dbms_metadata.get_ddl('PROCOBJ','MV_RF$J_0_S_114206','SZ73Y') from dual;

-- Parar um JOB que não é Scheduler
Eliminar a sessão ativa com o SID que retorne pela pesquisa de JOBS

-- ORA-23421: o número de job 61 não é uma tarefa da fila de jobs
Logar como o Owner do JOB e executá-lo

-- Erro de Falha no Backup servidor TAL
Política(s): FS

Quer dizer File System, equipe de SO que atende, mesmo em servidores de Banco de Dados

-- Parar um Scheduler JOB
exec sys.dbms_scheduler.STOP_JOB(job_name=>'SYS.JOB_ADM_ANALYZE_FULL', force=>true);

-- Executar Scheduler Job
exec DBMS_SCHEDULER.RUN_JOB('OWNER.JOB',false);

-- Parar um Job que não é Scheduler
Colocar como Broken
Matar a sessão que está executando o JOB
https://dbsystems.wordpress.com/2008/04/10/killing-the-oracle-dbms_job/

-- Scheduler JOBS sendo executados
SELECT * FROM dba_scheduler_running_jobs;

-- Erro de DG_DAT01 não existe/montado
select * fromdba_data_files
Pegar o caminho utilizado e substituir

-- Alarme de DML e DRL com privilégios indevidos
SELECT * FROM DBA_TAB_PRIVS WHERE GRANTEE LIKE '%DRL%' AND PRIVILEGE <> 'SELECT';
SELECT 'REVOKE '|| PRIVILEGE || ' ON ' || OWNER || '.' || TABLE_NAME || ' FROM ' || GRANTEE || ';' FROM DBA_TAB_PRIVS WHERE GRANTEE LIKE '%DRL%' AND PRIVILEGE <> 'SELECT';

SELECT * FROM DBA_TAB_PRIVS WHERE GRANTEE LIKE '%DML%' AND PRIVILEGE NOT IN ('UPDATE','INSERT','DELETE');
SELECT 'REVOKE '|| PRIVILEGE || ' ON ' || OWNER || '.' || TABLE_NAME || ' FROM ' || GRANTEE || ';' FROM DBA_TAB_PRIVS WHERE GRANTEE LIKE '%DML%' AND PRIVILEGE NOT IN ('UPDATE','INSERT','DELETE');

SELECT * FROM DBA_ROLE_PRIVS WHERE GRANTED_ROLE LIKE '%DML%';

-- Migrar DATABASE Links sem saber a senha (expdp com arquivo de parâmetro parFile)
Criar o arquivo para.par com o conteúdo:
full=y
include=DB_LINK:"IN ('ASALF','BRANET','SIRR_BR','UNBA','UNBC','UNBS','UNES','UNRIO','UNSEAL','UNSUL')"

Executar o Export
expdp directory=EXP_DIR dumpfile=asj7m1_expdp_dblinks_%U.dmp logfile=asj7m1_expdp_dblinks_20191106.log cluster=n flashback_time=systimestamp parallel=8 parFile=para.par

Copiar o DUMP
scp -p asj7m1@sbcldb15.petrobras.biz://oracle/export/epprd02/asj7m1_expdp_dblinks_01.dmp asj7m1@npaa5976:/tmp

Conceder o acesso para criar Database Link par ao Owner que receberá os DBLinks:
GRANT CREATE DATABASE LINK TO YDBB;

Realizar o Import
impdp directory=DATA_PUMP_DIR dumpfile=asj7m1_expdp_dblinks_%U.dmp logfile=asj7m1_impdp_dblinks_20191106.log parallel=8 remap_schema=U5U5:YDBB

Remover o acesso para criar DATABASE LINK
REVOKE CREATE DATABASE LINK FROM YDBB;

Verificar as entradas TNS no servidor destino
Testar

-- BDEMQ SEDE
É a base SISTP

-- Verificar Máximo de MB em um datafile e tablespace
 SELECT file_name, autoextensible, round(bytes/1024/1024,2) as bytes_in_mb, round(maxbytes/1024/1024,2) as maxbytes_in_mb FROM dba_data_files WHERE tablespace_name LIKE 'SZ73Y_TR%';
 
 SELECT file_name, round(maxbytes/1024/1024/1024,2) as maxbytes_in_gb FROM dba_data_filesWHERE tablespace_name LIKE 'W68R%' and FILE_NAME LIKE '%exahml01_w68r_d_01%'; 
 
-- Quando for fazer um DUMP maior que a FRA
ALTER system SET log_archive_dest_1='LOCATION=/oracle_bkp3/cipd/npaa2648/aplabh08 MANDATORY'scope=memorysid='*';

-- Query que mostra sessões com Lock em Banco baseado em um usuário:
select * from
(
SELECT b.inst_id as intance_id,
 d.INSTANCE_NAME as INSTANCE_NAME,
 d.HOST_NAME as host_name,
 b.session_id AS session_id,
 NVL(b.oracle_username, '(oracle)') AS username,
 a.owner AS object_owner,
 a.object_name,
 Decode(b.locked_mode, 0, 'None',
 1, 'Null (NULL)',
 2, 'Row-S (SS)',
 3, 'Row-X (SX)',
 4, 'Share (S)',
 5, 'S/Row-X (SSX)',
 6, 'Exclusive (X)',
 b.locked_mode) locked_mode,
 b.os_user_name,
 c.LOGON_TIME
FROM dba_objects a,
 gv$locked_object b,
 gv$session c,
 gv$instance d
WHEREa.object_id = b.object_id
andb.INST_ID= c.INST_ID
andb.session_id = c.sid
andc.INST_ID = d.INST_ID
)
where username = 'TX'
ORDER BY session_id;

-- Rodar na CRONTAB manualmente:
sudo su - oracle
sh -x $HOME/transf/spme_envia_sau.start

-- Incluir ou Excluir Tabelas do DUMP expdp
include=TABLE:\"IN \(\'EMP\', \'DEPT\'\)\"
"

-- Pra matar um EXPORT rolando
ps -ef | grep exp

-- Mais informações durante a execução dos scripts
WHENEVER SQLERROR EXIT SQL.SQLCODE;
SET TIME ON;
SET TIMI ON;
SET FEED ON;

-- Criar service no servidor de Banco
srvctl add service -d gdptt -s dw_service.petrobras.com.br
srvctl start service -d gdptt -s dw_service.petrobras.com.br
crsctl stat res -t
srvctl add service -d exadsv01 -s ntssd.petrobras.com.br -r rcexadsv01a,rcexadsv01b

srvctl add service -d sicarhmg -s sicarhmg.petrobras.com.br
srvctl start service -d sicarhmg -s sicarhmg.petrobras.com.br

-- Verificar quanto de Memória RAM o Banco está utilizando:
-- Para verificar problemas de SWAP
SGA:
SELECT sum(value)/1024/1024/1024 "TOTAL SGA (GB)" FROM v$sga;

PGA:
select sum(pga_max_mem)/1024/1024/1024 "TOTAL MAX PGA (GB)" from v$process;

Máximo de Conexão:
select (((select value from v$parameter where name = 'processes') -
(select count(1) from v$session where username is not null)) * (
select max(p.pga_max_mem)/1024/1024/1024
from v$process p, v$session s
where P.ADDR = S.paddr and s.username is not null))
from dual;

Link de onde retirei as explicações: https://chadstechnoworks.com/wptech/db/how_to_check_oracle_database_memory_and_storage_size.html

show parameter sga;
​show parameter pga;
​show parameter memory;
TEM QUE TER 75% para o Banco de Dados e o resto pra SO.

-- Verificar utilização da FRA:
Verificando se a flash recovery area se encontra configurada:
show parameters recovery_file
 
-- Verificar utilização do DG_DAT
select name,total_mb,free_mb, (free_mb*100/total_mb) porcent_disp from v$asm_diskgroup where name='RECOC1';

-- memória SWAP (a tarefa é de SO)
​swapoff -a
​swapon -a
​sysctl -w vm.drop_caches=3
​isso resolve 95% dos alarmes de swap

-- Alarmes Agent Unreachable
[11:09] Renata da Silva Pfaltzgraff - PrestServ
como sudo su - orarom
​[11:14] Renata da Silva Pfaltzgraff - PrestServ
[oracle@onyxdb01:~] $ sudo su - orarom
[orarom@onyxdb01 ~]$ /opt/OracleHomes/agent_home/core/12.1.0.5.0/bin/emctl status agent
Oracle Enterprise Manager Cloud Control 12c Release 5
Copyright (c) 1996, 2015 Oracle Corporation.All rights reserved.
---------------------------------------------------------------
Agent is Not Running

​[11:14] Renata da Silva Pfaltzgraff - PrestServ
ai falei com Vilnei e ele retirou, pois estava indevido

-- Alarmes de JOB executando mais de 24
Se não estiver nas tabelas RUNNING, verificar a coluna LAST_DATE nas tabelas comuns de listagem dos JOBS
 SELECT * FROM DBA_JOBS WHERE THIS_DATE IS NOT NULL;
Para resolver, conforme orientação da RENATA (Isso é UMA situação de um JOB):
[08:51] Renata da Silva Pfaltzgraff - PrestServ
com o schema
​[08:51] Renata da Silva Pfaltzgraff - PrestServ
coloca como broken
​[08:51] Renata da Silva Pfaltzgraff - PrestServ
EXEC dbms_job.broken('2306',TRUE);
​[08:52] Adrian Lumbreras Dellatorre - PrestServ
hmmm
​[08:52] Renata da Silva Pfaltzgraff - PrestServ
executa o Job e/ou mview
​[08:52] Renata da Silva Pfaltzgraff - PrestServ
select owner, mview_name, last_refresh_date from all_mviews where owner = 'TCRP';
exec dbms_mview.refresh('"TCRP"."MV_BIREF_PAIS"');
PL/SQL procedure SUCCESSFUL;;;ly completed
​[08:52] Renata da Silva Pfaltzgraff - PrestServ
SQL> exec dbms_job.run(2306)
PL/SQL procedure SUCCESSFUL;;;ly completed

--banco do PJUR 
- npaa2648 - aplabh

-- Para descobrir se o servidor é RIC ou DMZ
 - SIGMON
 - Hosts
 - Consulta detalhada
 - DMZ?
 
 -- Alarme 
- Executar um refresh completo na MView do Job
exec dbms_mview.refresh('"AQG"."PONTO_TRECHO_CURVA"', method => 'C', atomic_refresh => FALSE, out_of_place => FALSE);
- Executar o JOB para verificar se o problema foi corrigido

-- Query para ver facilmente o quanto uma tablespace está consumindo
SELECT m.tablespace_name, ROUND(m.used_percent, 2), ROUND((m.tablespace_size - m.used_space)*t.block_size/1024/1024, 3) mb_free
FROM dba_tablespace_usage_metrics m,
dba_tablespaces t,
v$parameter p
WHERE p.name='statistics_level' and p.value!='BASIC'
AND t.contents NOT IN ('TEMPORARY', 'UNDO') AND t.tablespace_name = m.tablespace_name
and t.TABLESPACE_NAME = 'SYSAUX';

-- Aplicação ASAP
Banco aplab p08/h08/d08

-- Alarme com JOBs executando por mais de 24h, após todas as verificações, não tem sessão, NADA NESSA BOSTA
- Renata resolveu vários com:
- Limpeza dos volumes de Disco do servidor
	- Dando um clearstate e upload no agent do Grid
	
-- Query para alarmes com PFL_USER e acesso diferente de SELECT
SELECT
distinct grantee as resultado
FROM DBA_TAB_PRIVS
WHERE PRIVILEGE <> 'SELECT'
 AND GRANTEE IN (SELECT GRANTED_ROLE
 FROM (SELECT NULL GRANTEE, USERNAME GRANTED_ROLE
 FROM DBA_USERS
WHERE PROFILE LIKE 'PFL_USER%'
AND PROFILE <> 'PFL_USER_EMERGENCY'
 UNION
 SELECT GRANTEE, GRANTED_ROLE
 FROM DBA_ROLE_PRIVS)
START WITH GRANTEE IS NULL
 CONNECT BY GRANTEE = PRIOR GRANTED_ROLE);
											 
--											 
SELECT COUNT(distinct grantee) as resultado
FROM DBA_TAB_PRIVS
WHERE PRIVILEGE <> 'SELECT'
AND (SELECT INSTANCE_NUMBER
 FROM V$INSTANCE) = (SELECT MIN(INSTANCE_NUMBER)
 FROM GV$INSTANCE
 WHERE DATABASE_STATUS = 'ACTIVE')
 AND GRANTEE IN (SELECT GRANTED_ROLE
 FROM (SELECT NULL GRANTEE, USERNAME GRANTED_ROLE
 FROM DBA_USERS
WHERE PROFILE LIKE 'PFL_USER%'
AND PROFILE <> 'PFL_USER_EMERGENCY'
 UNION
 SELECT GRANTEE, GRANTED_ROLE
 FROM DBA_ROLE_PRIVS)
START WITH GRANTEE IS NULL
 CONNECT BY GRANTEE = PRIOR GRANTED_ROLE);
 
SELECT *
FROM DBA_TAB_PRIVS
WHERE GRANTEE IN (SELECT USERNAME
                  FROM DBA_USERS
                  WHERE PROFILE LIKE 'PFL_USER%'
                  AND PROFILE <> 'PFL_USER_EMERGENCY')
AND PRIVILEGE <> 'SELECT';
 

SELECT distinct GRANTEE 
FROM dba_tab_privs
WHERE grantee LIKE '%DRL'
AND privilege <> 'SELECT'

SELECT distinct GRANTEE 
FROM dba_tab_privs 
WHERE grantee LIKE '%DML' 
AND privilege NOT IN ('INSERT', 'UPDATE', 'DELETE')

SELECT distinct GRANTEE 
FROM dba_tab_privs 
WHERE grantee like '%EXEC' 
AND privilege <> 'EXECUTE' 
				 
-- SCRIPT para tirar privilegios diferente de select 
select 'revoke '||privilege||' on '||owner||'.'||table_name||' from '||grantee||';'
 from dba_tab_privs where grantee in ('RCUBO_DRL')
and privilege <> 'SELECT';

select 'revoke '||privilege||' on '||owner||'.'||table_name||' from '||grantee||';'
 from dba_tab_privs where grantee in ('RBDEMQ_EXEC')
and privilege <> 'EXECUTE';

select 'revoke '||privilege||' on '||owner||'.'||table_name||' from '||grantee||';'
 from dba_tab_privs where grantee in ('RW68R_DML')
and privilege not in ('INSERT', 'UPDATE', 'DELETE');

RAPR_DRL => Select
RAPR_DML=> INSERT, UPDATE, DELETE
RAPR_EXEC => execute

-- Verificar Roles/Privilégios de um usuário
SELECT * FROM DBA_ROLE_PRIVS WHERE GRANTEE = 'USER';
				 
-- undo retetion:

SELECT d.undo_size/(1024*1024) "ACTUAL UNDO SIZE [MByte]",
SUBSTR(e.value,1,25) "UNDO RETENTION [Sec]",
(TO_NUMBER(e.value) * TO_NUMBER(f.value) *
 g.undo_block_per_sec) / (1024*1024)
 "NEEDED UNDO SIZE [MByte]"
FROM(SELECT SUM(a.bytes) undo_size
 FROMv$datafile a
 inner joinv$tablespace b
ona.ts# = b.ts#
inner joindba_tablespaces c
onb.name = c.tablespace_name
 WHERE c.contents = 'UNDO'
AND c.status = 'ONLINE') d,
v$parameter e,
v$parameter f,
 ( SELECT MAX(undoblks/((end_time-begin_time)*3600*24)) undo_block_per_sec
 FROMv$undostat) g
WHERE e.name = 'undo_retention'
AND f.name = 'db_block_size';


show parameter undo

alter system set undo_retention=72000 scope=both sid='*';

-- Erro em SCHEDULER JOB do TCRP:
Enviar para TIC/TIC-CORP/GDGAS-CORP=== N4-CCI

-- Erro em TCRP:
Enviar e-mail conforme o padrão abaixo:

Destinatários: estevesjoao.TO_BRASIL@petrobras.com.br; joao.filho@petrobras.com.br
Assunto: Erros em Mviews do TCRP (Scheduler jobs) 
Em anexo, estão os arquivos separados por base, que alarmam erros nas Mviews do owner do TCRP.
Favor verificar os erros para juntos podermos resolver os problemas dos scheduler_jobs das bases (XPTO).


-- Exemplo de Plano de Consulta no PLSQL
-- Outra forma é executar o comando com F5 no PLSQL

EXPLAIN PLAN FOR
SELECT
t.dataamostragem as Timestamp,
t.resultado as Value
from
u5u5.vw_togy_resultado_amostra t
where
upper(t.instalacao) = 'P-31'
and substr(upper(t.pontoamostragem),10,8) = 'DEGASSER'
and substr(upper(t.ensaio),1,5) = 'TOG01'
and TO_DATE(t.dataamostragem, 'DD-MM-YYYY HH24:MI:SS') >= TO_DATE('27/05/2020 22:11:02', 'DD-MM-YYYY HH24:MI:SS')
and TO_DATE(t.dataamostragem, 'DD-MM-YYYY HH24:MI:SS') <= TO_DATE('29/05/2020 22:11:02', 'DD-MM-YYYY HH24:MI:SS')
order
by TO_DATE(t.dataamostragem, 'DD-MM-YYYY HH24:MI:SS');

SELECT PLAN_TABLE_OUTPUT
FROM TABLE(DBMS_XPLAN.DISPLAY(null, NULL,'TYPICAL'));

-- Parar banco de dados sem entrar na base
srvctl stop instance -d depwbr -n onyxdb05 -o immediate --(se não for, ficar travado, trocar immediate por abort)
srvctl start instance -d depwbr -n onyxdb05

-- Criar usuário de Banco usando senha de rede
CREATE USER <CHAVE>
IDENTIFIED GLOBALLY AS 'cn=<chave>,cn=Users,o=petrobras,dc=petrobras,dc=com,dc=br';

-- Verificar se um Schema está encriptado
Select <Nome da table_space>, encrypted from dba_tablespaces;

-- Comando para coletar evidências em Servidor SQL
SELECT *FROM fn_listextendedproperty(default, default, default, default, default, default, default);

-- Comando para coletar evidências em Servidor Oracle
select host_name,instance_name from gv$instance;
select id_grupo,profile from orastatus.tbl_grupo_adm where id_grupo='GG_INFRA_SUPORTE_AB_DBA';
 
 -- Adicionar o parâmetro no EXP e IMP
JOB_NAME=exp_S547448
JOB_NAME=imp_S547448

-- Comando para acompannhar o DUMP sendo realizado
select OWNER_NAME, JOB_NAME, STATE from DBA_DATAPUMP_JOBS;


-- Problema de usuários sendo bloqueados nas bases BDIEP
Todos usuários desta equipe estão bloqueados porque o grupo cadunix não foi incluído na tabela orastatus.tbl_grupo_adm. 
 
Em todos os bancos, a gestão de concessão/revogação de acesso é feita de forma automática pelo job JOB_AUDITA_GRUPOS_AD. 
O job consulta a tabela acima e verifica os usuários destes grupos. Os usuários que não estão nos grupos são bloqueados por 15 dias, 
após os quais são removidos. (No hepbsol, os usuários ainda estão bloqueados. Suponho que o módulo SOX do ORASTATUS tenha sido criado a menos de 15 
dias neste banco.) Usuários não existentes no banco, mas presentes no grupo são criados. Por este motivo, não podemos mexer nesta tabela sem as 
autorizações necessárias para não haver inconformidade SOX. Neste caso, o banco é de HML e não temos controle SOX em HML. Só por este motivo, 
eu incluí o grupo na tabela. A partir de hoje o usuário não será bloqueado de novo.
 
Aproveitei para corrigir o nome do grupo cadunix da equipe BD-ORACLE:

SELECT * FROM ORASTATUS.TBL_GRUPO_ADM;

INSERT INTO ORASTATUS.TBL_GRUPO_ADM VALUES ('GG_INFRA_DBA_DSV','RADM_DBA_DSV','PFL_DBA_DSV');
UPDATE ORASTATUS.TBL_GRUPO_ADM SET ID_GRUPO = 'GG_INFRA_BD_ORACLE' WHERE ID_GRUPO = 'GG_INFRA_BANCO_DE_DADOS';

-- Caso não saiba o caminho, cd $AGENT_HOME/bin
-- Ou ps -ef | grep agent
-- Tratativas no Agent is Running and Ready
[oracle@npaa2648:/u01/app/oracle/product/12.1.0/agent_inst/bin] $ ./emctl clearstate agent
Oracle Enterprise Manager Cloud Control 12c Release 5
Copyright (c) 1996, 2015 Oracle Corporation.All rights reserved.
EMD clearstate completed SUCCESSFUL;;;ly
[oracle@npaa2648:/u01/app/oracle/product/12.1.0/agent_inst/bin] $ ./emctl stopagent
Oracle Enterprise Manager Cloud Control 12c Release 5
Copyright (c) 1996, 2015 Oracle Corporation.All rights reserved.
Stopping agent ..... stopped.
[oracle@npaa2648:/u01/app/oracle/product/12.1.0/agent_inst/bin] $ ./emctl startagent
Oracle Enterprise Manager Cloud Control 12c Release 5
Copyright (c) 1996, 2015 Oracle Corporation.All rights reserved.
Starting agent ................................................... started.
[oracle@npaa2648:/u01/app/oracle/product/12.1.0/agent_inst/bin] $ ./emctl upload agent
Oracle Enterprise Manager Cloud Control 12c Release 5
Copyright (c) 1996, 2015 Oracle Corporation.All rights reserved.
---------------------------------------------------------------
EMD upload completed SUCCESSFUL;;;ly
[oracle@npaa2648:/u01/app/oracle/product/12.1.0/agent_inst/bin] $

./emctl status agent -- verificar status do agent

-- Copiar um diretório / pasta no Linux
cp -avr origem destino
-a : Preserve the specified attributes such as directory an file mode, ownership, timestamps, if possible additional attributes: context, links, xattr, all.
-v : Verbose output.
-r : Copy directories recursively.

-- Como descobrir a versão do Oracle de cada base:
ps -ef | grep pmo
pwdx <pid_do_banco>

ou 

ls -lh /proc/<pid>/cwd

			
-- limpar memoria	(limpar) root
sync; echo 1 > /proc/sys/vm/drop_caches; echo 2 > /proc/sys/vm/drop_caches; echo 3 > /proc/sys/vm/drop_caches


-- BIRNCE2 E BIRNCE2
birnce2.ep-rnce.petrobras.com.br

-- Problema de JOB com NEXT_DATE no passado:
begin
dbms_scheduler.disable(NAME =>'ODS.JOB_MV_ARQV_SSMICA_ATRI',FORCE => TRUE);
dbms_scheduler.enable('ODS.JOB_MV_ARQV_SSMICA_ATRI');
end;

[08:37] William Robatino - PrestServ
se nao der certo vc pode usar esse parametro na base que resolve
​[08:37] William Robatino - PrestServ
alter session set nls_date_format = 'dd/mm/rrrr hh24:mi:ss';
alter session set nls_timestamp_format= 'dd/mm/rrrr hh24:mi:ssxff';
alter session set nls_timestamp_tz_format = 'dd/mm/rrrr hh24:mi:ssxff tzr';
​[08:38] William Robatino - PrestServ
tem q ser no user que vc criou a job
​[08:38] William Robatino - PrestServ
ou sys

-- Restore em servidor SQL Server no Windows cujo Banco está sendo utilizado
1) vc vai na parte de processos e verifica quem acessa o banco.
2) depois vc vai na parte de login e bloqueia os usuários q acessam o banco
3) e por último volta na parte de processos e mata as sessões q estam acessando.

-- Quando não conseguir logar com sysdba, utilizar o prelim. 
sqlplus -prelim / as sysdba

-- Problema de base SQL SERVER WINDOWS em modo RESTORING depois de aplicar um dump
RESTORE DATABASE DBSPGT_1 WITH RECOVERY

USE master;
GO

ALTER DATABASE DBSPGT_1
SET SINGLE_USER
WITH ROLLBACK IMMEDIATE;

USE master;
GO

RESTORE DATABASE DBSPGT_1 WITH RECOVERY

USE master;
GO

alter database DBSPGT_1 set offline with rollback immediate

alter database DBSPGT_1 set online

ALTER DATABASE DBSPGT_1
SET MULTI_USER;
GO

SBT_LIBRARY -> tem que ter o caminho do ORACLE_HOME
Dá pra ver as informações no parRman.sh (ou parDBBoost.sh, nesse caso)

 Quando esse problema deu no PJURP, Argona me orientou a entrar nos scripts .rcv e comentar as linhas delete obsolete.

-- Usuários sem auditoria habilitada

select u.username, u.profile from dba_users u where u.profile like '%SOX%';

select sjd.STATUS, to_char(max(log_date), 'dd/mm/yyyy hh24:mi') max_log_date 
from dba_scheduler_job_run_details sjd
where sjd.OWNER='ORASTATUS' and sjd.job_name='JOB_AUDITA_GRUPOS_AD'
group by sjd.STATUS;

select j.owner job_owner, j.job_name, j.program_owner pg_owner, j.program_name pg_name,
 j.schedule_owner sc_owner, j.schedule_name sc_name, j.enabled job_enabled, s.repeat_interval, j.state,
 to_char(j.last_start_date, 'dd/mm/yyyy hh24:mi') job_last_start,
 to_char(j.next_run_date, 'dd/mm/yyyy hh24:mi') job_next_start, p.program_action pg_action
from dba_scheduler_programs p
inner join dba_scheduler_jobs j on p.owner=j.program_owner and p.program_name=j.program_name
inner join dba_scheduler_schedules s on j.schedule_owner=s.owner and j.schedule_name=s.schedule_name
where j.owner='ORASTATUS' and j.job_name='JOB_AUDITA_GRUPOS_AD';
	
SE DER BOSTA, EXECUTAR PARA CORRIGIR O NEXT_DATE:

BEGIN
DBMS_SCHEDULER.SET_ATTRIBUTE (
 name => 'ORASTATUS.JOB_AUDITA_GRUPOS_AD',
 attribute=> 'schedule_name',
 value=> 'SCH_ADM_DAILY_11H_AND_23H');
END;
/

 
-- Agente com problema de TIMEZONE TZ

então pode ser o TZ
​./emctl config agent getTZ
./emctl config agent listtargets
./emctl getmetric agent DEPES,oracle_database,Response
./emctl status agent scheduler | grep Response
cd ~
curl http://npaa4263/java/tzupdater.jar --output tzupdater.jar
​ps -fu oracle | grep java
​<java> -jar tzupdater.jar -l http://npaa4263/java/tzdata2019b.tar.gz -v
depois reinicia o agente
Aguardar por volta de 1h e 30min


-- Para ver alerts antigos
adrci
show homes
set home <home_que_tem_rdbms>
show alert

se quiser pesquisar lá dentro:
[shift + G]
(?<texto_a_ser_pesquisado)

-- Backup de Banco 18 não limpa o FRA até finalizar. Para limpar, rodar o comando:
rman target /
DELETE NOPROMPT ARCHIVELOG ALL BACKED UP 1 TIMES TO DEVICE TYPE SBT_TAPE;

-- Criar meu usuário DBA nas Bases
create user ASJ7M1
identified by 
default tablespace USERS
temporary tablespace TEMP
profile PFL_ADM_USER;
-- Grant/Revoke role privileges 
grant radm_dba to ASJ7M1 with admin option;
grant radm_user to ASJ7M1;


-- Out of Memory
Resolvi verificando no init o memory_max_target, comparando a soma de todas as bases e as memórias que estão utilizando.
Como não teve jeito, tivemos que rebootar o servidor para que os Bancos fossem iniciados com a quantidade de memória correta.

-- Solicitação para cadastramento de DNS Reverso no host s6006db330
[10:28] Patrick da Conceição da Silva - PrestServ
Eu sigo esse fluxo quando vou abrir um chamado para eles
Serviços 
 > 
Tecnologia da Informação e Comunicação 
 > 
Serviços Internos 
 > 
Suporte Técnico de Serviços 
 > 
Rede de Dados 
N3-OPER-DHCP-DNS
 
Cadastrar DNS reverso para:
Name: s6006db330.petrobras.biz
Address: 10.30.139.81
Name: s6006db330-bkp.petrobras.biz
Address: 10.30.87.61

-- Verificar log de backup
select
j.session_recid, j.session_stamp,
to_char(j.start_time, 'yyyy-mm-dd hh24:mi:ss') start_time,
to_char(j.end_time, 'yyyy-mm-dd hh24:mi:ss') end_time,
(j.output_bytes/1024/1024) output_mbytes, j.status, j.input_type,
decode(to_char(j.start_time, 'd'), 1, 'Sunday', 2, 'Monday',
 3, 'Tuesday', 4, 'Wednesday',
 5, 'Thursday', 6, 'Friday',
 7, 'Saturday') dow,
j.elapsed_seconds, j.time_taken_display,
x.cf, x.df, x.i0, x.i1, x.l,
ro.inst_id output_instance
from V$RMAN_BACKUP_JOB_DETAILS j
left outer join (select
 d.session_recid, d.session_stamp,
 sum(case when d.controlfile_included = 'YES' then d.pieces else 0 end) CF,
 sum(case when d.controlfile_included = 'NO'
 and d.backup_type||d.incremental_level = 'D' then d.pieces else 0 end) DF,
 sum(case when d.backup_type||d.incremental_level = 'D0' then d.pieces else 0 end) I0,
 sum(case when d.backup_type||d.incremental_level = 'I1' then d.pieces else 0 end) I1,
 sum(case when d.backup_type = 'L' then d.pieces else 0 end) L
 from
 V$BACKUP_SET_DETAILS d
 join V$BACKUP_SET s on s.set_stamp = d.set_stamp and s.set_count = d.set_count
 where s.input_file_scan_only = 'NO'
 group by d.session_recid, d.session_stamp) x
on x.session_recid = j.session_recid and x.session_stamp = j.session_stamp
left outer join (select o.session_recid, o.session_stamp, min(inst_id) inst_id
 from GV$RMAN_OUTPUT o
 group by o.session_recid, o.session_stamp)
ro on ro.session_recid = j.session_recid and ro.session_stamp = j.session_stamp
where j.start_time > trunc(sysdate)-10
order by j.start_time DESC;

-- Com o Sessio_Stamp, dá pra ver o log todo direto no PL/SQL:
	select output from v$rman_output where session_stamp=1151021623;
	select output from v$rman_output where session_stamp=1148162415 AND OUTPUT LIKE '%warning%';
	

-- Clearstate manual de Agent
cd /u01/app/oracle/product/agent/agent_inst/bin
./emctl stop agent
cd ../sysman/emd/state
rm -vfr *
cd ../upload
rm -vfr *
cd /u01/app/oracle/product/agent/agent_inst/bin
./emctl start agent
./emctl upload agent
./emctl status agent
./emctl reload agent

-- Erro de aplicação de logs no standby - sev2 Erro DataGuard ao aplicar archives
SELECT COUNT(*)
FROM GV$INSTANCE A
 INNER JOIN GV$ARCHIVE_DEST_STATUS B ON A.INST_ID = B.INST_ID
 WHERE A.INSTANCE_ROLE = 'PRIMARY_INSTANCE'
 AND B.STATUS = 'VALID'
 AND B.TYPE = 'PHYSICAL'
 AND B.RECOVERY_MODE <> 'MANAGED REAL TIME APPLY'

-- Reestartar agent do ZABBIX
Dá um sudo su -
	
service zabbix-agent restart

-- Script de PurgeLogs
sudo su -
cp /oracle_bkp3/cipd/argona/scripts/purgeLogs /u01/app/oracle/scripts/
crontab -e
00 01 * * * /u01/app/oracle/scripts/purgeLogs -osw 7 -orcl 7 -tfa 7 -lsn > /tmp/cron_purgeLogs.log 2>&1

-- Espaço livre em Tablespace
select
 fs.tablespace_name"Tablespace",
 (df.totalspace - fs.freespace)/1024"Used GB",
 fs.freespace/1024"Free GB",
 df.totalspace/1024 "Total GB",
 round(100 * (fs.freespace / df.totalspace)) "Pct. Free"
from
 (select
tablespace_name,
round(sum(bytes) / 1048576) TotalSpace
 from
dba_data_files
 group by
tablespace_name
 ) df,
 (select
tablespace_name,
round(sum(bytes) / 1048576) FreeSpace
 from
dba_free_space
 group by
tablespace_name
 ) fs
where
 df.tablespace_name = fs.tablespace_name
and
fs.tablespace_name = 'CISTS_01';

-- Descobrir versão do Oracle
srvctl status database -d nome_da_base

-- Check the database in restricted mode
select logins from v$instance;

-- Rodar um backup em DISCO para testar as configurações do RMAN
Ao acessar a base, rodar um archive log list
Pegar a sequence
Logar no catálogo da RMAN
Rodar:
RUN
{
 ALLOCATE CHANNEL ch00 DEVICE TYPE disk format '/oracle_bkp3/cipd/adrian/archive_bkp.rman';
 backup archivelog logseq <numero_da_sequence>;
}

-- Deletar archives que já foram para a Fita
DELETE ARCHIVELOG LIKE 'all' BACKED UP 1 TIMES TO DEVICE TYPE SBT_TAPE;

-- Deletar archives 3 dias atras:
delete archivelog all completed before 'sysdate -3'; 

-- - FRA ou DAT
sudo su - grid

dg=RECOC1; for dir in $(asmcmd ls $dg); do echo $dg/$dir; asmcmd du $dg/$dir; done

dg=DG_FRA01; for dir in $(asmcmd ls $dg); do echo $dg/$dir; asmcmd du $dg/$dir; done

dg=DATAC3; for dir in $(asmcmd ls $dg); do echo $dg/$dir; asmcmd du $dg/$dir; done

-- verificar o status do BKP:
alter session set nls_date_format='dd/mm/yyyy hh24:mi:ss';
set lines 400
col opname format a40
set pages 120
SELECT sid, serial#, opname, sofar, totalwork, round((totalwork-sofar)*8192/1024/1024/1024) GB_rest,
round(sofar/totalwork*100,2) "% Complete", time_remaining, sysdate + TIME_REMAINING/3600/24 end_at
FROM v$session_longops
WHERE opname LIKE 'RMAN:%'
-- AND opname NOT LIKE 'RMAN: aggregate%'
AND sofar <> totalwork
AND totalwork != 0
order by 8;


-- Profiles petrobras

-- Usuários chave
Roles: RADM_USER + Demais Roles informadas (Validar acessos, pois não podem ter acesso de escrita)
Profile : PFL_USER


-- Usuário de Aplicação ou servico (USR_XXXX)
Roles: RADM_USER + Demais Roles informadas
Profile: PFL_ADM_APPLICATION


-- Schema
Roles: RADM_USER, RADM_SCHEMA + Demais Roles informadas
Profile: PFL_ADM_APPLICATION


-- Usuário AD
Roles: RADM_USER, RADM_AD
Profile: PFL_AD_DSV


-- Usuário DBA dsv COM AS
Roles: RADM_USER, RADM_DBA_DSV
Profile: PFL_DBA_DSV

AS DBA NOS

RADM_DBA

PFL_ADM_USER

-- verificar roles e profiles:

select * from dba_role_privs where granted_role in ('NOVOSIT_CONSULTA_RL');

select username, profile from dba_users
where username in (select distinct grantee from dba_role_privs
 where granted_role in ('HS_ADMIN_EXECUTE_ROLE','R_CPROD','SELECT_CATALOG_ROLE','R_UCPROD','R_UNCPROD','R_NCPROD'))
and profile like 'PFL_USER%';
 
revoke R_UNCPROD, R_CPROD, R_NCPROD, R_UCPROD from D8H5;

SELECT COUNT(*)
FROM DBA_USERS
WHERE PROFILE='DEFAULT' AND USERNAME <> 'XS$NULL'
AND (SELECT INSTANCE_NUMBER FROM V$INSTANCE) = (SELECT MIN(INSTANCE_NUMBER) FROM GV$INSTANCE WHERE DATABASE_STATUS = 'ACTIVE')

-- Alterar backup para utilizar rede de backup (tive que fazer isso pra um backup que estava muito lento)
#export RMAN_NB_ORA_CLIENT=s6006as2468.petrobras.biz
#export RMAN_NB_ORA_SERV=basileu.petrobras.com.br
export NBU_ORA_SERV=basileu-bkp.petrobras.com.br
export NBU_ORA_CLIENT=s6006as2468-bkp.petrobras.com.br


-- JOB com status Failed, tem essa consulta para pegar informações do erro
select * from dba_scheduler_job_run_details where job_name = 'JOB_ADM_UPDATE_OUTDATED_STATS' order by log_date desc;

select OWNER, JOB_NAME, SESSION_ID from dba_scheduler_running_jobs where JOB_NAME='JOB_MV_BIRH_PES_CART_TRAB';
select * from dba_scheduler_job_run_details where job_name in ('JOB_MV_BIRH_LOTACAO_FOTR_HIST') ORDER BY LOG_DATE DESC;

select b.* fromdba_scheduler_job_log b 
where b.job_name in ( select c.job_name from dba_scheduler_jobs c where c.failure_count <>0 )
and b.status <> 'SUCCEEDED' ORDER BY LOG_DATE DESC;

-- Job com status FAILED e o seguinte erro de execução
ORA-06598: insufficient INHERIT PRIVILEGES privilege
ORA-06512: at "ORASTATUS.SP_ADM_UPDATE_OUTDATED_STATS", line

Solução:
GRANT INHERIT PRIVILEGES ON USER "SYS" TO "ORASTATUS";

select b.* fromdba_scheduler_job_log b 
where b.job_name in ( select c.job_name from dba_scheduler_jobs c where c.failure_count <>0 )
and b.status <> 'SUCCEEDED' ORDER BY LOG_DATE DESC;

select OWNER, JOB_NAME from dba_scheduler_running_jobs where JOB_NAME like '%SU_CONTROL_MDU_DIV%';

select * from dba_scheduler_job_run_details where job_name in ('SU_CONTROL_MDU_DIV') ORDER BY LOG_DATE DESC;

select JOB_NAME, JOB_ACTION from dba_scheduler_jobs where job_name = 'SU_CONTROL_MDU_DIV';

select * from dba_scheduler_jobs where job_name in ('15601') ORDER BY LOG_DATE DESC;

select b.* fromdba_scheduler_job_log b 
where b.job_name in ( select c.job_name from dba_scheduler_jobs c where c.failure_count <>0 )
and b.status <> 'SUCCEEDED' ORDER BY LOG_DATE DESC;

desc dba_scheduler_jobs;

select ROLE, ROLE_ID, AUTHENTICATION_TYPE, EXTERNAL_NAME from DBA_ROLES where role= 'R_USR_UNC9_DRL';

-- Alocar canal:
ALLOCATE CHANNEL FOR MAINTENANCE DEVICE TYPE DISK;
ALLOCATE CHANNEL FOR MAINTENANCE DEVICE TYPE 'SBT_TAPE' 

ALLOCATE CHANNEL FOR MAINTENANCE DEVICE TYPE DISK;
ALLOCATE CHANNEL FOR MAINTENANCE DEVICE TYPE SBT_TAPE;

allocate channel FOR'SBT_TAPE' parms 'ENV=(NSR_SERVER=cipd_dd990_5.petrobras.com.br, NSR_CLIENT=npaa2428.petrobras.biz)';

--stop/start no banco:
 o - force do lado do imediate ()
srvctl stop instance -d aplabh -n npaa2648 -o immediate 
srvctl stop instance -d aplabh08 -n npaa2648 -o immediate 
srvctl stop instance -d aplabm08 -n npaa2648 -o immediate 

crsctl stop crs - com grid
./crsctl stop crs no caminho do bin com root

srvctl start instance -d aplabh -n npaa2648 
srvctl start instance -d aplabh08 -n npaa2648
srvctl start instance -d aplabm08 -n npaa2648 

crsctl start crs - com grid
./crsctl start crs no caminho do bin com root

srvctl stop instance -d aplattr -n npaa5038 -o immediate 
srvctl start instance -d aplabm08 -n npaa2648 -o immediate 

====================================================================================

srvctl stop instance -d rccaelpa -n haleiwa -o immediate 
srvctl start instance -d rccaelpa -n haleiwa -o immediate 

crsctl stop crs - com grid
./crsctl stop crs no caminho do bin com root

srvctl stop instance -d rccaelpb -n mavericks -o immediate 
srvctl start instance -d rccaelpb -n mavericks -o immediate 

crsctl stop crs - com grid
./crsctl stop crs no caminho do bin com root

crsctl start crs - com grid
./crsctl start crs no caminho do bin com root

-- Jobs com status failed:
select * from dba_scheduler_job_run_details where job_name in ('JOB_VERIFICA_USUARIO') ORDER BY LOG_DATE DESC;

-- Alertas com usuario com acesso diferente de select:
SELECT
distinct grantee as resultado
FROM DBA_TAB_PRIVS
WHERE PRIVILEGE <> 'SELECT'
 AND GRANTEE IN (SELECT GRANTED_ROLE
 FROM (SELECT NULL GRANTEE, USERNAME GRANTED_ROLE
 FROM DBA_USERS
WHERE PROFILE LIKE 'PFL_USER%'
AND PROFILE <> 'PFL_USER_EMERGENCY'
 UNION
 SELECT GRANTEE, GRANTED_ROLE
 FROM DBA_ROLE_PRIVS)
START WITH GRANTEE IS NULL

select username, profile from dba_users
where username in (select distinct grantee from dba_role_privs
where granted_role in (select grantee from dba_role_privs where granted_role in ('SODA_APP')))	

select username, profile from dba_users where username in (select distinct grantee from dba_role_privs
where granted_role in ('SODA_APP'));

select * from dba_role_privs where granted_role in ('HS_ADMIN_EXECUTE_ROLE','SELECT_CATALOG_ROLE');

-- para o erro: specification does not match any archived log in the repository - Doc ID 869671.1
select name, sequence#, completion_time, deleted from v$archived_log where status = 'A';	
	
archive log list;

alter system switch logfile;		 

-- Reprocessar job numero dbms_job
exec dbms_job.run();
BEGIN DBMS_JOB.run(); END;

-- verificar a ação dbms_job no banco:
select job_action from dba_scheduler_jobs where job_name='DBMS_JOB$_3281';

-- dropar dbms_job
exec dbms_job.remove(3281);

-- Reprocessar job scheduler
BEGIN DBMS_SCHEDULER.RUN_JOB(job_name => '"SCH_OFM"."JOB_MV_INTERV_PERMOPOROSO_OFM"', USE_CURRENT_SESSION => FALSE); END;

-- Verificar hora da atuação do job:
select j.owner job_owner, j.job_name, j.program_owner pg_owner, j.program_name pg_name,
 j.schedule_owner sc_owner, j.schedule_name sc_name, j.enabled job_enabled, s.repeat_interval, j.state,
 to_char(j.last_start_date, 'dd/mm/yyyy hh24:mi') job_last_start,
 to_char(j.next_run_date, 'dd/mm/yyyy hh24:mi') job_next_start, p.program_action pg_action
from dba_scheduler_programs p
inner join dba_scheduler_jobs j on p.owner=j.program_owner and p.program_name=j.program_name
inner join dba_scheduler_schedules s on j.schedule_owner=s.owner and j.schedule_name=s.schedule_name
where j.owner='SCH_OFM' and j.job_name='JOB_MV_INTERV_PERMOPOROSO_OFM';

-- - 24 horas - jobs running

--Parar jobs de Scheduler:
	
exec dbms_session.set_identifier('8189521');
	
select owner,job_name,session_id,elapsed_time,running_instance from dba_scheduler_running_jobs;

select OWNER, JOB_NAME from dba_scheduler_running_jobs where JOB_NAME like '%DBMS_JOB$_9857%';
 
exec sys.dbms_scheduler.STOP_JOB(job_name=>'UOFM.DBMS_JOB$_5229', force=>true);

exec sys.dbms_scheduler.STOP_JOB(job_name=>'SYS.NUM_JOB_64', force=>true);

BEGIN dbms_scheduler.stop_job('JOB_ADM_ANALYZE_FULL'); END;

exec sys.dbms_scheduler.STOP_JOB(job_name=>'SYS.JOB_ADM_ANALYZE_FULL', force=>true);
exec sys.dbms_scheduler.STOP_JOB(job_name=>'BDEMQ.MV_RF$J_0_S_64394', force=>true);
exec sys.dbms_scheduler.STOP_JOB(job_name=>'BDEMQ.DBMS_JOB$_13', force=>true);
exec sys.dbms_scheduler.STOP_JOB(job_name=>'BDEMQ.MV_RF$J_0_S_64394 ', force=>true);
exec sys.dbms_scheduler.STOP_JOB(job_name=>'SYS.NUM_JOB_13', force=>true);
exec sys.dbms_scheduler.STOP_JOB(job_name=>'BDEMQ.MV_RF$J_0_S_64612', force=>true);
exec sys.dbms_scheduler.STOP_JOB(job_name=>'BDEMQ.MV_RF$J_0_S_64546', force=>true);
exec sys.dbms_scheduler.STOP_JOB(job_name=>'BDEMQ.MV_RF$J_0_S_64546', force=>true);
exec sys.dbms_scheduler.STOP_JOB(job_name=>'BDEMQ.MV_RF$J_0_S_64296', force=>true);
exec sys.dbms_scheduler.STOP_JOB(job_name=>'BDEMQ.MV_RF$J_0_S_64296', force=>true);
exec sys.dbms_scheduler.STOP_JOB(job_name=>'BDEMQ.MV_RF$J_0_S_64376', force=>true);
exec sys.dbms_scheduler.STOP_JOB(job_name=>'BDEMQ.MV_RF$J_0_S_64376', force=>true);

EXEC DBMS_SCHEDULER.START_JOB (job_name => 'JOB_APP_REF_AMOSTRA_CALHA');

-- dropar jobs:
BEGIN DBMS_SCHEDULER.DROP_JOB(job_name => '"VIPW"."DBMS_JOB$_13821"', defer => false, force => false); END;

-- Tratativas para jobs de dbms_scheduler_jobs 'INSTANCIA'.NUM_JOB_'NUMERO'

select sid, job, LAST_DATE, THIS_DATE from dba_jobs_running where job = '9221';

select sid,serial# from v$session where sid='10708';

exec dbms_session.set_identifier('8136041');

SET LINESIZE 4000
COLUMN spid FORMAT A10
COLUMN username FORMAT A10
COLUMN program FORMAT A45

SELECT s.inst_id,
 s.sid,
 s.serial#,
 --s.sql_id,
 p.spid,
 s.username,
 s.program
FROM gv$session s
 JOIN gv$process p ON p.addr = s.paddr AND p.inst_id = s.inst_id
WHEREs.type != 'BACKGROUND' and s.sid= (select sid from dba_jobs_running where job = '9863');

ALTER SYSTEM KILL SESSION '5660,17859,@1' IMMEDIATE;

ALTER SYSTEM KILL SESSION '5814,45777,@2' IMMEDIATE;
ALTER SYSTEM KILL SESSION '5814,27000,@3' IMMEDIATE;

ALTER SYSTEM KILL SESSION 'sid,serial#' IMMEDIATE;

ALTER SYSTEM KILL SESSION '518,53453' IMMEDIATE;

alter system kill session '518,53453';

4221157
SELECT A.AUDIT_ENABLED
FROM (SELECT COUNT(*) AUDIT_ENABLED
FROM DBA_STMT_AUDIT_OPTS
 WHERE AUDIT_OPTION = 'CREATE SESSION') A


-- montar - NFS
mount -o rw,bg,hard,rsize=32768,wsize=32768,vers=3,nointr,timeo=600,tcpcipdss01.ep.petrobras.com.br:/ep01/bd/ep_dba_oracle_bkp /oracle_bkp3/cipd

-- comando para baixar uma instancia por nó:

srvctl stop instance -i rcfinda -d find -f
srvctl start instance -i pepes2 -d pepes
srvctl stop instance -i pepes2 -d pepes

 R1966796
 
-- boot em servidor:
reboot /now
 
-- analisar o processo do RMAN que esteja running:
set lines 2000 pages 2000
col status for a10
col operation for a12
select SID,OPERATION,STATUS,MBYTES_PROCESSED,START_TIME,END_TIME,INPUT_BYTES/1024/1024 INPUT_MB,OUTPUT_BYTES/1024/1024 OUTPUT_MB from V$RMAN_STATUS where status like 'RUNNING%';
 
-- comando para subir o banco em mount restrito
 startup mount restrict;
 
-- logar em PDBs:
show pdbs
ALTER SESSION SET CONTAINER=pdb1;
SHOW CON_NAME

-- voltar ao root do CBD:
alter session set container=CDB$ROOT;

. c1n003d.env
export ORACLE_PDB_SID=FIND

-- comando para baixar os resources do - cluster de maquina single
Usario: root
cd $ORACLE_HOME/bin - grid

./crsctl stat res -t
./crsctl stop has 
./crsctl start has
./crsctl stat res -t

-- comando para subir asm - logado com root na pasta bin do grid:
./crsctl start res ora.asm -init 

//asm nao sobe
systemctl status ohas
systemctl stop ohas.service
systemctl disable ohas.service
e dá um outro reboot

-- compilar no grid e verificar indisponibilidade total:
./crsctl status res -t -init

-- filtrar os processos no cluster relacionado a banco de dados:
crsctl status res -t | grep db

-- Parar todo o CRS. Validar o stop/start
Usario: root
cd $ORACLE_HOME/bin - - grid

./crsctl stat res -t
./crsctl stop crs
./crsctl start crs
./crsctl stat res -t

-- verificando os serviços locais do cluster
./crsctl check crs
./crsctl status res -t -init

-- comando para baixar os serviços d.bin:
ps -ef | grep d.bin
./crsctl stop crs -f
./crsctl stop has -f

crsctl stat res -t -w '(TARGET != ONLINE) or (STATE != ONLINE)'

-- adicionar banco no cluster
srvctl add database -d hprompt -o /u01/app/oracle/product/19/db_1 -domain PETROBRAS.COM.BR
srvctl start database -d hprompt

-- remover banco do cluster:
srvctl remove database -d hprompth

-- adicionar serviço no s.o em maquina RAC:
srvctl add service -d exadsv01 -s sdocd.petrobras.com.br -r rcexadsv01a,rcexadsv01b
srvctl start service -d exadsv01 -s sdocd.petrobras.com.br

-- adicionar serviço no s.o em container exacc:
srvctl add service -d c1s004p -pdb exaprd01 -s exaprd01.PETROBRAS.COM.BR -preferred 'c1s004p1', 'c1s004p2', 'c1s004p3', 'c1s004p4', 'c1s004p5', 'c1s004p6', 'c1s004p7', 'c1s004p8'
srvctl start service -d c1s004p -s exaprd01.PETROBRAS.COM.BR

exec dbms_service.start_service('gdptp.petrobras.com.br');

-- remover serviço no s.o em container exacc:
srvctl remove service -d c1s004p -s exaprd01.PETROBRAS.COM.BR

-- ver serviços exacc
select * from dba_services where lower(name) like '%e6ca%';
SELECT name,network_name FROM dba_services;
set lines 200
SELECT name,network_name FROM gv$active_services; 
select inst_id, name, network_name from gv$active_services order by name, inst_id;
select inst_id, name, network_name from gv$active_services where name like '%svc_spotfirelab%' order by name, inst_id;

dcli -l oracle -g ~/dbs_group ". ~/c1s1abp.env;lsnrctl status|grep -i sptp.petrobras.com.br"
dcli -l oracle -g ~/dbs_group ". ~/c5n101p.env;lsnrctl status|grep -i c5n301p"

-- parar/subir serviços exacc
alter session set container=aplabp08

exec DBMS_SERVICE.STOP_SERVICE('SYS.KUPC$S_1_20220824132705_0',DBMS_SERVICE.ALL_INSTANCES);
exec DBMS_SERVICE.DELETE_SERVICE('SYS.KUPC$C_1_20220824132705_0');
alter pluggable database DEPBR save state;

exec DBMS_SERVICE.START_SERVICE('exadsv01.petrobras.com.br',DBMS_SERVICE.ALL_INSTANCES);
alter pluggable database PRIMP save state instances=all;

-- parar/subir serviços exacc em apenas 1 pbd:
exec DBMS_SERVICE.STOP_SERVICE('aplabp.PETROBRAS.COM.BR','aticp.petrobras.com.br');
exec DBMS_SERVICE.DELETE_SERVICE('SYS.KUPC$C_1_20220824132705_0');
exec DBMS_SERVICE.START_SERVICE('aticp.petrobras.com.br','aticp.petrobras.com.br');
alter pluggable database APLABP save state instances=all;

-- criar serviços no exacc:

exec DBMS_SERVICE.CREATE_SERVICE('svc_exadsv01','b360t.petrobras.com.br');
exec DBMS_SERVICE.START_SERVICE('svc_spotfirelab',DBMS_SERVICE.ALL_INSTANCES);
alter pluggable database SPOTFIRELAB save state instances=all;


alter pluggable database exaprd01 save state instances=all; start service -d c1s004p -s exaprd01.PETROBRAS.COM.BR

-- ver serviços exacc
select inst_id, name, network_name from gv$active_services order by name, inst_id 
select inst_id, name, network_name from gv$active_serviceswhere name like '%LISTENER_GME1ADB3_dbsrvprddb10s.cpdprd.pt%' order by name, inst_id;

exec DBMS_SERVICE.STOP_SERVICE('cwn101p_peplibra.paas.oracle.com',DBMS_SERVICE.ALL_INSTANCES);

exec DBMS_SERVICE.START_SERVICE('savd.petrobras.com.br',DBMS_SERVICE.ALL_INSTANCES);

alter pluggable database US01T save state instances=all;

-- criar serviços no exacc:

exec DBMS_SERVICE.STOP_SERVICE('aplabp.PETROBRAS.COM.BR','aticp.petrobras.com.br');
exec DBMS_SERVICE.DELETE_SERVICE('aplabp.PETROBRAS.COM.BR');
alter pluggable database APLABP save state instances=all;

begin
exec DBMS_SERVICE.CREATE_SERVICE('aplabp.petrobras.com.br','aticp.petrobras.com.br');
exec DBMS_SERVICE.START_SERVICE('b360t.petrobras.com.br',DBMS_SERVICE.ALL_INSTANCES);
end;
/

alter pluggable database exaprd01 save state instances=all;

-- avaliar a compatibilidade:
select username, password_versions from dba_users where username = 'BAMS_APLICACAO';

set long 9999999
select dbms_metadata.get_ddl('USER','BAMS_APLICACAO')||';' from dual;

-- mudar a PFL para trocar para mesma senha:

alter user BAMS_APLICACAO profile DEFAULT;

realizar a troca da senha pra mesma.

alter user BAMS_APLICACAO profile PFL_ADM_APPLICATION;

-- registar o banco no serviços do GRID
srvctl add database -d sicar -o /u01/app/oracle/product/19/db_1 -domain petrobras.com.br

-- validar o status do DG || - BASE:
select a.name, a.open_mode, a.database_role, b.host_name, b.instance_name, b.status from gv$database a, gv$instance b;

set lines 200
select name, open_mode, database_role from gv$database;
select host_name, instance_name, status, logins from gv$instance;

set lines 20000000000000000
select NAME, OPEN_MODE, RESTRICTED, OPEN_TIME,RECOVERY_STATUS from gv$pdbs;

-- limpeza na area de shared pool:
alter system flush shared_pool;

-- comando para saber quais são os nomes do nós do cluster. 

logado com grid - olsnodes

-- para o serviço somente do ASM - logado com grid:
srvctl status asm
srvctl stop asm
srvctl start asm

./crsctl start res ora.asm -init

./crsctl start res ora.recurso -init

./crsctl start res ora.crsd -init

-- query para verificar o retetion da UNDO:
SELECT ts.tablespace_name, ts.retention FROMdba_tablespaces ts wherets.contents = 'UNDO';

ALTER TABLESPACE UNDO01 RETENTION NOGUARANTEE;

-- caminho/status do wallet:
set linesize 200
col WALLET_DIR for a32
col status for a21
select STATUS, WRL_TYPE WALLET_DIR, WRL_PARAMETER from GV$ENCRYPTION_WALLET;

select INST_ID, STATUS, WRL_TYPE from GV$ENCRYPTION_WALLET;

select * from gv$encryption_wallet;

-- abrir o wallet:
ADMINISTER KEY MANAGEMENT SET KEYSTORE OPEN IDENTIFIED BY "entub#d0sh";

alter system set encryption key identified by "<wallet-pwd>";

ALTER SYSTEM SET ENCRYPTION KEY IDENTIFIED BY "Entub#d0sh";

ALTER SYSTEM SET ENCRYPTION KEY AUTHENTICATED BY "Entub#d0sh";

-- tbs criptografada:
SELECT NAME, ENCRYPTIONALG ENCRYPTEDTS, STATUS FROM
V$ENCRYPTED_TABLESPACES, V$TABLESPACE WHERE V$ENCRYPTED_TABLESPACES.TS# = V$TABLESPACE.TS#; 

SELECT NAME, ENCRYPTIONALG ENCRYPTEDTS FROM V$ENCRYPTED_TABLESPACES, V$TABLESPACE WHERE V$ENCRYPTED_TABLESPACES.TS# = V$TABLESPACE.TS#;

SELECT tablespace_name, encrypted, status FROM dba_tablespaces where tablespace_name like '%';

-- No servidor para trocar de senha

orapki wallet change_pwd -wallet $ORACLE_BASE/admin/hepbrf/wallet -oldpwd "<wallet-pwd>" -newpwd "Entub#d0sh"

-- criação de wallet novo
//sqlnet
vi /u01/app/oracle/product/19/db_1/network/admin/sqlnet.ora

WALLET_LOCATION=(SOURCE=(METHOD=file)(METHOD_DATA=(DIRECTORY=/u01/app/oracle/admin/$ORACLE_SID/wallet)))
SQLNET.ENCRYPTION_SERVER=ACCEPTED
SQLNET.ENCRYPTION_TYPES_SERVER=AES256
SQLNET.CRYPTO_CHECKSUM_SERVER=ACCEPTED
SQLNET.CRYPTO_CHECKSUM_TYPES_SERVER=SHA1

SQL> SELECT * FROM GV$ENCRYPTION_WALLET;

[oracle@npaa4981:~] $ mkdir -p /u01/app/oracle/admin/hprompt/wallet/
[oracle@npaa4981:~] $ sqlplus / as sysdba

SQL> alter system set encryption key identified by Entub#d0sh;

ADMINISTER KEY MANAGEMENT CREATE KEYSTORE '/u01/app/oracle/admin/tepqa/wallet' IDENTIFIED BY "Entub#d0sh";
ADMINISTER KEY MANAGEMENT SET KEY FORCE KEYSTORE IDENTIFIED BY "Entub#d0sh" WITH BACKUP;

SQL> SELECT * FROM GV$ENCRYPTION_WALLET;

se for rac fazer Nos 2 nodes
srvctl getenv database -d sigemp
srvctl setenv database -d sigemp -t ORACLE_BASE=$ORACLE_BASE


criação de wallet novo
//sqlnet
vi /u01/app/oracle/product/19/db_1/network/admin/sqlnet.ora

WALLET_LOCATION=(SOURCE=(METHOD=file)(METHOD_DATA=(DIRECTORY=/u01/app/oracle/admin/$ORACLE_SID/wallet)))

SQLNET.ENCRYPTION_SERVER=ACCEPTED
SQLNET.ENCRYPTION_TYPES_SERVER=AES256
SQLNET.CRYPTO_CHECKSUM_SERVER=ACCEPTED
SQLNET.CRYPTO_CHECKSUM_TYPES_SERVER=SHA1

SQL> SELECT * FROM GV$ENCRYPTION_WALLET;


INST_ID WRL_TYPE
---------- --------------------
WRL_PARAMETER
--------------------------------------------------------------------------------
STATUS WALLET_TYPE WALLET_OR KEYSTORE FULLY_BAC
------------------------------ -------------------- --------- -------- ---------
CON_ID
----------
1 FILE
/u01/app/oracle/admin/hprompt/wallet/
NOT_AVAILABLE UNKNOWN SINGLE NONE UNDEFINED
0


[oracle@npaa4981:~] $ mkdir -p /u01/app/oracle/admin/hprompt/wallet/
[oracle@npaa4981:~] $ sqlplus / as sysdba

SQL> alter system set encryption key identified by Entub#d0sh;

System altered.

[oracle@npaa4981:~] $ $ORACLE_HOME/bin/orapki wallet create -wallet $ORACLE_BASE/admin/sigemp/wallet -auto_login -pwd Entub#d0sh
Oracle PKI Tool Release 21.0.0.0.0 - Production
Version 21.0.0.0.0
Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.


Operation is successfully completed.
[oracle@npaa4981:~] $ sqlplus / as sysdba


SQL> SELECT * FROM GV$ENCRYPTION_WALLET;

INST_ID WRL_TYPE
---------- --------------------
WRL_PARAMETER
--------------------------------------------------------------------------------
STATUS WALLET_TYPE WALLET_OR KEYSTORE FULLY_BAC
------------------------------ -------------------- --------- -------- ---------
CON_ID
----------
1 FILE
/u01/app/oracle/admin/hprompt/wallet/
OPEN PASSWORD SINGLE NONE NO
0


se for rac fazer Nos 2 nodes
srvctl getenv database -d sigemp
srvctl setenv database -d hepbrf -t ORACLE_BASE=$ORACLE_BASE
copiar wallet nos 2 nodes

srvctl getenv database -d ipaet
srvctl setenv database -d hepbrf -t ORACLE_BASE=$ORACLE_BASE


//wallet perdido e sem nada criptografado
segue ai
rm wallet.sso do diretorio
SQL> alter system set "_db_discard_lost_masterkey"=true scope=memory;
System altered.
SQL> administer key management set keystore open identified by Entub#d0sh;
keystore altered.
SQL> administer key management set key identified by Entub#d0sh with backup;
keystore altered.
SQL> administer key management create auto_login keystore from keystore '/u01/app/oracle/admin/ipaet/wallet/' identified by Entub#d0sh;
shutdown immediate
startup

-- Mesas de Sustentação:

ABAST: N4-SAP-SUSTENTACAO-ABAST_GE
APLAT: N4-APLAT-BC
BDIEP: N4-BD-US
Canal Cliente: N4-SUSTENTACAO-CANAL_CLIENTE
BDEMQ: N4-FC-SPSCO
SINS: N4-APP_CRITICAS_CSC
TCRP: N4-GESTAO_DADOS
PNAM: N4-APP_NAOCRITICAS_US
QVX9: N4-PLANCOR-BC
SLABW: N4-LABWARE
SILAB: N4-APP_CRITICAS_CSC
CORP_R3: N4-etl
SLWTP: entrar em contato por email com leandropaiva@transpetro.com.br
ORASTATUS: N3-INFRA-BD-ORACLE
NTSS: N4-APP_CRITICAS_CORP
DBMS_JOBS: N4-BD-US
SGER: N4-APP_CRITICAS_CORP
BRFF_OWNER: N4-SUSTENTACAO-CANAL_CLIENTE
SZ73Y: N4-APP_CRITICAS_US
PCSW: N4-APP_CRITICAS_CORP
ARO: N4-APP_NAOCRITICAS_VIXTEAM
JS86: N4-SIGEM-AWS
INFOPOCO: N4-INFO 
VIPW: N4-APP_NAOCRITICAS_CSC
Time C: N3-INFRA-BD-C
Redes: N3-SUPORTE-LAN-CPD - N3-REDES_CPD
Storage: N4-STORAGE_BACKUP_HDS
Service desk: N1-SD2_SERVICE_DESK
time DNS: N3-OPER-DHCP-DNS
BDEMQ-CI - OID: N4-GAIA
BDEMQ-CI: N4-FC-SPSCO
_SOAINFRA: N3-INFRA-WEB-UNIX - N4-CCI
SPGT: N4-APP_CRITICAS_US
balanceadores: N3-BALANCEAMENTO

-- mesa de BKP | NETBACKUP
N4-BACKUP_VERITAS

-- mesa de BKP | DELL
N4-STORAGE_BACKUP_DELL-EMC

-- mesa de BKP | AVAMAR
N3-STORAGE_BACKUP

-- senhas bdiep:
produção => EPPBDI#3P

homoloção => EPPBDI#2H

dsv => EPPBDI#1D

owner: INR, APR, EEP, AQG, TBB, ACG, ACO

-- catalog standby
rman target / catalog rman_stby/qwerasdf#357@rman.PETROBRAS.COM.BR

rman target / catalog rman_stby_bkp/qwerasdf#357@rman_bkp.petrobras.com.br

-- caminho do bp.conf
vi /usr/openv/netbackup/bp.conf

-- caminho do bphdb | criar a pasta mkdir bphdb - chmod 777 bphdb
/usr/openv/netbackup/logs

-- rebuild:
select 'alter index '||owner||'.'||index_name||' rebuild parallel 8 nologging;'
from dba_indexes
WHERE OWNER='CFORM' AND STATUS='UNUSABLE';

select 'alter index '||OWNER||'.'||INDEX_NAME||' rebuild online parallel 4 nologging;' from dba_indexes where tablespace_name = 'FWCA_I_01'
union all select 'alter index '||OWNER||'.'||INDEX_NAME||' noparallel;' from dba_indexes where tablespace_name = 'FWCA_I_01';

set lines 200
set pages 0
select 'alter index '||OWNER||'.'||segment_name||' rebuild online parallel 4 nologging;' from dba_segments where tablespace_name = 'TS_SEDE_I_01'
and segment_type = 'INDEX'
union all
select 'alter index '||OWNER||'.'||segment_name||' noparallel;' from dba_segments where tablespace_name = 'CCMULTI_I01'
and segment_type = 'INDEX'

select 'ALTER INDEX '||owner||'.'||SEGMENT_NAME||' REBUILD TABLESPACE DATA_MAD;' 
from dba_segments where tablespace_name='DATA_MAD_BKP' and segment_type = 'JS86';

alter index JS86.UN_CT_DOC_PREVISTO rebuild online parallel 4 nologging;

alter index JS86.UN_CT_DOC_PREVISTO rebuild noparallel;

alter INDEX JS86.UN_CT_DOCUMENTO rebuild;

alter INDEX JS86.UN_DOCU_NM_DOCUMENTO rebuild;

tabela documento previsto 

alter INDEX JS86.UN_CT_DOC_PREVISTO rebuild;

ALTER INDEX JS86.UN_DOPR_NM_DOC_PREVISTO REBUILD;

select 'alter index '||owner||'.'||index_name||' rebuild parallel 8 nologging;'
from dba_indexes
WHERE OWNER='JS86' AND STATUS='UNUSABLE';

--inodes

tar -czvf /oracle_bkp3/cipd/trace_20210609.tar.gz trace_20210609

-- Alocar espaço em fs:

# lvextend -L 16G /dev/mapper/vg8sda24553-u01_oradiag == (Os 29GB que ja tinha + os 10GB que vc quer adicionar)

2- Verificar qual o sistema de arquivo do LVM

Nesse caso é ext4

#mount | grep sicardsv-archive

3 - Validar o aumento do LVM com o comando resize2fs
 
# resize2fs /dev/mapper/vg7sda29706-u01_grid

caso o sistema de arquivo fosse XFS,o comando seria xfs_growfs : 

# xfs_growfs /dev/mapper/system-u01--app

lvextend -L 16g /dev/mapper/vg7sda11618-u01--gidiag

resize2fs /dev/mapper/vg7sda11618-u01--gidiag

--ext4
resize2fs /dev/mapper/vg7sda9690-u01--admin

--xfs
xfs_growfs /dev/mapper/system-u01_app

-- - FS Limpeza de fs: || /u01/app/oracle/diag
	
-- Verificar tamanho das pastas de um diretório em ordem crescente de tamanho
 
-- maior ofensor: du -sh ./* -- du -sh ./* | sort -h	
-- verificar os maiores ofensores do /u01/app: du -k --exclude=/u01/app/oracle/diag --exclude=/u01/app/oracle/admin /u01/app | sort -n
-- as maiores pastas do user logado: du -k | sort -n

rm -rf *.core
rm *.trc
rm *.trm

mv incident incident_20220720
mkdir incident
tar -czvf incident_20220720.tar.gz incident_20220720
rm -rf incident_20220720

mv oracle.ahf oracle.ahf_S2337037
tar -czvf oracle.ahf_S2337037.tar.gz oracle.ahf_S2337037
rm -rf oracle.ahf_S2337037

mv vmcore_bkp vmcore_bkp_20220823
mkdir alert
tar -czvf vmcore_bkp_20220823.tar.gz vmcore_bkp_20220823
rm -rf vmcore_bkp

mv trace trace_20220831
mkdir trace
tar -czvf trace_20220831.tar.gz trace_20220831
rm -rf trace_20220831

mv alert alert_20220831
mkdir alert
tar -czvf alert_20220831.tar.gz alert_20220831
rm -rf alert_20220831

mv audit audit_20220621
mkdir audit
tar -czvf audit_20220614.tar.gz audit_20220614
rm -rf audit_20220621

mv adump adump_20220622
mkdir adump
tar -czvf adump_20220620.tar.gz adump_20220620
rm -rf adump_20220622

mv cdump cdump_20220811
mkdir cdump
tar -czvf cdump_20220811.tar.gz cdump_20220811
rm -rf cdump_20220811

mv backup backup_20210723
mkdir backup
tar -czvf backup_20210723.tar.gz backup_20210723
rm -rf backup_20210723

mv cfile cfile_20210623
mkdir cfile
tar -czvf cfile_20210623.tar.gz cfile_20210623
rm -rf cfile_20210623

mv log log_20220511
mkdir log
tar -czvf log_20220511.tar.gz log_20220511
rm -rf log_20220511

mv utl utl_20220201
mkdir cfile
tar -czvf utl_20220201.tar.gz utl_20220201
rm -rf utl_20220201

-- apagar archivos: find . -name "*.arc" -mtime +1 -exec rm {} \;

-- Assigned Service Department 
N3-INFRA-APLICACOES_AB

-- BKP de archive: /u01/app/oracle/admin/<nome_da_base>/scripts/backup

nohup ./scrRmanTapeArchive.sh &
./scrRmanDDBoostFullOnline.sh &

SELECT LOCAL_TRAN_ID, GLOBAL_TRAN_ID,STATE,
'EXECUTE DBMS_TRANSACTION.PURGE_LOST_DB_ENTRY('||''''||LOCAL_TRAN_ID||''''||');'||chr(13)||'COMMIT;'
FROM SPME_INTER
ORDER BY 1 ASC;

rollback force '38.14.527200';
	
-- deletar archive:

delete noprompt archivelog all completed before 'sysdate-1/24';

delete noprompt archivelog until time = 'sysdate-0.5' backed up 1 times to sbt ;
delete noprompt archivelog until time = 'sysdate-0.5' backed up 2 times to sbt ;

-- Verificar usuarios no banco:

set lines 80
select username, account_status, profile, created from dba_users where username='sadiscorap01';

SZ74Y

-- MATAR sessão:
SELECT 'alter system kill session '''||s.sid||','||s.serial#||','||'@'||s.inst_id||''' immediate;' FROM gv$session s
JOIN gv$process p
ON p.addr = s.paddr
AND p.inst_id = s.inst_id
WHERE s.type != 'BACKGROUND' and s.username = 'poweron.po_mutex';



-----------------------------------------------------------------

select vs.sid,vs.username,vs.osuser, vs.process,vp.spid
from gv$session vs, gv$process vp
where vs.paddr = vp.addr
and vs.username='SYS';

SELECT'kill -9 ' || P.SPID
FROMV$SESSION S
INNER JOINV$PROCESS P ONS.PADDR = P.ADDR
where S.username = UPPER('ASY12W');

---------------------------------------------------------------------------------

column path format a20
set lines 132
set pages 50
select
s.seconds_in_wait tempo_espera_seg,
s.OSUSER os_user, s.sid, s.USERNAME Bd_user, ' Bloqueado por ==> ' motivo,
b.OSUSER /*bloking_osuser*/ osuser_blocking, b.USERNAME /*bloking_username*/ dbuser_blocking , s.blocking_session dbsection_blocking ,
--s.serial#,
s.wait_class
from
gv$session s join gv$session b on b.sid = s.BLOCKING_SESSION
where
s.blocking_session is not NULL
order by
s.blocking_session;
	
SELECT SE.INST_ID IID
,DECODE(EVENT
,'jobq slave wait'
,'zIJQ'
,DECODE(SE.STATUS
,'ACTIVE'
,'ACT'
,'INACTIVE'
,'INA'
,SE.STATUS)) STA
,REPLACE(TO_CHAR(FLOOR(LAST_CALL_ET / 3600)
,'00') || ':' ||
TO_CHAR(FLOOR(MOD(LAST_CALL_ET
,3600) / 60)
,'00') || ':' ||
TO_CHAR(MOD(MOD(LAST_CALL_ET
,3600)
,60)
,'00')
,' '
,NULL) L_S
,NVL(SE.USERNAME
,PR.PROGRAM) USERNAME
,OSUSER
, 'ALTER SYSTEM KILL SESSION ' ||'''' || SE.SID || ',' || SE.SERIAL# || ',@' || SE.INST_ID|| '''' || ' IMMEDIATE;'SID_SERIAL
,PR.SPID || ' (' || PR.PROGRAM || ')' SPID_PROGRAM
,HASH_VALUE SQL_HSH
,SQ.SQL_ID
-- ,SQ.CHILD_NUMBER CN
,EXECUTIONS SQL_EXE
,ROUND(((ELAPSED_TIME + CPU_TIME) /
DECODE(EXECUTIONS
,0
,1
,EXECUTIONS) / 1000000),5) SQL_ELA
,SQL_PROFILE
,SQL_PLAN_BASELINE
,PLAN_HASH_VALUE
,SQL_TEXT
,SE.PREV_SQL_ID
,(SELECT MAX('(' || LON.OPNAME || ') (' || LON.SOFAR || '->' ||
LON.TOTALWORK || ') : ' || LON.TARGET)
FROM V$SESSION_LONGOPS LON
WHERE LON.SID = SE.SID
AND LON.SQL_HASH_VALUE = SE.SQL_HASH_VALUE
AND SOFAR < TOTALWORK) LO
,' (#W : ' || RPAD(SEQ#
,5) || ' | ST : ' ||
DECODE(WAIT_TIME
,0
,'WAIT'
,-1
,'FAST'
,-2
,'UNKN'
,WAIT_TIME) || ') ' || EVENT W
,SE.BLOCKING_SESSION
,SE.SECONDS_IN_WAIT
,SE.TERMINAL
,SE.OSUSER
,SE.MACHINE
,SE.LOGON_TIME
,SE.PROGRAM
,SE.FAILED_OVER
,SE.SERVER
,SE.SERVICE_NAME
,(SELECT SQL_FULLTEXT
FROM V$SQLAREA
WHERE SQL_ID = SE.SQL_ID) SQL_FULLTEXT
/*
,(SELECT OWNER || '.' || OBJECT_NAME || '(' || OBJECT_TYPE || ') - ' ||
SQ.PROGRAM_ID || '(' || SQ.PROGRAM_LINE# || ')'
FROM DBA_OBJECTS OB
,V$SQL SQ
WHERE HASH_VALUE = SE.SQL_HASH_VALUE
AND INST_ID = SE.INST_ID
AND CHILD_NUMBER = SE.SQL_CHILD_NUMBER
AND OB.OBJECT_ID = SQ.PROGRAM_ID) PRG_O
*/
FROM GV$SESSION SE
,GV$PROCESS PR
,GV$SQLAREA SQ
WHERE SE.INST_ID = PR.INST_ID
AND SE.INST_ID = SQ.INST_ID (+)
AND SE.PADDR = PR.ADDR(+)
AND SE.SQL_ID = SQ.SQL_ID(+)
AND SE.TYPE = 'USER'
-- AND SE.USERNAME NOT IN ('SYS', 'DBSNMP')
-- AND SE.USERNAME NOT IN ('QIOR_SOAINFRA')
-- AND SE.STATUS IN ('ACTIVE', 'KILLED', 'PSEUDO')
-- AND SE.SID NOT IN (SELECT SID
-- FROM V$MYSTAT)
--AND SE.USERNAME IN ('U4VI')
-- AND SE.MACHINE = 'moros'
--and osuser like 'sabiaep%'
-- AND SID in (256)
--and SE.INST_ID = 2
---and PR.SPID in () 24887 ALTER SYSTEM KILL SESSION '5515,40347,@1' IMMEDIATE;
ORDER BY STA
,L_S
,SE.USERNAME
,SID_SERIAL

---t3gd

---55yyu29u390rt
/*
select * from gv$sql s1 where sql_id= 'a4qn0ha0ub9th'
select * from gv$sql s1 where
*/

--- select * from gv$instance
--- select * from gv$database
--- select NAME, OPEN_MODE, RESTRICTED, OPEN_TIME,RECOVERY_STATUS from gv$pdbs;

-- nowait:
select 'alter system kill session ''' || s.sid || ',' || s.serial# || ',@' || s.inst_id || ''' immediate;' cmd
 ,      s.username
 ,      o.object_name
 ,      s.sid
 ,      s.serial#
 ,      s.inst_id
 ,      p.spid
 ,      s.program
 ,      s.machine
 ,      s.osuser
 ,      s.port
 ,      s.logon_time
 ,      sq.sql_text
 from   gv$locked_object l
 ,      dba_objects      o
 ,      gv$session       s
 ,      gv$process       p
 ,      gv$sql           sq
 where  o.object_id = l.object_id
 and    s.sid = l.session_id
 and    s.inst_id = l.inst_id
 and    p.addr = s.paddr
 and    sq.address(+) = s.sql_address
 order by s.username
 ,      s.inst_id
 ,      s.sid
 ,      s.serial#
 ,      o.object_name;
 
-- verificar sessões:
select count(username) as 'PO_CONNECT', 'TOTAL' as CONEXOES
from gv$session where username is not null
UNION
select count(username), 'ATIVOS'
from gv$session where username is not null and status = 'ACTIVE'
UNION
select count(username), 'INATIVOS'
from gv$session where username is not null and status = 'INACTIVE'
UNION
select count(username), 'PERDIDOS'
from gv$session where username is not null and status = 'SNIPED'
order by 1, 2;

-- lock de usuario

set linesize 200
set pagesize 60
col profile for a30
col USERNAME for a20
col ACCOUNT_STATUS for a10
SELECT USERNAME,EXPIRY_DATE, PROFILE,ACCOUNT_STATUS, DEFAULT_TABLESPACE from dba_users where username like '%%';

alter user IARM_APLICACAO account unlock;
alter user ROND_PR_REPAR_APLICACAO account unlock;
alter user TELEMAT_PR_REPAR account unlock;

alter user PO_CONNECT account lock;

alter user DNYR account unlock;
alter user SZ73Y_SIS account unlock;

-- JOBS CANCELADOS:
select * from dba_scheduler_job_run_details where job_name in ('JOB_MV_ACERVO_TRANSF_EXT') ORDER BY LOG_DATE DESC;

select * from dba_scheduler_jobs where job_name = 'JOB_MV_ACERVO_TRANSF_EXT'

-- validação do ORASTATUS para absorção:
set linesize 200
set pagesize 60
col profile for a30
col USERNAME for a20
col ACCOUNT_STATUS for a10
SELECT USERNAME,EXPIRY_DATE, PROFILE,ACCOUNT_STATUS, DEFAULT_TABLESPACE from dba_users where username like '%ORASTATUS%';

ALTER USER ORASTATUS IDENTIFIED BY niBanc06$ab account unlock;

exec dbms_session.set_identifier('T6354300');

set lines 200
SELECT * FROM orastatus.TBL_VERSAO;

-- Serial number - linux:

logado com root - dmidecode -t 1

-- Criar usuario no banco:
set linesize 200
set pagesize 60
col profile for a30
col USERNAME for a20
col ACCOUNT_STATUS for a10
SELECT USERNAME,EXPIRY_DATE, PROFILE,ACCOUNT_STATUS, DEFAULT_TABLESPACE from dba_users where username like '%SAPGRM01%';

SELECT USERNAME, PROFILE from dba_users where username like '%ORASTATUS%';

select 

set linesize 200
set pagesize 60
col profile for a30
col USERNAME for a20
col ACCOUNT_STATUS for a10
SELECT USERNAME, PASSWORD,ACCOUNT_STATUS, PROFILE, DEFAULT_TABLESPACE from dba_users where username like '%SAPGRM01%';

select username,expiry_date,account_status from dba_users where username like '%SYS%'; 

exec dbms_session.set_identifier('8668178');

select * from dba_users where username = 'DS9F';

CREATE USER YRTN IDENTIFIED BY mnJ#2kop9Z DEFAULT TABLESPACE "USERS"PROFILE "PFL_USER_TEMPORARY_365" ACCOUNT UNLOCK;
GRANT RADM_USER TO YRTN;
grant select on PCSW.MV_BI_CAEX_SUB_ES_GEO to YRTN;
grant select on PCSW.MV_BI_HIAS_SUB_ES_GEO to YRTN;
grant select on PCSW.MV_BI_SOLI_SUB_ES_GEO to YRTN;

CREATE USER DBSNMP IDENTIFIED BY Entub#d0sh DEFAULT TABLESPACE "USERS"PROFILE "PFL_ADM_TOOL" ACCOUNT UNLOCK;
CREATE USER ASD2HR IDENTIFIED BY mnJ#2kop9Z9 DEFAULT TABLESPACE "USERS"PROFILE "PFL_ADM_USER" ACCOUNT UNLOCK;

S0r#yWxQV9

CREATE USER CXL_ARCH IDENTIFIED BY S0r#yWxQV9 DEFAULT TABLESPACE "USERS" PROFILE "PFL_ADM_USER" ACCOUNT UNLOCK;

ALTER USER BDEMQ_E1_S IDENTIFIED BY Bdetste1#$ account unlock;
ALTER USER BDEMQ_S IDENTIFIED BY Bdetste1#$ account unlock;

ALTER USER DBSNMP IDENTIFIED BY E#x46C_FaU account unlock;
ALTER USER ASMSNMP IDENTIFIED BY E#x46C_FaU account unlock;

ALTER USER SYSTEM IDENTIFIED BY ap2015 account unlock;
ALTER USER SPAD_INTEGRACAO_SSP0 IDENTIFIED BY iJQ4xKo#Hb account unlock;

ALTER PROFILE PFL_ADM_APPLICATION limit password_life_time UNLIMITED;

ALTER USER SYS IDENTIFIED BY Entub#d0sh account unlock;

ALTER USER ASD2HR IDENTIFIED BY mnJ#2kop9Z9 account unlock;
ALTER USER E002_LNK IDENTIFIED BY mnJ#2kop9Z account unlock;

ALTER USER YDBB_INTEGRACAO_PBIP IDENTIFIED BY entub#2022$ account unlock;

-- criar a role:
create role RADM_USER;

-- Grant/Revoke system privileges:
grant alter session to RADM_USER;
grant create session to RADM_USER;
grant create synonym to RADM_USER;
grant query rewrite to RADM_USER;

-- grant pro usuario:
GRANT RADM_USER TO ASD2HR;

-- grant pro usuario de schema:
GRANT RADM_SCHEMA TO ASD2HR;

GRANT "RADM_DBA" TO ASD2HR WITH ADMIN OPTION;

desc dba_users;

create user redotrans identified by Entub#d0sh; 

-- Grant de DBA 
grant dba to system;
grant connect to system;
	
-- Grant para criação de JOBs
grant create job to asj7m1;

alter user SSP0 grant connect through ASD2HR;

alter session set current_schema = "APR";

alter user APLATDM GRANT CONNECT THROUGH ASD2HR;

-- pegar o hash de usuario:

SELECT USERNAME, PASSWORD,ACCOUNT_STATUS, PROFILE, DEFAULT_TABLESPACEfrom dba_users where username like '%DEPLOYBD_CONFIGURATOR%';

select name, PASSWORD from sys.user$ where name='DEPLOYBD_CONFIGURATOR';

create user DEPLOYBD_CONFIGURATOR IDENTIFIED BY values 'AC5AEDBD5025D821' DEFAULT TABLESPACE USERS profile PFL_ADM_TOOL; 

-- minha senha :
mnJ#2kop9Z
mnJ#2kop9z
mnJ#2kop9z1 
mnJ#2kop9z2
mnJ#2kop9Zz
mnJ#2kop9Z2

mnJ#2kop9Z9 - APLABH| aplabp | PEPBR | OLPR04 | APLATP | PEPEUHO | SISTT | APLABP02 | PWSATIH | SISTH | HEPBR | CXLH
mnJ#2kop9Z8 - 
mnJ#2kop9Z19 - sistp

-- lock controfile:
SELECT s.sid, serial#, username AS "User",   program, module, action, logon_time "Logon", l.*
FROM gv$session s, gv$enqueue_lock l
WHERE l.sid = s.sid and l.type = 'CF' AND l.id1 = 0 and l.id2 = 2;

-- Procedimento para compilação de script em ecomex - NPAA4287:

A entrada do ecomexp (PRD) esta no arquivo de TNS no client: C:\Oracle\PRODUCT\11.2.0\Client_1\network\admin

entrada: 

ecomexp =
(description=
(address=(protocol=tcp)(host=bdecomexp.petrobras.com.br)(port=1521))
(connect_data=(service_name=ecomexp.petrobras.com.br))) 
		
logar no cmd:

Realizado a copia da pasta de script que esta anexado no chamado no caminho por exemplo: C:\Consolidado p109oq_p109ov - petrobras DB\sql 
e ir até esse caminho no CMD.

logar com o sqlplus sys/Entubados@ecomexp as sysdba e depois de logado realizar o conn:

conn ASXX[ECMX]/senha@ecomexp - logado realizar um show user para verificar se esta logado com o onwer ecmx

depois é realizar o @install de dentro do banco e encaminhar as logs .lst que foram geradas na pasta /sql para o solicitante. 

-- ecomex
sqlplus asd2hr[ECMX]/mnJ#2kop9Z@ECOMEXP

conn ASD2HR[ECMX]/mnJ#2kop9Z

-- verificar a pct das query ativas no banco:
set line 999 pages 999
select sofar Blocks_Processed,totalwork Total_Work,
totalwork-sofar Total_Work_Left,start_time Start_Time,round((elapsed_seconds/60),0) Elapsed_Minutes,
substr(message,1,33) Message,username, round(sofar/totalwork*100,2) || '%' "Completed"
from v$session_longops where totalwork-sofar > 0 order by start_time desc;

-- adicionar serviço no s.o em maquina single:
srvctl add service -d aplabt -s SPTT.PETROBRAS.COM.BR 
srvctl start service -d aplabt -s SPTT.PETROBRAS.COM.BR
srvctl status service -d aplabt || crsctl status res -t

-- stop start nos serviços
srvctl stop service -d exadsv01 -s e6cad.petrobras.com.br
srvctl start service -d exadsv01 -s e6cad.petrobras.com.br


-- Desbloquear usuário no BD
set linesize 200
set pagesize 60
col profile for a30
col USERNAME for a20
col ACCOUNT_STATUS for a10
SELECT USERNAME,EXPIRY_DATE, PROFILE,ACCOUNT_STATUS, DEFAULT_TABLESPACE from dba_users where username like '%SYS%';

alter user ASCYCZ account unlock;

--mview log

select * from dba_mview_logs where LOG_OWNER= 'RST'; no pepbr

grant select on aco.MLOG$_CONTRATO_CONCESSAO to USR_QVX9;

grant select on PCSW.MV_BI_CAEX_SUB_ES_GEO to YRTN;
grant select on PCSW.MV_BI_HIAS_SUB_ES_GEO to YRTN;
grant select on PCSW.MV_BI_SOLI_SUB_ES_GEO to YRTN;


BE43 - R_ADMCADDOC - RADM_USER - R_BE43 - R_ADMCFORM
U4VC - R_U4VC - RADM_USER - R_ADMCADDOC - R_ADMCFORM 
D27F - R_CADDOC_DRL - R_D27F - RADM_USER
NTK6 - R_NTK6 - CONNECT
ACDU - R_ADMCFORM - R_ACDU - R_ADMCADDOC - RADM_USER 
ASC2OE
Y83Q - R_Y83Q


select 'revoke '||privilege||' on '||owner||'.'||table_name||' from '||grantee||';'
from dba_tab_privs where grantee in ('ASMC2L')
and privilege <> 'SELECT';

-- comando para saber as configurações do LINUX/AIX:
hostnamectl

-- query para analisar processos do RMAN no banco:
select s.INST_ID, s.PROCESS, s.sid, s.serial#, s.machine, s.username, s.action, s.logon_time, s.module from gv$session_wait w,
gv$session s
where w.sid = s.sid
and s.module like '%rman%'
--and s.event like '%Failed Logon Delay%'
order by 1, 2, 3;

select s.INST_ID, p.SPID, s.sid, s.serial#, s.machine, s.username, s.action, s.logon_time, s.module from gv$session_wait w,
gv$session s, gv$process p
where w.sid = s.sid
and s.module like '%rman%'
--and s.event like '%Failed Logon Delay%'
order by 1, 2, 3;

-- usuarios com - profile default
select * from dba_users where profile = 'DEFAULT';

ALTER USER GSMUSER PROFILE PFL_ADM_TOOL;

alter user C##RELOCATE PROFILE PFL_ADM_TOOL;
alter user GSMUSER PROFILE PFL_ADM_TOOL;
alter user REMOTE_SCHEDULER_AGENT PROFILE PFL_ADM_TOOL;
alter user DBSFWUSER PROFILE PFL_ADM_TOOL;
alter user GSMCATUSER PROFILE PFL_ADM_TOOL;
alter user GGSYS PROFILE PFL_ADM_TOOL;
alter user DVF PROFILE PFL_ADM_TOOL;
alter user OJVMSYS PROFILE PFL_ADM_TOOL;
alter user ORDDATA PROFILE PFL_ADM_TOOL;
alter user OLAPSYS PROFILE PFL_ADM_TOOL;
alter user DVSYS PROFILE PFL_ADM_TOOL;
alter user SAUDITUNIX PROFILE PFL_ADM_TOOL;
alter user SYSBACKUP PROFILE PFL_ADM_TOOL;
alter user SYSDG PROFILE PFL_ADM_TOOL;
alter user SYSKM PROFILE PFL_ADM_TOOL;
alter user SYSRAC PROFILE PFL_ADM_TOOL;
alter user DGUSER PROFILE PFL_ADM_TOOL;

-- - sys Senha padrão pra banco:

senha: Entub#d0sh - entub#d0sh - E#x46C_FaU

-- comando para alocar disco no asm:


alter diskgroup DG_DAT01 add disk 'dev/oracleasm/disks/AFL004B0' name AFL004B0;
alter diskgroup DG_DAT01 add disk 'ORCL:DSK012';
alter diskgroup DG_FRA01 add disk 'ORCL:DSK046';
alter diskgroup DG_FRA01 add disk '/dev/oracleasm/disks/DISKJ1'; 


--disks query de avaliar os discos disponiveis :

column path format a20
set lines 132
set pages 50 

select path, group_number group_#, disk_number disk_#, mount_status,
 header_status, state, total_mb, free_mb
from v$asm_disk
order by group_number;

--mudar os parâmetros do asm_power_limit/rebalance:
select INST_ID, OPERATION, STATE, POWER, SOFAR, EST_WORK, EST_RATE, EST_MINUTES from GV$ASM_OPERATION;
show parameter limit
alter diskgroup DG_DAT01 rebalance power 200;
alter diskgroup DG_FRA01 rebalance power 200;

-- retenção AWR:
select * from dba_hist_wr_control;

-- Rodar o PL SQL no - CMD:

C:\Program Files\PLSQL Developer>plsqldev.exe TNS_ADMIN= C:Program Files\PLSQL Developer\tnsnames.ora

C:\Program Files (x86)\PLSQL Developer>plsqldev.exe TNS_ADMIN= C:Program Files (x86)\PLSQL Developer\tnsnames.ora

-- testar acesso no banco via cmd:
sqlplus sys/ENtub4d0s#_@olhm14 as sysdba

-- Acessar BD com a própria chave, mas com privilégio do Owner dos objetos:
	Comando: alter user QVX9 grant connect through asd2hr;
	Login no PLSQL: asd2hr[SIOF_BW]
	
	exec dbms_session.set_identifier('T3666815');

-- concatenar comandos:

set lines 200
col name for a10
select NAME,DATABASE_ROLE,OPEN_MODE,LOG_MODE,FLASHBACK_ON,FORCE_LOGGING,PROTECTION_MODE,PROTECTION_LEVEL,SWITCHOVER_STATUS from v$database;

-- Maquina para rodar script: 
s6006db243
	
select username, profile from dba_users
where username in (select distinct grantee from dba_role_privs
where granted_role in ('EXECUTE_CATALOG_ROLE','HS_ADMIN_ROLE','ASAVCN','ASAWEG','ASY16N','DBA','ASC95L','IMP_FULL_DATABASE','ASXDAE','ASD0H4','EXP_FULL_DATABASE','RADM_DBA_DSV','ASY2G','ASY1SP','SYS','ASD0H4','SYS','ASB58L','ASCJSP','ASD0H4','SYS','UDBA') and profile like 'PFL_USER%';
 
 -- mview:
 select owner, mview_name, last_refresh_date from all_mviews where owner = 'TCRP';
 exec dbms_mview.refresh('"TCRP"."MV_BIREF_LOCAL_NEGOCIO"');
 
 -- Analisar Restore point:
SELECT NAME, TIME FROM V$RESTORE_POINT;

DROP RESTORE POINT ANTES_UPG19C;
DROP RESTORE POINT ANTES_TIMEZONE2; 
DROP RESTORE POINT PATCHES_20220224; 

CREATE RESTORE POINT RP_RECSEAL_20210727 GUARANTEE FLASHBACK DATABASE;

alterset archive_lag_target=600 sid='*';

-- parar/start todas as triggers da base
alter system set "_system_trig_enabled"=false sid='*';
alter system set "_system_trig_enabled"=true sid='*';
alter system set "_system_trig_enabled"=false sid='*';

-- triggers:
alter trigger ORASTATUS.TRG_LOG_SERVERERROR disable;

 -- Analisar flashback do banco:
SELECT FLASHBACK_ON FROM V$DATABASE;

-- Analisar - flashback recovery:
select FILE_TYPE, PERCENT_SPACE_USED, PERCENT_SPACE_RECLAIMABLE from v$flash_recovery_area_usage;

alter database flashback off;
alter database flashback on;

exec dbms_session.set_identifier('T5583675');

show parameter db_flashback_retention_target
alter system set db_flashback_retention_target = 2880 scope=memory spfile ='*';

show parameter db_recovery_file_dest_size
alter system set db_recovery_file_dest_size = 50G scope=memory spfile ='*';

-- script para avaliar a quantidade archive que esta sendo gerado. 
WITH
log AS (
SELECT /*+MATERIALIZE NO_MERGE*/ /* 2d.262 */
 --DISTINCT
 thread#,
 sequence#,
 first_time,
 blocks,
 block_size
FROM v$archived_log
 WHERE first_time IS NOT NULL
),
log_denorm AS (
SELECT /*+MATERIALIZE NO_MERGE*/ /* 2d.262 */
 TO_CHAR(TRUNC(first_time), 'YYYY-MM-DD') yyyy_mm_dd,
 TO_CHAR(TRUNC(first_time), 'Dy') day,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '00', 1, 0)) h00,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '01', 1, 0)) h01,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '02', 1, 0)) h02,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '03', 1, 0)) h03,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '04', 1, 0)) h04,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '05', 1, 0)) h05,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '06', 1, 0)) h06,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '07', 1, 0)) h07,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '08', 1, 0)) h08,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '09', 1, 0)) h09,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '10', 1, 0)) h10,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '11', 1, 0)) h11,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '12', 1, 0)) h12,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '13', 1, 0)) h13,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '14', 1, 0)) h14,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '15', 1, 0)) h15,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '16', 1, 0)) h16,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '17', 1, 0)) h17,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '18', 1, 0)) h18,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '19', 1, 0)) h19,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '20', 1, 0)) h20,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '21', 1, 0)) h21,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '22', 1, 0)) h22,
 SUM(DECODE(TO_CHAR(first_time, 'HH24'), '23', 1, 0)) h23,
 ROUND(SUM(blocks * block_size) / POWER(10,9), 1) TOT_GB,
 COUNT(*) cnt,
 ROUND(SUM(blocks * block_size) / POWER(10,9) / COUNT(*), 1) AVG_GB
FROM log
 GROUP BY
 TRUNC(first_time)
 ORDER BY
 TRUNC(first_time) DESC
),
ordered_log AS (
SELECT /*+MATERIALIZE NO_MERGE*/ /* 2d.262 */
 ROWNUM row_num_noprint, log_denorm.*
FROM log_denorm
),
min_set AS (
SELECT /*+MATERIALIZE NO_MERGE*/ /* 2d.262 */
 MIN(row_num_noprint) min_row_num
FROM ordered_log
)
SELECT /*+NO_MERGE*/ /* 2d.262 */
 log.*
FROM ordered_log log,
 min_set ms
 WHERE log.row_num_noprint < ms.min_row_num + 14
 ORDER BY
 log.yyyy_mm_dd DESC;
	 

-- stop/start no netbkp - logado com root
/usr/openv/netbackup/bin/goodies/netbackup stop
/opt/VRTSpbx/bin/vxpbx_exchanged stop

-- verificar o serviço:
/usr/openv/netbackup/bin/bpps -x
 
/opt/VRTSpbx/bin/vxpbx_exchanged start
/usr/openv/netbackup/bin/goodies/netbackup start

-- stop 
/usr/openv/netbackup/bin/bp.kill_all

/usr/openv/netbackup/bin/bpclntcmd -pn -verbose

-- verificar o serviço:
/usr/openv/netbackup/bin/bpclntcmd -pn

-- start
/usr/openv/netbackup/bin/bp.start_all

-- verificar rota - netbkp:
netstat -rn


-- permissão: https://support.oracle.com/knowledge/Oracle%20Database%20Products/2332879_1.html

chmod 6751 oracle 

-- troca do parametro backup_tape_io_slaves
verificar como esta o arquivo de parametro se é init ou spfile - Se o banco for com init, é colocar o parametro no arquivo e baixar e subir o banco.
alter system set backup_tape_io_slaves=true scope=both sid ='*';

-- - DG - Analisar DATA guard:

-- Verificar se tem dataguard:
select open_mode,database_role from v$database;
show parameter log_archive_config

-- query que aponta o apply log do standby
select NAME, VALUE, TIME_COMPUTED, DATUM_TIME from v$dataguard_stats;

-- query GAP de sequencia
SELECT THREAD#, LOW_SEQUENCE#, HIGH_SEQUENCE# FROM V$ARCHIVE_GAP;

-- query de sincronismo
set lines 1000 
select 'APPLIED' STATUS, thread#, max(sequence#),
to_char(max(next_time),'dd/mm/yyyy hh24:mi:ss') next_time
from v$archived_log where applied = 'YES' group by thread#
union
select 'RECEIVED' STATUS, thread#, max(sequence#),
to_char(max(next_time),'dd/mm/yyyy hh24:mi:ss') next_time
from gv$archived_log group by thread# order by status, thread#;

-------------------------------------------------------------------
setlinesize 2000
set pagesize 2000

SELECT distinct ARCH.THREAD# "Thread", ARCH.SEQUENCE# "Last Sequence Received",
APPL.SEQUENCE# "Last Sequence Applied", (ARCH.SEQUENCE#-APPL.SEQUENCE#) "Difference"
FROM
(SELECT THREAD# ,SEQUENCE# FROM GV$ARCHIVED_LOG
WHERE (THREAD#,FIRST_TIME ) IN (SELECT THREAD#,MAX(FIRST_TIME)
FROM GV$ARCHIVED_LOG
GROUP BY THREAD#
)
) ARCH,
(SELECT THREAD# ,SEQUENCE#
FROM GV$LOG_HISTORY
WHERE (THREAD#,FIRST_TIME)
IN (SELECT THREAD#,MAX(FIRST_TIME) FROM GV$LOG_HISTORY GROUP BY THREAD#)
) APPL
WHERE ARCH.THREAD#=APPL.THREAD# ORDER BY 1;

-- dessincronizar/sincronizar - data guard
alter database recover managed standby database cancel;
alter database recover managed standby database using current logfile disconnect from session;

select username, account_status from dba_users where username = 'SYS';

-- deixar o dg em mounted:
alter database mount standby database; 

-- deixar o DG open:
alter database open read only;

-- verificar o destino archive na primaria para o data guard - standby
set lines 2000
set pages 200
column error format a55 wrap
select inst_id, dest_id,status,error from gv$archive_dest;

show parameter log_archive_dest

alter system set LOG_ARCHIVE_DEST_state_1=enable sid='*';
alter system set LOG_ARCHIVE_DEST_state_9=ENABLE sid='*';

alter system set log_archive_dest_state_1=ENABLE sid='*';

-- verificar os destinos dos archives com status diferente de inativo:
col DEST_NAME for a50
col STATUS for a20
col DESTINATION for a20
col ERROR for a20
select DEST_NAME, STATUS, BINDING, DESTINATION, ERROR from v$archive_dest where STATUS <> 'INACTIVE';

-- query de analise de alertas data guard apply active:
SELECT COUNT(*)
FROM GV$MANAGED_STANDBY
WHERE STATUS = 'APPLYING_LOG';

select STATUS, PROCESS, INST_ID from GV$MANAGED_STANDBY;

select process,status,sequence#,block# from v$managed_standby;

os alertas DATAGUARD_APPLY_ACTIVE são gerados se caso o 'APPLYING_LOG';der menor que 1. 

-- verificar log de erro no DG:
select facility, severity, error_code, timestamp, message from v$dataguard_status; 

-- verificar a configuração dos log_archive_dest
col name for a19
col value for a66
select name, value from v$parameter where name like 'log_archive_dest_%' and value like 
'LOCATION=%' or value like 'SERVICE=%' or value like 'location=%' or value like 'service=%';

-- Procedimento de criação do redotrans:
http://www.nazmulhuda.info/change-sys-password-in-data-guard-environment

Na primaria:

create user redotrans identified by Entubados;

grant sysoper to redotrans;

ALTER SYSTEM SET REDO_TRANSPORT_USER = REDOTRANS scope=both sid = '*';

Esta tratativa deve ser feita na primaria, copiar o arquivo orapw para o 2 nó e para os dois nós do DG. 

Realizar o stop do DG por inteiro, subir uma instancia como nomount e acompanhar no alert a aplicação do RFS/Media recovery

-- comando para saber o valor do redo_transport_user
show parameter redo 

-- Status do sys:
select username, account_status from dba_users where username = 'SYS';

-- Status do REDO:
select username, account_status from dba_users where username like '%REDO%';

-- testar login com usuario redotrans:
sqlplus sys/Entub#d0sh@odscp as sysdba - DG
sqlplus sys/Entub#d0sh@pepbrdg1 as sysdba - PRIMARIA

owner: sys
Senha: "ENtub4d0s#_"

Senha: E#x46C_FaU

-- verificar a permissão do redotrans
set lines 200
select username,sysdba,sysoper,sysasm from v$pwfile_users;

grant create session to redotrans;
grant sysoper,sysdba to redotrans;

-- configurar o log_archive_dest_*
alter system set log_archive_dest_10='SERVICE=aplabp LGWR ASYNC NOAFFIRM DELAY=0 COMPRESSION=ENABLE MAX_CONNECTIONS=2 NET_TIMEOUT=30 REOPEN=30 DB_UNIQUE_NAME=aplabp VALID_FOR=(ONLINE_LOGFILE, PRIMARY_ROLE)' scope = memory sid = '*'; 
alter system set log_archive_dest_10='SERVICE=cxlp LGWR ASYNC NOAFFIRM DELAY=0 
COMPRESSION=ENABLE MAX_CONNECTIONS=2 NET_TIMEOUT=30 REOPEN=30 DB_UNIQUE_NAME=cxlp 
VALID_FOR=(ONLINE_LOGFILE, PRIMARY_ROLE)' scope = memory sid = '*'; 

-- configurar o config no standby:
alter system set log_archive_config = 'DG_CONFIG=(aplabdg1,aplabdg2)' scope = memory sid = '*'; 
alter system set log_archive_config = '' scope = memory sid = '*'; 

col DEST_NAME for a50
col STATUS for a20
col DESTINATION for a20
col ERROR for a20
select DEST_NAME, STATUS, BINDING, DESTINATION, ERROR from v$archive_dest where STATUS <> 'INACTIVE';

set lines 2000
set pages 200
column error format a55 wrap
select inst_id, dest_id,status,error from gv$archive_dest;

alter system set log_archive_config = 'DG_CONFIG=(aplabdg1,aplabdg2)' scope = both sid = '*';
alter system set log_archive_config = 'DG_CONFIG=(aplab08dg1,aplab08dg2)' scope = both sid = '*';
alter system set log_archive_config = 'DG_CONFIG=(aplabdg1,aplabdg2)' scope = both sid = '*';

alter system set log_archive_config = 'DG_CONFIG=(cxlpdg,cxlp)' scope = memory sid = '*';


alter system set log_archive_dest_10='SERVICE=cxlp NOAFFIRM ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=cxlp';
alter system set log_archive_dest_state_10='DEFER';


alter system set log_archive_dest_9 = '' scope = both sid = '*';
alter system set log_archive_dest_10 = '' scope = both sid = '*';
-- saber o caminho dos archives - logar no rman target / 
list archivelog all;

-- setar o log_archive_dest_state para enable
STATUS=DISABLE? 
 
alter system set LOG_ARCHIVE_DEST_9 = ENABLE sid = '*';

-- primary comando pra contemplar na primaria
ALTER SYSTEM SWITCH LOGFILE;

-- Verificar sincronização e atualização de um DataGuard DG
select distinct checkpoint_time from v$datafile_header;

-- validar o status do DG || - BASE:
select name, open_mode, database_role from gv$database;
select host_name, instance_name, status from gv$instance;

select name, open_mode, database_role from v$database;
select host_name, instance_name, status from v$instance;

-- verificar o tempo de aplicação de log:
set linesize 9000
column name format a25
column value format a20
column time_computed format a25
SELECT name, value, time_computed FROM v$dataguard_stats;

-- recovery mode:
SET LINES 180
col DEST_NAME for a30
select DEST_ID,dest_name,status,type,srl,recovery_mode from v$archive_dest_status; where dest_id=1;

-- Analisar o redolog:
set linesize 2000
set pagesize 2000
select group#,thread#,BYTES/1024/1024/1024 ,BLOCKSIZE,MEMBERS, status from v$log;

select group#,status,member from v$logfile;

select GROUP#,THREAD#,BYTES/1024/1024/1024,BLOCKSIZE,STATUS from v$standby_log;

SELECT thread#, group#, sequence#, bytes, archived, status FROM v$standby_log order by thread#, group#;

-- comando para dropar logfile standby:
alter database drop standby logfile group 1;
alter database drop standby logfile group 2;
alter database drop standby logfile group 31;
alter database drop standby logfile group 32;
alter database drop standby logfile group 33;
alter database drop standby logfile group 34;
alter database drop standby logfile group 35;
alter database drop standby logfile group 41;
alter database drop standby logfile group 42;
alter database drop standby logfile group 43;
alter database drop standby logfile group 44;
alter database drop standby logfile group 36;

-- comando para dropar logfile:

alter database clear logfile GROUP 32; 
alter database drop logfile GROUP 24;

-- comando para adicionar logfile standby:

alter database add standby logfile thread 1 GROUP 31 ('+DG_DAT01','+DG_FRA01') size 1G;
alter database add standby logfile thread 1 GROUP 32 ('+DG_DAT01','+DG_FRA01') size 1G;
alter database add standby logfile thread 1 GROUP 33 ('+DG_DAT01','+DG_FRA01') size 1G;
alter database add standby logfile thread 1 GROUP 34 ('+DG_DAT01','+DG_FRA01') size 1G;
alter database add standby logfile thread 1 GROUP 35 ('+DG_DAT01','+DG_FRA01') size 1G;
alter database add standby logfile thread 1 GROUP 36 ('+DG_DAT01','+DG_FRA01') size 1G;

alter database add standby logfile thread 2 GROUP 41 ('+DG_DAT01','+DG_FRA01') size 1G;
alter database add standby logfile thread 2 GROUP 42 ('+DG_DAT01','+DG_FRA01') size 1G;
alter database add standby logfile thread 2 GROUP 43 ('+DG_DAT01','+DG_FRA01') size 1G;
alter database add standby logfile thread 2 GROUP 44 ('+DG_DAT01','+DG_FRA01') size 1G;
alter database add standby logfile thread 2 GROUP 45 ('+DG_DAT01','+DG_FRA01') size 1G;

-- comando para adicionar logfile:
alter database add logfile thread 1 GROUP 11 ('+DG_DAT01','+DG_FRA01') size 1G;
alter database add logfile thread 2 GROUP 21 ('+DG_DAT01','+DG_FRA01') size 1G;
alter database add logfile thread 2 GROUP 22 ('+DG_DAT01','+DG_FRA01') size 1G;

alter database add logfile group 11 ('+DG_DAT01','+DG_FRA01') size 100m;
alter database add logfile group 12 ('+DG_DAT01','+DG_FRA01') size 100m;
alter database add logfile group 13 ('+DG_DAT01','+DG_FRA01') size 100m;
alter database add logfile group 14 ('+DG_DAT01','+DG_FRA01') size 100m;

set lines 200
set pages 100
select l.group#, l.thread#,f.member,l.archived,l.status,(bytes/1024/1024) fsize
from v$log l, v$logfile f where f.group# = l.group# order by 1,2;

Normalizando DG_DAT01 e DG_FRA01alter database add logfile thread 2 group 11 ('+DG_DAT01','+DG_FRA01') size 1g;
alter database add logfile thread 2 group 12 ('+DG_DAT01','+DG_FRA01') size 1g;
alter database add logfile thread 2 group 13 ('+DG_DAT01','+DG_FRA01') size 1g;-- excluido e criadoalter database drop logfile group 2;
alter database add logfile thread 1 group 2 ('+DG_DAT01','+DG_FRA01') size 1g;-- criadoalter database add logfile thread 1 group 3 ('+DG_DAT01','+DG_FRA01') size 1g;
alter database add logfile thread 1 group 4 ('+DG_DAT01','+DG_FRA01') size 1g;
alter database add logfile thread 1 group 4 ('+DG_DAT01','+DG_FRA01') size 1g;

alter database add logfile thread 1 group 101 ('+DG_DAT01','+DG_FRA01') size 1g;
alter database add logfile thread 1 group 102 ('+DG_DAT01','+DG_FRA01') size 1g;
alter database add logfile thread 1 group 103 ('+DG_DAT01','+DG_FRA01') size 1g;
alter database add logfile thread 1 group 104 ('+DG_DAT01','+DG_FRA01') size 1g;
alter database add logfile thread 1 group 105 ('+DG_DAT01','+DG_FRA01') size 1g;

só pode excluir (drop logfile), quando tiver INATIVO

alter database disable thread 3;
alter database drop logfile group 1;
alter database drop logfile group 4; alter database drop logfile group 5;
alter database drop logfile group 11;alter database drop logfile group 12;

-- comando para manutenção dos redo no standby:
alter system set standby_file_management = AUTO sid ='*';

-- erro de datafile com file ID diferente:
Errors in file /u02/app/oracle/diag/rdbms/pepbcfdg/pepbcf1/trace/pepbcf1_pr00_191194.trc:
ORA-01111: name for data file 26 is unknown - rename to correct file
ORA-01110: data file 26: '/u02/app/oracle/product/19.0.0.0/dbhome_2/dbs/UNNAMED00026'
ORA-01157: cannot identify/lock data file 26 - see DBWR trace file
ORA-01111: name for data file 26 is unknown - rename to correct file
ORA-01110: data file 26: '/u02/app/oracle/product/19.0.0.0/dbhome_2/dbs/UNNAMED00026'
PR00 (PID:191194): Managed Standby Recovery not using Real Time Apply
Stopping change tracking
2022-03-15T10:35:26.255495-03:00
Recovery Slave PR00 previously exited with exception 1111

logado na primaria, solta o comando pra saber o nome 

Alter database create datafile '/u02/app/oracle/product/19.0.0.0/dbhome_2/dbs/UNNAMED00026' as '+DATAC1/';

Alter database create datafile '/u02/app/oracle/product/19.0.0.0/dbhome_2/dbs/UNNAMED00122' as new; 


select FILE_NAME, FILE_ID, STATUS from dba_data_files where FILE_ID = 118;

https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=3585329985659&id=1416554.1&_afrWindowMode=0&_adf.ctrl-state=mikbhk3ph_53

-- verificar o parametro process do banco - Quantidade de processos maior que 90 por cento permitido

show parameter process
select count (*) from v$process;

col RESOURCE_NAME for a30
SELECT RESOURCE_NAME, CURRENT_UTILIZATION, MAX_UTILIZATION, LIMIT_VALUE
FROM V$RESOURCE_LIMIT WHERE RESOURCE_NAME IN ( 'sessions', 'processes');

show parameter process
show parameter sessions

select count(username) as QTDE, 'TOTAL' as CONEXOES
from gv$session where username is not null
UNION
select count(username), 'ATIVOS'
from gv$session where username is not null and status = 'ACTIVE'
UNION
select count(username), 'INATIVOS'
from gv$session where username is not null and status = 'INACTIVE'
UNION
select count(username), 'PERDIDOS'
from gv$session where username is not null and status = 'SNIPED'
order by 1, 2;

-- verifcar sessão inativa:
select username , machine,status, count(*)
from gv$session where username is not null group by username , machine,status order by 4 desc;

-- balanceador:

select count(*), inst_id from gv$session group by inst_id;

 -- matar sessão com - LOCAL=NO no filtro com ps -ef | grep LOCAL=NO mudar o campo "oraclez5mgh" 

ps -ef|grep oraclez5mgh | grep LOCAL=NO |grep -v grep|awk '{print $2}' |xargs -i kill -9 {}
 
 
-- Analisar resize tablespace:

exec dbms_session.set_identifier('8878174');

set linesize 1000 pagesize 0 feedback off trimspool on
with
hwm as (
-- get highest block id from each datafiles ( from x$ktfbue as we don't need all joins from dba_extents )
select /*+ materialize */ ktfbuesegtsn ts#,ktfbuefno relative_fno,max(ktfbuebno+ktfbueblks-1) hwm_blocks
from sys.x$ktfbue group by ktfbuefno,ktfbuesegtsn
),
hwmts as (
-- join ts# with tablespace_name
select name tablespace_name,relative_fno,hwm_blocks
from hwm join v$tablespace using(ts#)
),
hwmdf as (
-- join with datafiles, put 5M minimum for datafiles with no extents
select file_name,nvl(hwm_blocks*(bytes/blocks),5*1024*1024) hwm_bytes,bytes,autoextensible,maxbytes
from hwmts right join dba_data_files using(tablespace_name,relative_fno)
)
select
case when autoextensible='YES' and maxbytes>=bytes
then -- we generate resize statements only if autoextensible can grow back to current size
'/* reclaim '||to_char(ceil((bytes-hwm_bytes)/1024/1024),999999)
||'M from '||to_char(ceil(bytes/1024/1024),999999)||'M */ '
||'alter database datafile '''||file_name||''' resize '||ceil(hwm_bytes/1024/1024)||'M;'
else -- generate only a comment when autoextensible is off
'/* reclaim '||to_char(ceil((bytes-hwm_bytes)/1024/1024),999999)
||'M from '||to_char(ceil(bytes/1024/1024),999999)
||'M after setting autoextensible maxsize higher than current size for file '
|| file_name||' */'
end SQL
from hwmdf
where
bytes-hwm_bytes>1024*1024 -- resize only if at least 1MB can be reclaimed
order by bytes-hwm_bytes desc
/

======================================================================================================

set lines 200
select 'alter database datafile ''' || file_name || ''' resize ' ||
ceil( (nvl(hwm,1)*(select value from v$parameter where name = 'db_block_size'))/1024/1024 ) || 'm; '
|| '-- Actual: ' || bytes/1024/1024 || 'm; '
cmd
from dba_data_files a,
( select file_id, max(block_id+blocks-1) hwm
from dba_extents
group by file_id ) b
where a.file_id = b.file_id(+)
and ceil( blocks*(select value from v$parameter where name = 'db_block_size')/1024/1024) -
ceil( (nvl(hwm,1)*(select value from v$parameter where name = 'db_block_size'))/1024/1024 ) > 0
--and a.tablespace_name like 'SYSAUX%'
and (bytes/1024/1024 ) - ceil( (nvl(hwm,1)*(select value from v$parameter where name = 'db_block_size'))/1024/1024 ) > 1024
order by 1
/

-- Catalog dell RMAN BKP dell:
export TNS_ADMIN=/u01/app/oracle/admin/rman/tns

rman target / catalog rman_ab/Aslaj1i#001@RMAN.PETROBRAS.COM.BR
rman target / catalog rman_ab_bkp/Aslaj1i#001@RMAN_BKP.PETROBRAS.COM.BR

-- Catalog de RMAN BKP NETBKP:
rman target / catalog rman/qwerasdf#357@rman.PETROBRAS.COM.BR

-- comando para listar o BKP citando a sequence e thread
list backup of archivelog logseq=265119 thread =1;

-- Restore archive

T-1.S-418765 to T-1.S-418864

-- Realizar restore no catalog da dell
export TNS_ADMIN=/u01/app/oracle/admin/rman/tns
rman target / catalog rman_ab/Aslaj1i#001@rman.PETROBRAS.COM.BR

run {
allocate channel c1 device type sbt;
allocate channel c2 device type sbt;
allocate channel c3 device type sbt;
send 'NSR_ENV=(NSR_SERVER=srjcipdnw102n01.petrobras.biz, NSR_CLIENT = sanddb01-bkp.petrobras.com.br)';
RESTORE ARCHIVELOG FROM LOGSEQ=723828 UNTIL LOGSEQ=418864 THREAD 1;
}

run {
allocate channel c1 device type sbt;
allocate channel c2 device type sbt;
allocate channel c3 device type sbt;
send 'NSR_ENV=(NSR_SERVER=srjcipdnw102n01.petrobras.biz, NSR_CLIENT=sanddb01-bkp.petrobras.com.br)';
restore archivelog logseq=723828 thread 2;
}

run {
allocate channel c1 device type sbt;
allocate channel c2 device type sbt;
allocate channel c3 device type sbt;
send 'NSR_ENV=(NSR_SERVER=srjcipdnw102n01.petrobras.biz, NSR_CLIENT = S6006AS3795-bkp.petrobras.biz)';
RESTORE RESTORE ARCHIVELOG LOGSEQ=634013 THREAD 2;
}

-- restore de archive no netbkp - logar com o catalogo do netbkp

run{
allocate channel arch_sbt01 type SBT_TAPE;
allocate channel arch_sbt02 type SBT_TAPE;
allocate channel arch_sbt03 type SBT_TAPE;
send 'NB_ORA_CLIENT=rhaegal-bkp.petrobras.com.br, NB_ORA_SERV=liceu.petrobras.com.br, NB_ORA_POLICY=DB_ORA_RMAN_RCPRIMAP_ON';
restore ARCHIVELOG FROM TIME "to_date('02/22/22 04:48:33','MM/DD/YY HH24:MI:SS')" UNTIL TIME "to_date('02/22/22 06:00:00','MM/DD/YY HH24:MI:SS')";
}


RUN {
allocate channel arch_sbt01 type SBT_TAPE;
allocate channel arch_sbt02 type SBT_TAPE;
SEND 'NB_ORA_POLICY=DB_ORA_RMAN_SRJCIPDEXA1CL1_CWN102P_ARCH, NB_ORA_SERV=srjcipdnbu406.petrobras.biz, NB_ORA_CLIENT=srjcipdexa1cl1db02.petrobras.biz';
RESTORE ARCHIVELOG FROM LOGSEQ=5085 UNTIL LOGSEQ=5087 THREAD 1;
}

RUN {
allocate channel arch_sbt01 type SBT_TAPE;
allocate channel arch_sbt02 type SBT_TAPE;
SEND 'NB_ORA_POLICY=DB_ORA_RMAN_SRJCIPDEXA1CL1_CWN102P_ARCH, NB_ORA_SERV=srjcipdnbu406.petrobras.biz, NB_ORA_CLIENT=srjcipdexa1cl1db02.petrobras.biz';
RESTORE ARCHIVELOG FROM LOGSEQ=4741 THREAD 2;
}

run
{
allocate channel arch_sbt0 type 'SBT_TAPE' PARMS 'SBT_LIBRARY=/usr/openv/netbackup/bin/libobk.so64';
allocate channel arch_sbt1 type 'SBT_TAPE' PARMS 'SBT_LIBRARY=/usr/openv/netbackup/bin/libobk.so64';
send 'NB_ORA_SERV=srjcipdnbu406.petrobras.biz, NB_ORA_CLIENT=srjcipdexa1cl1db02.petrobras.biz, NB_ORA_POLICY=DB_ORA_RMAN_SRJCIPDEXA1CL1_CWN301P_ARCH';
restore archivelogsequence 4741 thread 2;
}


T-2.S-4741

RUN {
ALLOCATE CHANNEL SBT01 TYPE 'sbt_tape';
ALLOCATE CHANNEL SBT02 TYPE 'sbt_tape';
ALLOCATE CHANNEL SBT03 TYPE 'sbt_tape';
ALLOCATE CHANNEL SBT04 TYPE 'sbt_tape';
SEND 'NB_ORA_POLICY=DB_ORA_RMAN_SISTP_ARCH, NB_ORA_SERV=zelia.petrobras.com.br, NB_ORA_CLIENT=felizardo.ep.petrobras.com.br';
RESTORE ARCHIVELOG FROM logseq=137260 thread=3;
}

-- restore de archive no dbbboost - logar com o catalogo do dbbboost

run{
allocate channel arch_sbt_dd01 type 'sbt_tape' PARMS 'BLKSIZE=1048576,SBT_LIBRARY=/u01/app/oracle/product/11.2.0/db_1/lib/libddobk.so,ENV=(STORAGE_UNIT=ORACLE_TIC_ES, BACKUP_HOST=cipd_dd990_6.petrobras.com.br)';
allocate channel arch_sbt_dd02 type 'sbt_tape' PARMS 'BLKSIZE=1048576,SBT_LIBRARY=/u01/app/oracle/product/11.2.0/db_1/lib/libddobk.so,ENV=(STORAGE_UNIT=ORACLE_TIC_ES, BACKUP_HOST=cipd_dd990_6.petrobras.com.br)';
allocate channel arch_sbt_dd03 type 'sbt_tape' PARMS 'BLKSIZE=1048576,SBT_LIBRARY=/u01/app/oracle/product/11.2.0/db_1/lib/libddobk.so,ENV=(STORAGE_UNIT=ORACLE_TIC_ES, BACKUP_HOST=cipd_dd990_6.petrobras.com.br)';
allocate channel arch_sbt_dd04 type 'sbt_tape' PARMS 'BLKSIZE=1048576,SBT_LIBRARY=/u01/app/oracle/product/11.2.0/db_1/lib/libddobk.so,ENV=(STORAGE_UNIT=ORACLE_TIC_ES, BACKUP_HOST=cipd_dd990_6.petrobras.com.br)';
restore ARCHIVELOG FROM TIME "to_date('02/22/22 04:48:33','MM/DD/YY HH24:MI:SS')" UNTIL TIME "to_date('02/22/22 06:00:00','MM/DD/YY HH24:MI:SS')";
}

RUN {
allocate channel arch_sbt_dd01 type 'sbt_tape' PARMS 'BLKSIZE=1048576,SBT_LIBRARY=/u01/app/oracle/product/11.2.0/db_1/lib/libddobk.so,ENV=(STORAGE_UNIT=ORACLE_TIC_NE,BACKUP_HOST=cipd_dd990_5.petrobras.com.br)';
allocate channel arch_sbt_dd02 type 'sbt_tape' PARMS 'BLKSIZE=1048576,SBT_LIBRARY=/u01/app/oracle/product/11.2.0/db_1/lib/libddobk.so,ENV=(STORAGE_UNIT=ORACLE_TIC_NE,BACKUP_HOST=cipd_dd990_5.petrobras.com.br)';
RESTORE ARCHIVELOG FROM LOGSEQ=193542 UNTIL LOGSEQ=193568 THREAD 1;
}

SEND 'NB_ORA_POLICY=DB_ORA_RMAN_RCPRIMAP_ARCH1, NB_ORA_SERV=liceu.petrobras.com.br, NB_ORA_CLIENT=rhaegal.petrobras.com.br';
allocate channel arch_sbt_dd01 type 'sbt_tape' PARMS 'BLKSIZE=1048576,SBT_LIBRARY=${DD_LIBRARY},ENV=(STORAGE_UNIT=${DD_STORAGE_UNIT},BACKUP_HOST=${DD_SYSTEM})';

run {
ALLOCATE CHANNEL arch_sbt_dd01 TYPE 'sbt_tape' PARMS 'BLKSIZE=1048576,SBT_LIBRARY=/u01/app/oracle/product/11.2.0/db_1/lib/libddobk.so,ENV=(STORAGE_UNIT=ORACLE_TIC_ES,BACKUP_HOST=cipd_dd990_6.petrobras.com.br)';
restore archivelog from logseq=955472 thread 2 ; 
restore archivelog from logseq=986294 thread 1 ; 
}

-- comando para listar o bkp:
list  of archivelog logseq 955472 thread 2;

-- comando para fazer o BKP:
run {
allocate channel dsk1 device type disk;
backup archivelog from logse 955472thread 2 format '/oracle/bkp_nfs/michael_bkp/michael.rman1';
backup archivelog from logse 986294thread 1 format '/oracle/bkp_nfs/michael_bkp/michael.rman2';
}


-- destino:
catalog start with '/tmp/michael.rman';
 
restore archivelog from sequence 955472 thread 2;

RUN
{
ALLOCATE CHANNEL ch12 TYPE DISK;
ALLOCATE CHANNEL ch13 TYPE DISK;
ALLOCATE CHANNEL ch14 TYPE DISK;
ALLOCATE CHANNEL ch15 TYPE DISK;
BACKUP FORMAT '/ora_operacao2/CXLP/CXLP_BANCO/%d_D_%T_%u_s%s_p%p'
DATABASE CURRENT CONTROLFILE FORMAT '/ora_operacao2/CXLP/CXLP_BANCO/%d_C_%T_%u'
SPFILE FORMAT '/ora_operacao2/CXLP/CXLP_BANCO/%d_S_%T_%u'
PLUS ARCHIVELOG FORMAT '/ora_operacao2/CXLP/CXLP_BANCO/%d_A_%T_%u_s%s_p%p';
RELEASE CHANNEL ch12;
RELEASE CHANNEL ch13;
RELEASE CHANNEL ch14;
RELEASE CHANNEL ch15;
}

list backup of archivelog logseq 955472 thread 2;
RESTORE ARCHIVELOG FROM logseq=2216058 until logseq thread=2;

-- comando para soltar um bkp archive do networker dell logado no catalogo:
rman target / catalog rman_ab/Aslaj1i#001@rman.PETROBRAS.COM.BR

run {
ALLOCATE CHANNEL SB01 TYPE 'sbt_tape';
ALLOCATE CHANNEL SB03 TYPE 'sbt_tape';
ALLOCATE CHANNEL SB04 TYPE 'sbt_tape';
send 'NSR_ENV=(NSR_SERVER=srjcipdnw102n01.petrobras.biz, NSR_CLIENT=golddb03-con.petrobras.com.br)';
backup archivelog all format '%d_arch_%U_%t' delete input;
}

RUN {
ALLOCATE CHANNEL CH1_ARC TYPE 'SBT_TAPE';
ALLOCATE CHANNEL CH2_ARC TYPE 'SBT_TAPE';
ALLOCATE CHANNEL CH3_ARC TYPE 'SBT_TAPE';
ALLOCATE CHANNEL CH4_ARC TYPE 'SBT_TAPE';
BACKUP DURATION 12:00 MINIMIZE TIME CHECK LOGICAL ARCHIVELOG ALL MAXSETSIZE 16G FILESPERSET 20 SKIP INACCESSIBLE FORMAT '%d_arch_%U_%t' TAG 'lgto-arch'
DELETE INPUT;
BACKUP DURATION 01:00 MINIMIZE TIME CHECK LOGICAL CURRENT CONTROLFILE FORMAT '%d_controlfile_pos_full_%U_%t' TAG 'lgto-pos-arch-cf';
}

-- comando para soltar um bkp FULL do networker dell logado no catalogo:
rman target / catalog rman_ab/Aslaj1i#001@rman.PETROBRAS.COM.BR
RUN {
ALLOCATE CHANNEL CH6_FULL TYPE 'SBT_TAPE';
ALLOCATE CHANNEL CH5_FULL TYPE 'SBT_TAPE';
ALLOCATE CHANNEL CH7_FULL TYPE 'SBT_TAPE';
ALLOCATE CHANNEL CH8_FULL TYPE 'SBT_TAPE';
BACKUP DURATION 24:00 MINIMIZE TIME CHECK LOGICAL SECTION SIZE 32G FULL FILESPERSET 4 
FORMAT '%d_datafile_full_%U_%t' TAG 'lgto-full-database' DATABASE FORCE; 
BACKUP DURATION 01:00 MINIMIZE TIME CHECK LOGICAL CURRENT CONTROLFILE FORMAT '%d_controlfile_pos_full_%U_%t' TAG 'lgto-pos-full-cf';
}

-- avaliar archives no rman:
crosscheck archivelog all;

-- Ressincronizar RMAN com banco:
Resync catalog;

-- Deletar archives failed expirados com status failed
delete expired archivelog all;

-- configurar politica deleção DG/Primaria
CONFIGURE ARCHIVELOG DELETION POLICY TO APPLIED ON ALL STANDBY;

-- Caminho dos logs do bkp da DELL
/nsr/apps/logs

-- destino dos archives
archive log list

resync catalog;

RUN
{
SET DBID 1312293510;
UNREGISTER DATABASE spotfrp NOPROMPT;
}

LIST INCARNATION OF DATABASE spotfrp;

-- - Conexões no banco:

select username, machine, status, count (*) from gv$session where username is not null group by username, machine, status;

-- verificar o tamanho do bkp finalizado.

col gname form a10
col dbname form a10
col file_type form a14

SELECT
gname,
dbname,
file_type,
round(SUM(space)/1024/1024) mb,
round(SUM(space)/1024/1024/1024) gb,
COUNT(*) "#FILES"
FROM
(
SELECT
gname,
regexp_substr(full_alias_path, '[[:alnum:]_]*',1,4) dbname,
file_type,
space,
aname,
system_created,
alias_directory
FROM
(
SELECT
concat('+'||gname, sys_connect_by_path(aname, '/')) full_alias_path,
system_created,
alias_directory,
file_type,
space,
level,
gname,
aname
FROM
(
SELECT
b.namegname,
a.parent_indexpindex,
a.nameaname,
a.reference_index rindex ,
a.system_created,
a.alias_directory,
c.type file_type,
c.space
FROM
v$asm_alias a,
v$asm_diskgroup b,
v$asm_file c
WHERE
a.group_number = b.group_number
AND a.group_number = c.group_number(+)
AND a.file_number = c.file_number(+)
AND a.file_incarnation = c.incarnation(+) ) START WITH (mod(pindex, power(2, 24))) = 0
AND rindex IN
(
SELECT
a.reference_index
FROM
v$asm_alias a,
v$asm_diskgroup b
WHERE
a.group_number = b.group_number
AND (
mod(a.parent_index, power(2, 24))) = 0
and a.name ='APLABP02DG1'
) CONNECT BY prior rindex = pindex )
WHERE
NOT file_type IS NULL
and system_created = 'Y' )
WHERE
dbname ='APLABP02DG1'
GROUP BY
gname,
dbname,
file_type
ORDER BY
gname,
dbname,
file_type
/

-- destino Criar alternate dos archives:

set lines 2000
set pages 200
column error format a55 wrap
select inst_id, dest_id,status,error from gv$archive_dest;

col DEST_NAME for a50
col STATUS for a20
col DESTINATION for a20
col ERROR for a20
select DEST_NAME, STATUS, BINDING, DESTINATION, ERROR from v$archive_dest where STATUS <> 'INACTIVE';

show parameter log_archive_dest_2
show parameter log_archive_dest_state_2

DG_FRA01_EPPRD02

alter system set log_archive_dest_1='LOCATION=+DG_FRA01 MANDATORY MAX_FAILURE=1 ALTERNATE=LOG_ARCHIVE_DEST_2' scope=memory;
alter system set log_archive_dest_2 ='LOCATION=/u01/app/oracle/admin/arch_alternate/ccq' scope=memory;
alter system set log_archive_dest_state_1=ENABLE scope=memory;
alter system set log_archive_dest_state_2=ALTERNATE scope=memory;


alter system set log_archive_dest_1='LOCATION='' MANDATORY MAX_FAILURE=1 ALTERNATE=log_archive_dest_2' scope=spfile sid='*';

srjcipdexa1cl1db02.petrobras.biz
		

alter system set log_archive_dest_1 ='LOCATION=/u01/app/oracle/admin/arch_alternate/ODSCP MANDATORY MAX_FAILURE=1' scope=both sid='*';

alter system set log_archive_dest_state_2=ENABLE sid='*';

alter system set log_archive_dest_state_2=ALTERNATE scope=both sid='*';

alter system set log_archive_dest_1='LOCATION=/oracle_bkp3/cipd/reccbr/reccbr_2' scope=memory sid='*';

alter system set log_archive_dest_state_1=DISABLE scope=memory sid='*';

alter system set log_archive_dest_2 ='LOCATION=/ora_operacao2/CXLP' scope=memory;

alter system set log_archive_dest_state_2=ALTERNATE scope=memory sid='*';

alter system set log_archive_dest_1='LOCATION=+DG_FRA01 MANDATORY MAX_FAILURE=1 ALTERNATE=LOG_ARCHIVE_DEST_2' scope=memory sid='*';
alter system set log_archive_dest_state_1=ENABLE scope=memory sid='*';

alter system set log_archive_dest_2='LOCATION=/oracle_bkp3/cipd/arch_alternate_peps/pepbsol' scope=memory sid='*';
alter system set log_archive_dest_state_2=ALTERNATE scope=memory sid='*';

alter system set log_archive_dest_1='LOCATION=+DG_FRA01 MANDATORY MAX_FAILURE=1 ALTERNATE=LOG_ARCHIVE_DEST_3' scope=memory sid='*';
alter system set log_archive_dest_3='LOCATION=/oracle_bkp3/cipd/arch_alternate_peps/peprnce MANDATORY' scope=memory sid='*';
alter system set log_archive_dest_state_3=ALTERNATE scope=both sid='*';

select DEST_NAME, RECOVERY_MODE from GV$ARCHIVE_DEST_STATUS where RECOVERY_MODE <> 'MANAGED REAL TIME APPLY' and DEST_NAME = 'LOG_ARCHIVE_DEST_10';

-- base com spfile
alter system set log_archive_dest_1='LOCATION=+DG_FRA01 MANDATORY MAX_FAILURE=1 ALTERNATE=LOG_ARCHIVE_DEST_2' scope=memory sid='*';
alter system set log_archive_dest_state_1=ENABLE scope=memory; 

alter system set log_archive_dest_2='LOCATION=/oracle_bkp3/cipd/recbr' scope=memory; 
alter system set log_archive_dest_state_2=ALTERNATE scope=memory sid='*';

-- deletar arquives - (APENAS EMERGENCIAL)rodar esse script no banco, ele vai gerar linhas de comando para rodar no rman:
select 'delete noprompt archivelog until sequence '||max(a.sequence#)||' thread '||thread#||';'
from gv$archived_log a, v$database b
where a.applied='YES'
and b.RESETLOGS_CHANGE#=a.RESETLOGS_CHANGE#
group by thread#;

-- Comando pra saber o nome da base:
select name from v$database;

-- Comando pra saber o nome da instancia:
select instance_name from v$instance;

-- comando pra saber o nome do db_unique_name
show parameter unique

-- voltar o link simbolico do netbkp
cd $ORACLE_HOME/lib
unlink $ORACLE_HOME/lib/libobk.so64
unlink $ORACLE_HOME/lib/libobk.so
unlink $ORACLE_HOME/lib/libobk.so.back
unlink $ORACLE_HOME/lib/libobk.so_bkp
ln -s /usr/openv/netbackup/bin/libobk.so64
ls -ltra | grep libobk.so

-- voltar o link do DBBOOST - npaa2431
cd $ORACLE_HOME/lib
unlink $ORACLE_HOME/lib/libddobk.so
ln -s /usr/lib/cd $ORACLE_HOME/lib/libddobk.so
ln -s$ORACLE_HOME/lib/libddobk.so
ls -ltra | grep libddobk.so

-- voltar o link do BKP - DELL
cd $ORACLE_HOME/lib 
unlink $ORACLE_HOME/lib/libobk.so
ln -s /usr/lib/libnsrora.so $ORACLE_HOME/lib/libobk.so
ls -ltra | grep libnsrora.so

-- mesa de BKP | NETBACKUP
N4-BACKUP_VERITAS

-- mesa de BKP | DELL
N4-STORAGE_BACKUP_DELL-EMC

-- mesa de BKP | AVAMAR
N3-STORAGE_BACKUP 

-- Agent do dbboost
manabu - /BKP_NAS_TICNE_CIPD/MIDIAS_ORACLE/ddboost

-- comando para mudar o owner de um archivo:
 chown -R grid:oinstall ddboost.*

-- Habilitar archive no banco:
archive log list
select log_mode from v$database;
shutdown immediate;
startup mount;
alter database archivelog;
alter database open;
archive log list

-- comando para fazer um scp absorvendo o arquivo de origem para destino. Tem de estar logado onde quer que o arquivo fique/seja copiado
scp -rp asd2hr@onyxdb01:/u01/app/oracle/admin/exadsv01/scripts/backup/scrRootRmanTapeFullOnline.sh .

-- SCP logado no destino
scp -rp ewallet.p12 asd2hr@s602das547:/u01/app/oracle/admin/peprsvdg1/wallet

scp -rp ewallet.p12.lck asd2hr@lavadb03:/u01/app/oracle/product/19/db_1/admin/ccp/wallet

-- comando para saber o config scan:
srvctl config scan

-- comando para saber o listener scan:
srvctl status scan_listener

-- comando para realocar o listener scan. Aqui esta sendo setado o scan_1 na maquina geriba
srvctl relocate scan_listener -i 1 -n srjcipdexa1cl1db08
srvctl relocate scan_listener -i 2 -n srjcipdexa2cl3db04
srvctl relocate scan_listener -i 3 -n srjcipdexa2cl3db02

-- limpeza do alvo no scan_listener:
./emctl config agent listtargets
./emctl clearstate agent [LISTENER_SCAN3_bdiep3, oracle_listener]

-- Select para saber se o parametro é static or dinamico. No campo name, colocar o nome do parametro.
set lines 200
col name for a35
col value for a25

Select name,VALUE,ISDEFAULT,ISSES_MODIFIABLE,ISSYS_MODIFIABLE from gv$parameter where name='audit_file_dest';

-- Usuarios sem auditoria habilitada
select u.username, u.profile from dba_users u where u.profile like '%SOX%';

select sjd.STATUS, to_char(max(log_date), 'dd/mm/yyyy hh24:mi') max_log_date 
from dba_scheduler_job_run_details sjd
where sjd.OWNER='ORASTATUS' and sjd.job_name='JOB_AUDITA_GRUPOS_AD'
group by sjd.STATUS;

select j.owner job_owner, j.job_name, j.program_owner pg_owner, j.program_name pg_name,
 j.schedule_owner sc_owner, j.schedule_name sc_name, j.enabled job_enabled, s.repeat_interval, j.state,
 to_char(j.last_start_date, 'dd/mm/yyyy hh24:mi') job_last_start,
 to_char(j.next_run_date, 'dd/mm/yyyy hh24:mi') job_next_start, p.program_action pg_action
from dba_scheduler_programs p
inner join dba_scheduler_jobs j on p.owner=j.program_owner and p.program_name=j.program_name
inner join dba_scheduler_schedules s on j.schedule_owner=s.owner and j.schedule_name=s.schedule_name
where j.owner='ORASTATUS' and j.job_name='JOB_AUDITA_GRUPOS_AD';

SELECT COMANDO 
FROM (( -- usuarios privilegiados
SELECT DISTINCT G.SQLAUDIT || F.USERNAME || ' BY ACCESS WHENEVER SUCCESSFUL' COMANDO
FROM (SELECT GRANTED_ROLE, SYS_CONNECT_BY_PATH(GRANTED_ROLE, '/') PATH, CONNECT_BY_ROOT GRANTED_ROLE USERNAME
FROM (SELECT NULL GRANTEE, USERNAME GRANTED_ROLE FROM DBA_USERS
UNION ALL
SELECT GRANTEE, GRANTED_ROLE FROM DBA_ROLE_PRIVS)
START WITH GRANTEE IS NULL CONNECT BY GRANTEE = PRIOR GRANTED_ROLE) D
INNER JOIN (SELECT A.GRANTEE FROM DBA_TAB_PRIVS A
INNER JOIN DBA_USERS B ON A.OWNER = B.USERNAME
WHERE A.PRIVILEGE IN ('INSERT', 'UPDATE', 'DELETE', 'EXECUTE')
AND B.PROFILE = 'PFL_ADM_APPLICATION_SOX'
UNION
SELECT C.GRANTEE FROM DBA_SYS_PRIVS C
WHERE C.PRIVILEGE IN ('ALTER ANY MATERIALIZED VIEW', 'ALTER ANY PROCEDURE',
'ALTER ANY SEQUENCE', 'ALTER ANY TABLE',
'ALTER ANY TRIGGER', 'CREATE ANY MATERIALIZED VIEW',
'CREATE ANY PROCEDURE', 'CREATE ANY SEQUENCE',
'CREATE ANY TABLE', 'CREATE ANY TRIGGER',
'CREATE ANY VIEW', 'DELETE ANY TABLE',
'DROP ANY MATERIALIZED VIEW', 'DROP ANY PROCEDURE',
'DROP ANY SEQUENCE', 'DROP ANY TABLE',
'DROP ANY TRIGGER', 'DROP ANY VIEW', 'INSERT ANY TABLE',
'UPDATE ANY TABLE', 'EXECUTE ANY PROCEDURE')) E ON D.GRANTED_ROLE = E.GRANTEE
INNER JOIN DBA_USERS F ON D.USERNAME = F.USERNAME
INNER JOIN (SELECT 'AUDIT USER BY ' SQLAUDIT FROM DUAL UNION ALL
SELECT 'AUDIT SYSTEM GRANT BY 'FROM DUAL UNION ALL
SELECT 'AUDIT GRANT TABLE BY ' FROM DUAL UNION ALL
SELECT 'AUDIT INSERT TABLE BY 'FROM DUAL UNION ALL
SELECT 'AUDIT UPDATE TABLE BY 'FROM DUAL UNION ALL
SELECT 'AUDIT DELETE TABLE BY 'FROM DUAL UNION ALL
SELECT 'AUDIT TABLE BY ' FROM DUAL UNION ALL
SELECT 'AUDIT ALTER TABLE BY ' FROM DUAL) G ON 1 = 1
WHERE F.PROFILE NOT LIKE 'PFL_ADM_APPLICATION%'
AND F.USERNAME NOT IN ('SYS','ORAJOB')
)
MINUS ( SELECT 'AUDIT ' || AUDIT_OPTION || ' BY ' || USER_NAME || ' ' || SUCCESS || ' WHENEVER SUCCESSFUL' COMANDO
FROM DBA_STMT_AUDIT_OPTS 
WHERE USER_NAME IS NOT NULL
AND USER_NAME <> 'ANY CLIENT')
UNION ALL
( -- proxy users
SELECT DISTINCT G.SQLAUDIT || F.USERNAME || ' ON BEHALF OF ANY BY ACCESS WHENEVER SUCCESSFUL' COMANDO
FROM (SELECT GRANTED_ROLE, SYS_CONNECT_BY_PATH(GRANTED_ROLE, '/') PATH, CONNECT_BY_ROOT GRANTED_ROLE USERNAME
FROM (SELECT NULL GRANTEE, USERNAME GRANTED_ROLE FROM DBA_USERS
UNION ALL
SELECT GRANTEE, GRANTED_ROLE FROM DBA_ROLE_PRIVS)
START WITH GRANTEE IS NULL CONNECT BY GRANTEE = PRIOR GRANTED_ROLE) D
INNER JOIN (SELECT A.GRANTEE FROM DBA_TAB_PRIVS A
INNER JOIN DBA_USERS B ON A.OWNER = B.USERNAME
WHERE A.PRIVILEGE IN ('INSERT', 'UPDATE', 'DELETE', 'EXECUTE')
AND B.PROFILE = 'PFL_ADM_APPLICATION_SOX'
UNION
SELECT C.GRANTEE FROM DBA_SYS_PRIVS C
WHERE C.PRIVILEGE IN ('ALTER ANY MATERIALIZED VIEW', 'ALTER ANY PROCEDURE',
'ALTER ANY SEQUENCE', 'ALTER ANY TABLE',
'ALTER ANY TRIGGER', 'CREATE ANY MATERIALIZED VIEW',
'CREATE ANY PROCEDURE', 'CREATE ANY SEQUENCE',
'CREATE ANY TABLE', 'CREATE ANY TRIGGER',
'CREATE ANY VIEW', 'DELETE ANY TABLE',
'DROP ANY MATERIALIZED VIEW', 'DROP ANY PROCEDURE',
'DROP ANY SEQUENCE', 'DROP ANY TABLE',
'DROP ANY TRIGGER', 'DROP ANY VIEW', 'INSERT ANY TABLE',
'UPDATE ANY TABLE', 'EXECUTE ANY PROCEDURE')) E ON D.GRANTED_ROLE = E.GRANTEE
INNER JOIN DBA_USERS F ON D.USERNAME = F.USERNAME
INNER JOIN (SELECT 'AUDIT USER BY ' SQLAUDIT FROM DUAL UNION ALL
SELECT 'AUDIT SYSTEM GRANT BY 'FROM DUAL UNION ALL
SELECT 'AUDIT GRANT TABLE BY ' FROM DUAL UNION ALL
SELECT 'AUDIT INSERT TABLE BY 'FROM DUAL UNION ALL
SELECT 'AUDIT UPDATE TABLE BY 'FROM DUAL UNION ALL
SELECT 'AUDIT DELETE TABLE BY 'FROM DUAL UNION ALL
SELECT 'AUDIT TABLE BY ' FROM DUAL UNION ALL
SELECT 'AUDIT ALTER TABLE BY ' FROM DUAL) G ON 1 = 1
WHERE F.PROFILE NOT LIKE 'PFL_ADM_APPLICATION%'
AND F.USERNAME NOT IN ('SYS','ORAJOB'))
MINUS ( SELECT 'AUDIT ' || AUDIT_OPTION || ' BY ' || DECODE(USER_NAME, 'ANY CLIENT',PROXY_NAME,USER_NAME) 
 || DECODE(USER_NAME, 'ANY CLIENT',' ON BEHALF OF ANY ',' ') || SUCCESS || ' WHENEVER SUCCESSFUL' COMANDO
FROM DBA_STMT_AUDIT_OPTS 
WHERE USER_NAME = 'ANY CLIENT')
 )
UNION ALL
SELECT 'AUDIT SESSION WHENEVER NOT SUCCESSFUL'
FROM DUAL
WHERE NOT EXISTS (SELECT 1 FROM ( SELECT 'AUDIT ' || AUDIT_OPTION COMANDO
FROM DBA_STMT_AUDIT_OPTS
WHERE USER_NAME IS NULL)
WHERE COMANDO = 'AUDIT CREATE SESSION')
UNION ALL
SELECT 'AUDIT SYSTEM AUDIT BY ACCESS WHENEVER SUCCESSFUL'
FROM DUAL
WHERE NOT EXISTS (SELECT 1 FROM ( SELECT 'AUDIT ' || AUDIT_OPTION COMANDO
FROM DBA_STMT_AUDIT_OPTS
WHERE USER_NAME IS NULL)
WHERE COMANDO = 'AUDIT SYSTEM AUDIT')
UNION ALL
SELECT 'AUDIT AUDIT ANY BY ACCESS WHENEVER SUCCESSFUL'
FROM DUAL
WHERE NOT EXISTS (SELECT 1 FROM ( SELECT 'AUDIT ' || AUDIT_OPTION COMANDO
FROM DBA_STMT_AUDIT_OPTS
WHERE USER_NAME IS NULL)
WHERE COMANDO = 'AUDIT AUDIT ANY')
UNION ALL
SELECT 'AUDIT EXECUTE ON SYS.DBMS_SNAPSHOT_UTL BY ACCESS WHENEVER SUCCESSFUL'
FROM V$DATABASE
WHERE NAME='PEPBR'-- esta auditoria soh eh habilitada na base integrada
AND NOT EXISTS (SELECT 1 FROM ( SELECT 'AUDIT EXECUTE ON ' || OWNER || '.' || OBJECT_NAME COMANDO
FROM DBA_OBJ_AUDIT_OPTS
WHERE OWNER = 'SYS'
AND OBJECT_NAME = 'DBMS_SNAPSHOT_UTL'
AND EXE = 'A/-')
WHERE COMANDO = 'AUDIT EXECUTE ON SYS.DBMS_SNAPSHOT_UTL')
UNION ALL
SELECT 'AUDIT EXECUTE ON SYS.DBMS_SCHEDULER BY ACCESS WHENEVER SUCCESSFUL'
FROM V$DATABASE
WHERE NAME='PEPBR'-- esta auditoria soh eh habilitada na base integrada
AND NOT EXISTS (SELECT 1 FROM (SELECT 'AUDIT EXECUTE ON ' || OWNER || '.' || OBJECT_NAME COMANDO
 FROM DBA_OBJ_AUDIT_OPTS
 WHERE OWNER = 'SYS'
 AND OBJECT_NAME = 'DBMS_SCHEDULER'
 AND EXE = 'A/-')
WHERE COMANDO = 'AUDIT EXECUTE ON SYS.DBMS_SCHEDULER');
						
-- logar no ORATOP:
cd $ORACLE_HOME/suptools/oratop

export ORACLE_SID=<base>

oratop / as sysdba

-- comando para adicionar o max_idle_time - Este parametro serve para derrubar sessões que ficaram inativas no banco acima de 120 minutos. 
alter system set max_idle_time = 300 scope=both sid='*';

-- comando do PWCOPY:
pwcopy --dbuniquename odscpdg1 /u01/app/oracle/product/19/db_1/dbs/pwodscp +DG_FRA01/odscpdg1/ -f 

-- comando para zerar o parametro
alter system set redo_transport_user='' sid='*'; 
alter system reset redo_transport_user sid='*';

-- comando para copiar o archive de senha a para o b 
cp orapwrcodscpa orapwrcodscpb

-- comando para copiar os arquivos 
[oracle@sanddb01:/u01/app/oracle/product/19/db_1/dbs] $ scp orapwrcodscp* sanddb02:/u01/app/oracle/product/19/db_1/dbs

-- comando para setar os archives para serem backpeados depois de aplicar no DG:
CONFIGURE ARCHIVELOG DELETION POLICY to applied on all standby; 

1 - criar novos pwfiles no oracle_home/dbs 
2 - replicar para os dois nos pwfile a / pwfile b 
3 - alterar a config da instancia, limpando a config do local do pwfile que estava no asm, deixando em branco, onde o caminho default e oracle_home/dbs. 
4 - enviar os novos pfiles para os dois nodes do dg, e ainda assim apresentava erro. "v$archive_dest_status na primaria log archive_dest"
5 - redefinir a senha do sys com o padrão, copiou novamente os pfiles para o node2 rac e ambiente dataguard e ainda assim, apresentou erros. 
6 - criação de user para o redotrans, dar as permissões necessárias, e definir o user no parametro redo_transport_user, o que funcionou. obs os users foram criados na primaria e dataguard, ja que a replicação não estava válida. neste caso, esta etapa funcionou. 
7 - nova copia do pfile, stop / start na instancia do dg "mount mode", inicializado o apply, que ocorreu bem, deixou sincronizar um pouco e por fim, baixou, parou a replicaçao, abriu a instancia de dr, e iniciou a aplicaçao novamente. obs: feito o processo em um node do dr por vez. obs2, o parametro de redotransuser foi zerado, pois passaria a utilizar o sys novamente... 
obs.: testes de tnsping conectando na primaria / dataguard via sqlplus sys/xxx@prim @standbya partir da primaria / standby e vice e versa. 


rman target / catalog rman_ab/Aslaj1i#001@rman.PETROBRAS.COM.BR

spool log to rman_manual_backup01.log
spool trace to rman_manual_backup01.trc
set echo on
debug all;
run {
ALLOCATE CHANNEL SB01 TYPE 'sbt_tape';
ALLOCATE CHANNEL SB03 TYPE 'sbt_tape';
ALLOCATE CHANNEL SB04 TYPE 'sbt_tape';
send 'NSR_ENV=(NSR_SERVER=srjcipdnw102n01.petrobras.biz, NSR_CLIENT=npaa8723-bkp.petrobras.com.br)';
backup archivelog all format '%d_arch_%U_%t' delete input;
}
debug off;
spool trace off
spool log off

spool log to rman_manual_backup01.log
spool trace to rman_manual_backup01.trc
set echo on
debug all;
run {
allocate channel t1 device type sbt;
backup current controlfile;
}
debug off;
spool trace off
spool log off

vi etc/sysctl.conf

sysctl -p

401749.1


#!/bin/bash
source /u01/app/oracle/scripts/oraenv_19_oracle_db_1.sh
export ORACLE_SID=rcaplabpa
sqlplus "/ as sysdba" @Script03_RLAM_AtualizacaoContratado.sql 
@Script04_RLAM_CopiaMatrizIsolamento.sql

exit


spool /home/oracle/asd2hr

begin
exec dbms_session.set_identifier('Atendimento ao Chamado: S2085709 '|| to_char (sysdate, 'dd/mm/yyyy HH24:MI'));
end;
/

set timing on;
set echo on;
spool /home/oracle/asd2hr/script1.log

exec dbms_session.set_identifier('Atendimento ao Chamado: S2085709 '|| to_char (sysdate, 'dd/mm/yyyy HH24:MI'));

SET DEFINE ON;
spool off
quit

set timing on;
set echo on;
spool /home/oracle/asd2hr/script2.log

exec dbms_session.set_identifier('Atendimento ao Chamado: S2085709 '|| to_char (sysdate, 'dd/mm/yyyy HH24:MI'));

SET DEFINE ON;
spool off
quit

-- verificar o character set da base:
select * from v$nls_parameters where PARAMETER like '%CHARACTERSET%';

-- limpeza de DNS:
ipconfig /flushdns;

-- caminho do bp.conf 
logar com root
vi /usr/openv/netbackup/bp.conf

set lines 2000
set pagesize 60
col OWNER a5
col DIRECTORY_NAME a5
col DIRECTORY_PATH a12

SET LINESIZE 145
SET PAGESIZE 9999
SET VERIFY off
select * from dba_directories; 

-- Se precisar montar - NAS. Pedir para equipe de SO. ou executar com root criar antes com o mkdir a pasta
mount -o rw,bg,hard,rsize=32768,wsize=32768,vers=3,nointr,timeo=600,tcp cipdss01.ep:/ep04/bd/ora_operacao /ora_operacao2
mount -o rw,bg,vers=3,noac,hard,nointr,timeo=600,rsize=32768,wsize=32768 s6006vfs0601.petrobras.biz:/PRD_EXADATA_001/PRD_EXADATA_001 /oracle_bkp/exadata
mount s6006fs14:/vol/DB_NFS_INFRA_APLICACOES_TESTE /ora_operacao2
mount cipdss01.ep:/ep04/bd/ora_operacao /ora_operacao
mount /dev/sdf1 /oracle_dump
mount /oracle_dump
mount s6006fs14:/vol/DB_NFS_INFRA_APLICACOES_TESTE /fts2
mount s6006fs14:/vol/DBA_NFS_DUMP_SPSCO /fts2

umount /oracle_bkp3/cipd
mount /oracle_bkp3/cipd

mount s6006fs14.petrobras.biz:/vol/DBA_CIFS_NFS_SEDE_CIPD/UNIX /oracle_bkp/cipd

mount -o rw,bg,hard,rsize=32768,wsize=32768,vers=3,nointr,timeo=600,tcp cipdss01.ep.petrobras.com.br:/ep01/bd/ep_dba_oracle_bkp /oracle_bkp3/cipd

vi /etc/fstab
mount s6006vfs0606:/PRD_EP_DBA_ORACLE_001/PRD_EP_DBA_ORACLE_001/oracle_bkp3/cipd nfs rw,bg,hard,rsize=32768,wsize=32768,vers=3,nointr,timeo=600,tcp 0 0

mount s6006vfs0601:/PRD_BDIEP_006/PRD_BDIEP_006/recs /oracle_bkp4/recs
mount s6006vfs0601.petrobras.biz:/PRD_ARCHIVE_ORACLE_001/PRD_ARCHIVE_ORACLE_001 /arch_alternate/rec

mkdir /oracle_bkp3/cipd/
mount -o rw,bg,hard,rsize=32768,wsize=32768,vers=3,nointr,timeo=600,tcp cipdss01.ep.petrobras.com.br:/ep01/bd/ep_dba_oracle_bkp /oracle_bkp3/cipd

-- tamanho da tabela:
SELECT * FROM
(select OWNER,
SEGMENT_NAME,
SEGMENT_TYPE,
MAX (BYTES/1024/1024) MB,
TABLESPACE_NAME
from
dba_segments WHERE OWNER = 'CCMULTI_OWNER'
GROUP BY OWNER,SEGMENT_NAME, SEGMENT_TYPE, TABLESPACE_NAME order by 3 desc );

Select count (*) from dba_segments where like owner='%SCH_EMRG%';

col owner for a22
select owner, count(*), sum(bytes/1024/1024/1024)gb from dba_segments where owner like 'SCH_EMRG%' group by owner order by 1;

-- montar NAS - root
mkdir -p /ora_operacao
mount -o rw,bg,hard,rsize=32768,wsize=32768,vers=3,nointr,timeo=600,tcp cipdss01.ep:/ep04/bd/ora_operacao /ora_operacao

mkdir -p /ora_operacao2
mount -o rw,bg,hard,rsize=32768,wsize=32768,vers=3,nointr,timeo=600,tcp s6006fs14:/vol/DB_NFS_INFRA_APLICACOES_TESTE /ora_operacao2

-- criar diretorio no banco:
select OWNER, DIRECTORY_NAME, DIRECTORY_PATH from dba_directories where directory_name = 'DIR_BKP_DUMP';

CREATE OR REPLACE directory DIR_EXP_DUMP AS '/ora_operacao/ASD2HR/S3299725_1';
CREATE OR REPLACE directory DIR_BKP_DUMP AS '/ora_operacao/ASD2HR/S3299725_BKP_SMSR_E1';

grant read, write on directory DIR_EXP_DUMP to sys, system;
grant read, write on directory DIR_BKP_DUMP to sys, system;

sqlfile=SPAD.sql content = metadata_only

--dump vindo de uma base sem acesso (time - c)

Aqui podemos pontuar que o comando sqlfile=SPAD.sql content = metadata_only que gera um archivo pontuando o que vem de dados de outra base:

Na maioria dos casos, criamos a TBS e as roles. Ex: 

-o procedimento de soltar o dump é esse:

--nohup impdp \"/ as sysdba\" JOB_NAME=Atendimento_S2762162 directory=DIR_ASD2HR dumpfile=APLC08P_SPAD_S2762162.dmp logfile=APLC08P_SPAD_S2762162_1.log sqlfile=SPAD.sql content = metadata_only cluster=n parallel=8 &

Feito isso, é compilar o comando do dump: 

-- verificar o tamanho do schema:
Select sum(bytes/1024/1024/1024) GB from dba_segments where owner='SSP0';
Select sum(bytes/1024/1024/1024) GB from dba_segments where owner in 
('DESEMPENHO_BGJOBUSER', 'DESEMPENHO_PRIVUSER', 'DESEMPENHO_ADMUSER', 'DESEMPENHO_PUBUSER', 'DESEMPENHO_PXRPTUSER');

-- nohup impdp \"/ as sysdba\" JOB_NAME=Atendimento_S3007024directory=DIR_ASD2HR dumpfile=APLC08P_SPAD_S2762162.dmp logfile=APLC08P_SPAD_S2762162_2.logcluster=n parallel=8 &
 
-- - dump Copia de schema:
-- nohup expdp \"/ as sysdba\" schemas=SMSR directory=DIR_EXP_DUMP dumpfile=expdp_asd2hr_SMSR_BKP_%U.dmp logfile=expdp_asd2hr_SMSR_BKP_.log flashback_time=systimestamp cluster=n parallel=8 &
-- nohup expdp \"/ as sysdba\" schemas=SMSR_E1 directory=DIR_BKP_DUMP dumpfile=expdp_asd2hr_SMSR_E1_BKP_%U.dmp logfile=expdp_asd2hr_SMSR_E1_BKP_.log flashback_time=systimestamp cluster=n parallel=8 &

-- nohup impdp \"/ as sysdba\" schemas=SMSR directory=DIR_EXP_DUMP dumpfile=expdp_asd2hr_%U.dmp logfile=impdp_asd2hr_.log cluster=n parallel=8 &
-- nohup impdp \"/ as sysdba\" remap_schema=SMSR:SMSR_E1 directory=DIR_EXP_DUMP dumpfile=expdp_asd2hr_%U.dmp logfile=impdp_asd2hr_.log cluster=n parallel=8 &

--nohup expdp \"/ as sysdba\" tables="CMXL"."LOG_ARCHIVE_TRACE","CMXL"."POS_SCR_FINAL_RESULT","CMXL"."POS_SUM_FINAL_RESULT_LINK","CMXL"."POS_SUM_FINAL_RESULT","CMXL"."POS_SUM_FINAL_DTL_RESULT_LINK","CMXL"."POS_SUM_FINAL_DTL_RESULT","CMXL"."POS_SCR_FINAL_RESULT_LINK" directory=DIR_LOG_BKP dumpfile=expdp_VCXL_%U.dmp logfile=expdp_VCXL_.log flashback_time=systimestamp cluster=n parallel=8 &


-- nohup impdp \"/ as sysdba\" schemas=GINSP directory=DIR_LOG_BKP dumpfile=expdp_GINSP_%U.dmp logfile=expdp_GINSP_.log cluster=n parallel=8 &
-- nohup impdp \"/ as sysdba\" Tables="RDOE"."TURNO_TRABALHO" TABLE_EXISTS_ACTION=TRUNCATE directory=DIR_BKP_DUMP dumpfile=expdp_asd2hr_S3080752_%U.dmp cluster=n logfile=expdp_asd2hr_S3080752_.log parallel=8 &

-- nohup impdp \"/ as sysdba\" directory=DIR_LOG_BKP dumpfile=expdp_GINSP_%U.dmp logfile=expdp_TABLES_.log cluster=n parallel=8 tables='GINSP.ARQUIVO' &

-- nohup expdp \"/ as sysdba\" schemas=TCRP directory=DIR_LOG_BKP dumpfile=expdp_TCRP_%U.dmp logfile=expdp_TCRP_.log flashback_time=systimestamp cluster=n parallel=10 &
-- nohup impdp \"/ as sysdba\" schemas=CUBO_ETL,CUBO_APLICACAO,CUBO_DEPLOYBD directory=DIR_LOG_BKP dumpfile=expdp_CUBO_USERS_%U.dmp logfile=expdp_CUBO_USERS_IMP.log cluster=n parallel=10 &
-- nohup impdp \"/ as sysdba\" schemas=CUBO directory=DIR_LOG_BKP dumpfile=expdp_CUBO_%U.dmp logfile=expdp_CUBO_IMP_.log cluster=n parallel=10 &
-- nohup expdp \"/ as sysdba\" schemas=UE6LX directory=DIR_BKP_DUMP dumpfile=expdp_UE6LX_BKP_%U.dmp logfile=expdp_UE6LX_BKP_.log flashback_time=systimestamp cluster=n parallel=10 &
-- nohup impdp \"/ as sysdba\" schemas=UE6LX directory=DIR_LOG_BKP dumpfile=expdp_UE6LX_%U.dmp logfile=expdp_UE6LX_IMP_.log cluster=n parallel=10 &
-- nohup expdp \"/ as sysdba\" schemas=SSP0 directory=DIR_BKP_DUMP dumpfile=expdp_SSP0_BKP_T_%U.dmp logfile=expdp_SSP0_BKP_T_.log flashback_time=systimestamp cluster=n parallel=10 &
-- nohup expdp \"/ as sysdba\" schemas=SSP0 directory=DIR_BKP_DUMP dumpfile=expdp_SSP0_%U.dmp logfile=expdp_SSP0_.log flashback_time=systimestamp cluster=n parallel=10 &
-- nohup expdp \"/ as sysdba\" schemas=SSP0 directory=DIR_LOG_BKP dumpfile=expdp_SSP0_%U.dmp logfile=expdp_SSP0_.log flashback_time=systimestamp cluster=n parallel=10 &
-- nohup impdp \"/ as sysdba\" schemas=SSP0 directory=DIR_LOG_BKP dumpfile=expdp_SSP0_%U.dmp logfile=expdp_SSP0_.log cluster=n parallel=10 &

-- nohup expdp \"/ as sysdba\" schemas=RSCO directory=DIR_BKP_DUMP dumpfile=expdp_RSCO_BKP_%U.dmp logfile=expdp_RSCO_BKP_.log flashback_time=systimestamp cluster=n parallel=10 &
-- nohup expdp \"/ as sysdba\" schemas=DESEMPENHO_BGJOBUSER,DESEMPENHO_PRIVUSER,DESEMPENHO_ADMUSER,DESEMPENHO_PUBUSER,DESEMPENHO_PXRPTUSER directory=DIR_BKP_DUMP dumpfile=expdp_DESEMPENHO_BKP_%U.dmp logfile=expdp_DESEMPENHO_BKP_.log flashback_time=systimestamp cluster=n parallel=4 &

-- nohup expdp \"/ as sysdba\" schemas=RDOE directory=DIR_BKP_DUMP dumpfile=expdp_asd2hr_S3080752_BKP_%U.dmp logfile=expdp_asd2hr_S3080752_BKP_.log flashback_time=systimestamp cluster=n parallel=8 &

-- nohup expdp \"/ as sysdba\" schemas=ROND_PE_RENEST,ROND_PE_RENEST_APLICACAO,TELEMAT_PE_RENESTdirectory=DIR_ASCJSP dumpfile=exp_colonia_rondapb_S2199538_%U.dmp logfile=exp_colonia_rondapb_S2199538.log flashback_time=systimestampcluster=n parallel=8 &

-- nohup expdp \"/ as sysdba\"schemas=SPOTFIRE,SPOTFIRE_ACTIONLOG,SPOTFIRE_STATS directory=DIR_LOG_BKP dumpfile=expdp_ascjsp_exaprd02_R2824975_%U.dmp logfile=expdp_ascjsp_exaprd02_R2824975.log cluster=n flashback_time=systimestamp parallel=8 &

export ORACLE_PDB_SID=EXADSV01

-- nohup expdp \"/ as sysdba\" schemas=PPBR_STG version=12.2.0.1 directory=DIR_BKP dumpfile=expdp_asd2hr_S3069706_%U.dmp logfile=expdp_asd2hr_S3069706_.log flashback_time=systimestamp cluster=n parallel=8

-- nohup expdp \"/ as sysdba\" schemas=BDEMQ directory=DIR_LOG_BKP dumpfile=S3166154_BDEMQ_%U.dmp logfile=S3166154_BDEMQ_.log flashback_time=systimestamp cluster=n parallel=8 &

-- nohup impdp \"/ as sysdba\" schemas=BDEMQ remap_schema=BDEMQ:BDEMQ_E1 directory=DIR_LOG_BKP dumpfile=S3166154_BDEMQ_%U.dmp logfile=S3166154_BDEMQ_IMP.log flashback_time=systimestamp cluster=n parallel=8 &

-- nohup impdp \"/ as sysdba\" directory=DIR_BKP dumpfile=expdp_asd2hr_S3069706_%U.dmp logfile=expdp_asd2hr_S3069706_.log cluster=n parallel=8 &

-- nohup impdp \"/ as sysdba\" directory=DIR_ASD2HR dumpfile=expdp_asd2hr_aplabp_S2510669_%U.dmp logfile=expdp_asd2hr_aplabp_S2510669_.log cluster=n parallel=8 status=30 &

-- nohup impdp \"/ as sysdba\" directory=DIR_ADM_DPUMP_NAS dumpfile=expdp_asd2hr_sanddb03_exaprd01_S2034280_%U.dmp cluster=n Tables="RDOE"."TURNO_TRABALHO" logfile=expdp_asd2hr_onyxdb01_exadsv01_S2034280.v1.log TABLE_EXISTS_ACTION=TRUNCATE parallel=8 status=30 &

-- nohup impdp dumpfile=expdp_SEAN_20211125_PRDEP_ASCYCZ.dmp remap_schema=SEAN:SCH_SEAN logfile=S2300794_expdp_SEAN_20211125_PRDEP_ASCYCZ_T2.log directory=dump_S2300794 table_exists_action=append parallel=8 &

-- nohup expdp \"/ as sysdba\" JOB_NAME=Atende_S2145926 schemas=SPOT directory=DIR_ADM_DPUMP_NAS dumpfile=expdp_asd2hr_mikoyan_aplabp_S2145926_%U.dmp logfile=expdp_asd2hr_mikoyan_aplabp_S2145926.log flashback_time=systimestamp cluster=n parallel=8 &

-- copia de segurança
-- nohup expdp \"/ as sysdba\" schemas=SPOT directory=DIR_ADM_DPUMP_NAS dumpfile=expdp_asd2hr_npaa2648_aplabh_copia_seg_%U.dmp logfile=expdp_asd2hr_npaa3648_aplabh_copia_seg.log flashback_time=systimestamp cluster=n parallel=8 &

-- nohup impdp \"/ as sysdba\" directory=DIR_ADM_DPUMP_NAS dumpfile=expdp_asd2hr_mikoyan_aplabp_S2145926_%U.dmp logfile=impdp_asd2hr_mikoyan_aplabp_S2145926.log cluster=n parallel=8 &

-- dump banco FULL
-- nohup expdp \"/ as sysdba\" full=Y directory=DIR_BKP_DUMP dumpfile=expdp_S3239206_%U.dmp logfile=expdp_S3239206_.log flashback_time=systimestamp cluster=n parallel=10 &

flashback_scn=49883730856

-- pós import:
SELECT 'CREATE OR REPLACE SYNONYM <usuario>_APLICACAO.' || OBJECT_NAME || ' FOR ' || OWNER || '.' || OBJECT_NAME || ';'
FROM DBA_OBJECTS WHERE OWNER='<usuario>' AND OBJECT_TYPE IN ('TABLE', 'VIEW', 'SEQUENCE','PROCEDURE','FUNCTION')order by OBJECT_TYPE;

-- Privilégios
SELECT 'GRANT SELECT ON ' || OWNER || '.' || OBJECT_NAME || ' TO <usuario>_DRL;'
FROM DBA_OBJECTS WHERE OWNER='<usuario>' AND OBJECT_TYPE IN ('TABLE', 'VIEW', 'SEQUENCE');

SELECT 'GRANT INSERT, UPDATE, DELETE ON ' || OWNER || '.' || OBJECT_NAME || ' TO <usuario>_DML;'
FROM DBA_OBJECTS WHERE OWNER='<usuario>' AND OBJECT_TYPE IN ('TABLE');

SELECT 'GRANT EXECUTE ON ' || OWNER || '.' || OBJECT_NAME || ' TO <usuario>_EXEC;'
FROM DBA_OBJECTS WHERE OWNER='<usuario>' AND OBJECT_TYPE IN ('PROCEDURE', 'FUNCTION', 'PACKAGE');

--Recriar os acessos e sinonimos 
SELECT 'GRANT SELECT ON ' || OWNER || '.' || OBJECT_NAME || ' TO RSGER_DRL;' FROM DBA_OBJECTS WHERE OWNER='SGER' AND OBJECT_TYPE IN ('TABLE', 'VIEW', 'SEQUENCE');
SELECT 'GRANT INSERT, UPDATE, DELETE ON ' || OWNER || '.' || OBJECT_NAME || ' TO RSGER_DML;' FROM DBA_OBJECTS WHERE OWNER='SGER' AND OBJECT_TYPE IN ('TABLE');
SELECT 'GRANT EXECUTE ON ' || OWNER || '.' || OBJECT_NAME || ' TO RSGER_EXEC;' FROM DBA_OBJECTS WHERE OWNER='SGER' AND OBJECT_TYPE IN ('PROCEDURE', 'FUNCTION', 'PACKAGE');
SELECT 'CREATE OR REPLACE SYNONYM SGER_APLICACAO.' || OBJECT_NAME || ' FOR ' || OWNER || '.' || OBJECT_NAME || ';' FROM DBA_OBJECTS WHERE OWNER='SGER' AND OBJECT_TYPE IN ('TABLE', 'VIEW', 'SEQUENCE','PROCEDURE','FUNCTION')order by OBJECT_TYPE;
SELECT 'CREATE OR REPLACE SYNONYM SGER_ETL.' || OBJECT_NAME || ' FOR ' || OWNER || '.' || OBJECT_NAME || ';' FROM DBA_OBJECTS WHERE OWNER='SGER' AND OBJECT_TYPE IN ('TABLE', 'VIEW', 'SEQUENCE','PROCEDURE','FUNCTION') order by OBJECT_TYPE;

-- verificar os grants:
set long 9999999
select dbms_metadata.get_ddl('USER','BDEMQ_E1')||';' from dual;
SELECT DBMS_METADATA.GET_GRANTED_DDL('ROLE_GRANT','RDOE')||';' FROM DUAL;
SELECT DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','RDOE')||';' FROM DUAL;
SELECT DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','RDOE') ||';' FROM DUAL;

set linesize 200
set pagesize 60
col profile for a30
col USERNAME for a20
col ACCOUNT_STATUS for a10
SELECT USERNAME,EXPIRY_DATE, PROFILE,ACCOUNT_STATUS, DEFAULT_TABLESPACE from dba_users where username like '%PPBR_STG%';

-- LIMPAR O SCHEMA PÒS EXPORT:

set pages 0 
SELECT 'DROP 
 '|| OWNER||'.'||TABLE_NAME || ' CASCADE CONSTRAINTS PURGE;' FROM DBA_TABLES WHERE OWNER IN ('SMSR_E1');
SELECT 'DROP ' || OBJECT_TYPE || ' ' || OWNER||'.'||OBJECT_NAME || ';' FROM DBA_OBJECTS WHERE OWNER IN ('SMSR_E1')
AND OBJECT_TYPE NOT IN ('TABLE','INDEX') AND OBJECT_NAME NOT LIKE 'BIN$%' AND OBJECT_NAME NOT LIKE '%$$' ORDER BY object_name;
SELECT 'DROP ' || OBJECT_TYPE || ' ' || OWNER||'.'||OBJECT_NAME || ';' FROM DBA_OBJECTS WHERE OWNER IN ('SMSR_E1') AND OBJECT_TYPE='SYNONYM';

-- comparar os objetos: 
select count(1), object_type from dba_objects where owner ='SCH_EMRG' group by object_type order by object_type;
select object_name, object_type from dba_objects where owner ='SCH_EMRG' order by object_type;

-- Analisar as estatisticas do owner - tabela:
col owner for a22
col TABLE_NAME for a22
set lines 2000 pages 2000
SELECT OWNER, TABLE_NAME, LAST_ANALYZED, NUM_ROWS FROM DBA_TABLES WHERE OWNER = 'OSADMIN';

-- Analisar as estatisticas do owner - indices
SELECT
 S.Owner As "Schema"
,S.Table_Name As "Objeto"
,S.Object_Type As "Tipo do Objeto"
,S.Num_Rows As "Qtd. de Linhas"
,To_Char(S.Last_Analyzed, 'yyyy-MM-dd HH24:mm:ss') As "Ultima Coleta"
FROM
sys.dba_ind_statistics S
WHERE
S.Owner = 'OSADMIN'
ORDER BY
S.Last_Analyzed;

-- por data:
col owner for a22
col TABLE_NAME for a22
set lines 2000 pages 2000
SELECT OWNER, TABLE_NAME, LAST_ANALYZED, NUM_ROWS FROM DBA_TABLES WHERE OWNER = 'SEDPPE' and LAST_ANALYZED > '16/11/2021';

-- Coleta de estatisticas por owner por tabela:

set pages 0
set lines 200

SELECT 'begin
dbms_stats.gather_table_stats (
ownname => '''||tab.owner||''',
tabname => '''||tab.table_name||''',
ESTIMATE_PERCENT => DBMS_STATS.AUTO_SAMPLE_SIZE,
cascade => true,
method_opt => ''FOR ALL INDEXED COLUMNS SIZE SKEWONLY'',
degree =>4
);
end;' ||chr(10)||
'/'
FROM DBA_TABLES TAB, DBA_OBJECTS OBJ
WHERE
TAB.OWNER = OBJ.OWNER AND
TAB.TABLE_NAME = OBJ.OBJECT_NAME AND
OBJ.OBJECT_TYPE = 'TABLE' AND
TAB.OWNER = 'PLAB' AND
TAB.TABLE_NAME NOT IN (SELECT TABLE_NAME FROM DBA_EXTERNAL_TABLES WHERE TABLE_NAME IS NOT NULL) AND
TABLE_NAME NOT IN (SELECT LOG_TABLE FROM DBA_SNAPSHOT_LOGS WHERE LOG_TABLE IS NOT NULL) AND
TABLE_NAME NOT IN (SELECT UPDATE_LOG FROM DBA_SNAPSHOTS WHERE UPDATE_LOG IS NOT NULL);

-- coletar somente de uma tabela
exec dbms_stats.gather_table_stats(ownname=>'BDEMQ',tabname=>'HIST_VALOR_OCORRENCIA',estimate_percent=>0.1,block_sample=>true, method_opt=>'FOR ALL INDEXED COLUMNS SIZE AUTO',cascade=>false,granularity=>'ALL',degree=>4);

-- coleta estatistica do schema por inteiro 
exec dbms_stats.gather_schema_stats('SSP0',options=>'GATHER', estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE, method_opt => 'FOR ALL COLUMNS SIZE AUTO', cascade => TRUE);

exec dbms_stats.gather_table_stats(ownname=>'TCRP',tabname=>'T',estimate_percent=>0.1,block_sample=>true,method_opt=>'FOR ALL INDEXED COLUMNS SIZE AUTO',cascade=>false,granularity=>'ALL',degree=>4);


-- Coleta de estatísticas do dicionario do banco:
begin
DBMS_STATS.GATHER_DICTIONARY_STATS(
degree => 4,
no_invalidate => false);
end;
/

-- Coleta de estatísticas nos objetos no banco:
begin
DBMS_STATS.GATHER_FIXED_OBJECTS_STATS(
no_invalidate => false);
end;
/

-- compilar objetos invalidos do schema:
BEGIN
SYS.UTL_RECOMP.RECOMP_SERIAL(SCHEMA =>'SMSR_E1');
END;
/

@$ORACLE_HOME/rdbms/admin/utlrp.sql

exec sys.utl_recomp.recomp_parallel(4);

-- coleta de estatisticas no indices:
select INDEX_NAME,LAST_ANALYZED, STATUS from dba_indexes where table_name='HIST_VALOR_OCORRENCIA';

EXEC DBMS_STATS.gather_index_stats('BDEMQ','IN_FK_HIVO_ORGA_CD_CBI',force=>true,ESTIMATE_PERCENT =>100,degree =>4);

-- export de estatisticas:
exec dbms_stats.create_stat_table(ownname => 'BDEMQ',stattab => 'STATSBACKUP',tblspace => 'BDEMQ_D_01');
select * from dba_tables where table_name ='STATSBACKUP';

exec dbms_stats.export_table_stats(ownname => 'BDEMQ',tabname =>'HIST_VALOR_OCORRENCIA',partname => NULL, stattab =>'STATSBACKUP',statid => NULL,cascade => TRUE,statown =>'BDEMQ');

-- import de estatisticas:
exec dbms_stats.import_table_stats(ownname => 'BDEMQ',tabname => 'HIST_VALOR_OCORRENCIA',partname => NULL, 
stattab => 'STATSBACKUP',statid => NULL, cascade => TRUE, statown =>'BDEMQ');

Doc ID 2701368.1


-- limpeza pré upgrade
PURGE RECYCLEBIN;
PURGE DBA_RECYCLEBIN;

@$ORACLE_HOME/rdbms/admin/utlrp.sql

select owner, object_name ,object_type
from DBA_objects
where STATUS ='INVALID' and owner ='SCH_EMRG';

select 'ALTER VIEW "' || owner || '"."' || object_name || '" compile;'
from DBA_objects
where object_type='ANEXO' and STATUS ='INVALID' and owner ='SCH_EMRG';

select 'ALTER MATERIALIZED VIEW "' || owner || '"."' || object_name || '" compile;'
from DBA_objects
where object_type='MATERIALIZED VIEW' and STATUS ='INVALID' and owner ='SCH_EMRG';

select 'ALTER FUNCTION "' || owner || '"."'|| object_name || '" compile;'
from DBA_objects
where object_type='FUNCTION' and STATUS ='INVALID' and owner ='SCH_EMRG';

================================================================================================

select 'ALTER PACKAGE BODY "' || owner || '"."' || object_name || '" compile;'
from DBA_objects
where object_type='PACKAGE BODY' and STATUS ='INVALID';

select 'ALTER PROCEDURE "' || owner || '"."' || object_name || '" compile;'
from DBA_objects
where object_type='PROCEDURE' and STATUS ='INVALID';

select 'ALTER SYNONYM "' || owner || '"."' || object_name || '" compile;'
from DBA_objects
where object_type='SYNONYM' and STATUS ='INVALID';

-- Comparativo de schema:
col owner for a22
col segment_type for a22
set lines 2000 pages 2000
select owner, segment_type, count(*) from dba_segments where owner ='SPOT' group by owner, segment_type
order by 2;

col owner for a22
col segment_type for a22
set lines 2000 pages 2000
select owner, segment_type, count(*) from dba_segments where owner ='SPOT' group by owner, segment_typeorder by 2;

-- chamados de absorção

- validação de BKP
- validação do ORASTATUS
- validação do monitoramento.

--MEMORY do banco:
SELECT
round(PGA_TARGET_FOR_ESTIMATE/1024/1024)
target_mb,
ESTD_PGA_CACHE_HIT_PERCENTAGE
cache_hit_perc,
ESTD_OVERALLOC_COUNT
FROM
V$PGA_TARGET_ADVICE;

set lines 200
select * from v$sga_target_advice;

select component, oper_type, oper_mode, 
 parameter, initial_size, final_size,
 to_char(start_time,'dd/mm/yyyyhh24:mi:ss') start_time, 
 to_char(end_time,'dd/mm/yyyyhh24:mi:ss') end_timefrom v$memory_resize_ops;
 
SELECT * FROM V$PGASTAT;

-- gerenciamento do memory target:
col COMPONENT for a20
col OPER_TYPE for a10
col OPER_MODE for a10
col PARAMETER for a20
col INITIAL_SIZE for a50
col FINAL_SIZE for a50
col START_TIME for a20
col END_TIME for a20
select component, oper_type, oper_mode, parameter,initial_size, final_size,
to_char(start_time,'dd/mm/yyyy hh24:mi:ss') start_time,
to_char(end_time,'dd/mm/yyyy hh24:mi:ss') end_time
from v$memory_resize_ops;

-- exemplos de como tem que ficar a entrada de TNS:
TCRP.PETROBRAS.COM.BR=
(DESCRIPTION=
(ADDRESS=(PROTOCOL=TCP)(HOST=sand-scan1.petrobras.com.br)(PORT=1521))
(CONNECT_DATA=
(SERVICE_NAME=odscp.petrobras.com.br)(UR=A)
)
)

TCRP_ODSCP.PETROBRAS.COM.BR=
(DESCRIPTION=
(ADDRESS=(PROTOCOL=TCP)(HOST=sand-scan1.petrobras.com.br)(PORT=1521))
(CONNECT_DATA=
(SERVICE_NAME=odscp.petrobras.com.br)(UR=A)
)
)

On UNIX:
root@erpddb01:/usr/openv/netbackup/bin/nbsetconfig
nbsetconfig>DB_SCRIPT_PATH = /export/home/oraprod/scripts
nbsetconfig>DB_SCRIPT_PATH = /export/home/oraprod/scripts/rmanfull.daily
nbsetconfig>
<ctrl-D>

-- evidencias - oracle:
select host_name,instance_name from gv$instance;
select id_grupo,profile from orastatus.tbl_grupo_adm where id_grupo='GG_INFRA_SUPORTE_AB_DBA';
select systimestamp from dual;

-- VELOCIDADE RMAN2

set linesize 126

column Pct_Complete format 99.99

column client_info format a25

column sid format 999column MB_PER_S format 999.99

select s.client_info,

l.sid,

l.serial#,

l.sofar,

l.totalwork,

round (l.sofar / l.totalwork*100,2) "Pct_Complete",

aio.MB_PER_S,

aio.LONG_WAIT_PCT

from v$session_longops l,

v$session s,

(select sid,

serial,

100* sum (long_waits) / sum (io_count) as "LONG_WAIT_PCT",

sum (effective_bytes_per_second)/1024/1024 as "MB_PER_S"

from v$backup_async_io

group by sid, serial) aio

where aio.sid = s.sid

and aio.serial = s.serial#

and l.opname like 'RMAN%'

and l.opname not like '%aggregate%'

and l.totalwork != 0

and l.sofar <> l.totalwork

and s.sid = l.sid

and s.serial# = l.serial#

order by 1;


-- TEPAIOP:
•	Host: npaa9314.petrobras.biz:1521
•	Nome do banco de dados: tepst
•	Usuário: system
•	Senha: uD4#Ux7ao8

-- teste com o redotrans DG x primaria e vice versa
sqlplus REDOTRANS/Entub#d0sh@SISTDG2 as sysdba

-- analisar usuario info/dados de user - GRANT:
set long 9999999
select dbms_metadata.get_ddl('USER','c1s1ccp1')||';' from dual;
SELECT DBMS_METADATA.GET_GRANTED_DDL('ROLE_GRANT','c1s1ccp1')||';' FROM DUAL;
SELECT DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','c1s1ccp1')||';' FROM DUAL;
SELECT DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','c1s1ccp1') ||';' FROM DUAL;

-- select pra ver o que tem dentro da role:
set long 9999999
SELECT DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','REDM_GPCS_DRL') ||';' FROM DUAL;

-- Verificar Roles/Privilégios de um usuário
SELECT * FROM DBA_ROLE_PRIVS WHERE GRANTEE = 'SGLDW';

-- alteração de usuario com login global
CREATE USER U4PK IDENTIFIED GLOBALLY AS 'cn=U4PK,cn=Users,o=petrobras,dc=petrobras,dc=com,dc=br' DEFAULT TABLESPACE USERS PROFILE PFL_BDEMQCI_USER;
alter USER "C5FL" IDENTIFIED GLOBALLY AS 'cn=U4PK,cn=Users,o=petrobras,dc=petrobras,dc=com,dc=br';
ALTER USER SX5A IDENTIFIED GLOBALLY AS 'cn=SX5A,cn=Users,o=petrobras,dc=petrobras,dc=com,dc=br' PROFILE PFL_BDEMQCI_USER DEFAULT TABLESPACE USERS ACCOUNT UNLOCK;
GRANT RBDEMQ_DRL, RADM_USER to C5FL;

alter user xxx identified externally accoun unlock;

SELECT USERNAME, PASSWORD,ACCOUNT_STATUS, PROFILE, DEFAULT_TABLESPACE from dba_users where username like '%SX5A%';

ALTER USER SX5A IDENTIFIED EXTERNALLY PROFILE PFL_BDEMQCI_USER;

-- nohup expdp system/senha JOB_NAME=Atendimento_S2212736 FULL=Y directory=DIR_ASD2HR dumpfile=expdp_Atendimento_S2212736_%U.dmp logfile=expdp_Atendimento_S2212736.log flashback_time=systimestamp logtime=all metrics=y cluster=n parallel=8 &

-- nohup expdp \"/ as sysdba\" JOB_NAME=Atendimento_S2145926 schemas=SPOT directory=DIR_ADM_DPUMP_NAS dumpfile=expdp_asd2hr_mikoyan_aplabp_S2145926_%U.dmp logfile=expdp_asd2hr_mikoyan_aplabp_S2145926.log flashback_time=systimestamp cluster=n parallel=8 status=30 &

nohup expdp SYSTEM/Entub#d0sh JOB_NAME=Atendimento_S2212736_V SCHEMAS='ECMX','ECMX_INTEGRACAO_TIMP' directory=DIR_ASD2HR dumpfile=Atendimento_S2212736_V_%U.dmp logfile=Atendimento_S2212736_V.log flashback_time=systimestamp cluster=n parallel=8 &

expdp SYSTEM/Entub#d0sh attach=Atendimento_S2212736_V


column con_id format 99
column pdb format a15
column network_name format a30
select con_id, pdb, network_name from cdb_services where pdb is not null and con_id > 2 order by pdb;

column name format a30;
column network_name format a30;
select name, network_name from v$active_services;

-- query de perfomance de import/export
SELECT SID,
SERIAL#,
START_TIME,
((SOFAR/TOTALWORK)*100),'%',
MESSAGE
FROM GV$SESSION_LONGOPS
where TIME_REMAINING > 0 ORDER BY start_time;

SELECT SID, SERIAL#,OPNAME, CONTEXT, SOFAR, TOTALWORK,ROUND(SOFAR/TOTALWORK*100,2) "%_COMPLETE" 
FROM GV$SESSION_LONGOPS WHERE OPNAME NOT LIKE '%aggregate%' AND TOTALWORK != 0 AND SOFAR <> TOTALWORK;

select sql_id from v$session where sid='3030';

select sql_fulltext from V$sql where sql_id='bjf05cwcj5s6p';

select sql_id, state, last_call_et, event, program, osuser from v$session where sql_id='bjf05cwcj5s6p';

set lines 200
col MESSAGE for a100
select message, time_remaining/3600 hrs from v$session_longops where sofar <> totalwork;

SET lines 1000
COL owner_name FORMAT a10;
COL job_name FORMAT a20
COL state FORMAT a11
COL operation LIKE state
COL job_mode LIKE state
select * from dba_datapump_jobs where state='EXECUTING';

SELECT SID, SERIAL#, opname, SOFAR, TOTALWORK,
ROUND(SOFAR/TOTALWORK*100,2) COMPLETE
FROM V$SESSION_LONGOPS
WHERE TOTALWORK != 0 AND SOFAR != TOTALWORK
order by 1;

//long ops
col SID for a20
col SERIAL# for a20
col MACHINE for a20
col OPNAME for a20
col START_TIME for a20
col LAST_UPDATE_TIME for a20
col SQL_ID for a20
col MESSAGE for a20
col TARGET for a20
col ELAPSED for a20
SELECT s.sid,
s.serial#,
s.machine,
sl.opname,
to_char(sl.start_time,'dd mon yyyy HH24:mi:ss') as start_time,
to_char(sl.last_update_time,'dd mon yyyy HH24:mi:ss') as last_update_time,
sl.sql_id,
sl.message,
sl.target,
ROUND(sl.elapsed_seconds/60) || ':' || MOD(sl.elapsed_seconds,60) elapsed,
ROUND(sl.time_remaining/60) || ':' || MOD(sl.time_remaining,60) remaining
FROM gv$session s,
gv$session_longops sl
WHERE s.sid = sl.sid
AND s.serial# = sl.serial#
AND sl.totalwork <> sl.sofar
order by elapsed_seconds desc;
========================================================================================================
alter session set nls_date_format='dd/mm/yyyy hh24:mi:ss';
set pages 100 lines 200
col percdone form a10
col elapsed format a10
col remaining format a10
col totalwork format 999,999,990
col sofar format 999,999,990
col usernameformat a15
col targetformat a10
col opnameformat a25
select inst_id,sid, serial#, username, SOFAR, TOTALWORK, round(( sofar/totalwork )*100)||'%' PercDone,
ltrim(to_char(trunc(time_remaining/60/60),'000'))||':'||
ltrim(to_char(trunc(time_remaining/60)-(trunc(time_remaining/60/60)*60),'00'))||':'||
ltrim(to_char(time_remaining-(trunc(time_remaining/60/60)*60*60)-
 (trunc(time_remaining/60)-(trunc(time_remaining/60/60)*60))*60,'00')) REMAINING,
ltrim(to_char(trunc(elapsed_seconds/60/60),'00'))||':'||
ltrim(to_char(trunc(elapsed_seconds/60)-(trunc(elapsed_seconds/60/60)*60),'00'))||':'||
ltrim(to_char(elapsed_seconds-(trunc(elapsed_seconds/60/60)*60*60)-
 (trunc(elapsed_seconds/60)-(trunc(elapsed_seconds/60/60)*60))*60,'00')) ELAPSED,
ltrim(to_char(trunc((time_remaining+elapsed_seconds)/60/60),'00'))||':'||
ltrim(to_char(trunc((time_remaining+elapsed_seconds)/60)-(trunc((time_remaining+elapsed_seconds)/60/60)*60),'00'))||':'||
ltrim(to_char((time_remaining+elapsed_seconds)-(trunc((time_remaining+elapsed_seconds)/60/60)*60*60)-
 (trunc((time_remaining+elapsed_seconds)/60)-(trunc((time_remaining+elapsed_seconds)/60/60)*60))*60,'00')) TOTAL,
sysdate+(time_remaining/60/60/24) PREVISAO_TERMINO,
TARGET, OPNAME
from gv$session_longops
where sofar <> totalwork and totalwork <> 0 order by target;

SELECT /*+ RULE */ D.JOB, V.SID, V.SERIAL#,LOG_USER USERNAME, WHAT,
DECODE(TRUNC(SYSDATE - LOGON_TIME), 0, NULL,
TRUNC(SYSDATE - LOGON_TIME) || ' Days' || ' + ') ||
TO_CHAR(TO_DATE(TRUNC(MOD(SYSDATE-LOGON_TIME,1) * 86400), 'SSSSS'), 'HH24:MI:SS') RUNNING,
D.FAILURES, 'alter system kill session ' || '''' || V.SID || ', ' || V.SERIAL# || '''' || ' immediate;' KILL_SQL
FROM DBA_JOBS_RUNNING D, GV$SESSION V, DBA_JOBS J
WHERE V.SID = D.SID
AND D.JOB = J.JOB
order by running desc;


-- query que verifica o gerenciamento do memory target:
col COMPONENT for a20
col OPER_TYPE for a10
col OPER_MODE for a10
col PARAMETER for a20
col START_TIME for a20
col END_TIME for a20
select component, oper_type, oper_mode, parameter,initial_size, final_size,
to_char(start_time,'dd/mm/yyyy hh24:mi:ss') start_time,
to_char(end_time,'dd/mm/yyyy hh24:mi:ss') end_time
from v$memory_resize_ops;

-- query de verificar o tamanho das tabelas:
SELECT * FROM
(select SEGMENT_NAME, SEGMENT_TYPE, BYTES/1024/1024 MB, TABLESPACE_NAME from dba_segments
order by 3 desc ) WHERE SEGMENT_NAME = 'WORKFLOW';

column SEGMENT_NAME format a30
column SEGMENT_TYPE format a15
column TABLESPACE_NAME format a30
SELECT * FROM
(select
SEGMENT_NAME,
SEGMENT_TYPE,
BYTES/1024/1024/1024 GB,
TABLESPACE_NAME
from
dba_segments
order by 3 desc ) WHERE
ROWNUM <= 10;

-- schema que pode ser dropado
set linesize 200
set pagesize 60
col profile for a30
col USERNAME for a20
col ACCOUNT_STATUS for a10
SELECT username, account_status, created, lock_date, expiry_date
FROM dba_users
WHERE account_status != 'OPEN' and profile='PFL_ADM_APPLICATION';

Select sum(bytes/1024/1024/1024) GB from dba_segments where owner='IDOC';

-- QUOTAS 
SELECT TABLESPACE_NAME, USERNAME FROM DBA_TS_QUOTAS WHERE TABLESPACE_NAME ='PPMJASPERADMIN_PPMJAS';
SELECT TABLESPACE_NAME, USERNAME FROM DBA_TS_QUOTAS WHERE USERNAME ='PPMJASPERADMIN_PPMJAS';

-- comando para dar QUOTA:
ALTER USER PPMJASPERADMIN QUOTA UNLIMITED ON PPMJASPERADMIN_PPMJAS;

-- Portal Oracle - chamados: https://support.oracle.com/epmos/faces/SrHome?_afrLoop=138462885735673&_afrWindowMode=0&_adf.ctrl-state=1dqy6cdi9f_4

michael.oliveira.INDRA@petrobras.com.br
Dro#1527

fabiano.franzini.indra@petrobras.com.br
@2Ffmi78

renatasilva.indra@petrobras.com.br
relhCN001

-- Alocar espaço no disco de SWAP:

Verificar uso de memória:

npaa3728[root] ~ # free -h
total used free shared buff/cache available
Mem: 11G 3.8G 3.6G 3.3G 4.1G 4.1G
Swap: 2.0G 1.7G 331M
npaa3728[root] ~ #
npaa3728[root] ~ #

Baixar o uso de memória cache

npaa3728[root] ~ # sync; echo 1 > /proc/sys/vm/drop_caches; echo 2 > /proc/sys/vm/drop_caches; echo 3 > /proc/sys/vm/drop_caches

npaa3728[root] ~ # free -h
total used free shared buff/cache available
Mem: 11G 3.8G 4.3G 3.3G 3.5G 4.3G
Swap: 2.0G 1.7G 331M
npaa3728[root] ~ #

Desligar o swap

npaa3728[root] ~ # swapoff -a

npaa3728[root] ~ # vgs
VG #PV #LV #SN Attr VSize VFree
system 2 12 0 wz--n- 209.50g 23.75g

Identificando a partição de swap -- Nesse caso está dentro do VG system

npaa3728[root] ~ # cat /etc/fstab |grep swap
/dev/mapper/system-swap swap swap defaults 0 0

Comando para Extender o LVM && Comando para validar a expansão & Religando o Swap

npaa3728[root] ~ # lvextend -L 5G /dev/mapper/system-swap && mkswap /dev/mapper/system-swap && swapon -a

Size of logical volume system/swap changed from 2.00 GiB (512 extents) to 5.00 GiB (1280 extents).
Logical volume system/swap successfully resized.


mkswap: /dev/mapper/system-swap: warning: wiping old swap signature.
Setting up swapspace version 1, size = 5242876 KiB
no label, UUID=f126ac2e-f74f-48bf-8adc-f81b5225abeb

npaa3728[root] ~ # free -h
total used free shared buff/cache available
Mem: 11G 4.9G 2.2G 3.9G 4.5G 2.5G
Swap: 5.0G 0B 5.0G
npaa3728[root] ~ #

-- Instalação do orastatus
Instanciar variáveis de ambiente
OBS: se estiver no ExaCC, setar as variáveis de ambiente do CDB e setar a variável 
ORACLE_PDB_SID com o nome do PDB no qual o orastatus será instalado ou atualizado.

[oracle@srjcipdexa2cl3db01 ~]$ . c1n003d.env
[oracle@srjcipdexa2cl3db01 ~]$ export ORACLE_PDB_SID=FIND
 
Criar a pasta orastatus dentro de $ORACLE_BASE/admin/scripts
[oracle@srjcipdexa2cl3db01 ~]$ mkdir -p $ORACLE_BASE/admin/scripts/orastatus
 
Descompactar o conteúdo do zip deixando apenas a pasta catalogo no servidor 

unzip catalogo.zip

[oracle@srjcipdexa2cl3db01 orastatus]$ pwd
/u02/app/oracle/admin/scripts/orastatus
[oracle@srjcipdexa2cl3db01 orastatus]$ ls -lh
total 116K
drwxr-xr-x 2 oracle oinstall 4.0K Dec8 14:08 catalogo
 
Criar o arquivo orainstall.sh com o conteúdo do item 6 na pasta $ORACLE_BASE/admin/scripts/orastatus

vi orainstall.sh

#!/bin/bash

SQLPLUS=$ORACLE_HOME/bin/sqlplus
SQLPLUS_OPTS="-S"
SQLPLUS_USER="/ as sysdba"
SCRNAME=CatalogoPB
FILE=${​​​​SCRNAME}​​​​​​​​​​​.zip
DIR=catalogo
INSTSCR=instcatpb.sh
TMPFILE=/tmp/${​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​FILE}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​
DATE=$(date +"%Y-%m-%d-%H-%M-%S")
LOGFILE="orastatus-$ORACLE_SID-$DATE.log"
$SQLPLUS $SQLPLUS_OPTS $SQLPLUS_USER @${​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​DIR}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/${​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​SCRNAME}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​.sql ${​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​LOGFILE}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​ N

[oracle@srjcipdexa2cl3db01 orastatus]$ ./orainstall.sh
Executar o orainstall.sh 4 vezes informando as opções 1, 2 , 4 e 5 respectivamente.

Na opção 4 informar o nome do grupo CADUNIX da equipe. 
Equipe BD Oracle	GG_INFRA_BD_ORACLE
Equipe AB			GG_INFRA_SUPORTE_AB_DBA
Equipe C			GG_INFRA_SUPORTE_C_DBA

-- select versão ORASTATUS:
set lines 2000
select * from orastatus.tbl_versao;

-- script de BKP full network dell

RUN {
ALLOCATE CHANNEL CH5_FULL TYPE 'SBT_TAPE';
ALLOCATE CHANNEL CH6_FULL TYPE 'SBT_TAPE';
ALLOCATE CHANNEL CH7_FULL TYPE 'SBT_TAPE';
ALLOCATE CHANNEL CH8_FULL TYPE 'SBT_TAPE';

sql 'alter system archive log current';

BACKUP
DURATION 24:00
MINIMIZE TIME
CHECK LOGICAL
SECTION SIZE 32G
FULL
FILESPERSET 4
FORMAT '%d_datafile_full_%U_%t' TAG 'lgto-full-database' DATABASE FORCE;

sql 'alter system archive log current';
BACKUP
DURATION 01:00
MINIMIZE TIME
CHECK LOGICAL CURRENT CONTROLFILE FORMAT '%d_controlfile_pos_full_%U_%t' TAG 'lgto-pos-full-cf';
}


BEGIN
 DBMS_SCHEDULER.CREATE_JOB( 
 JOB_NAME => 'SCOTT.JOB_TEMP',
 JOB_TYPE => 'PLSQL_BLOCK', 
 JOB_ACTION => q'[BEGIN EXECUTE IMMEDIATE 'GRANT SELECT ON SCOTT.EMP TO MYUSER'; END;]',
 ENABLED => TRUE); 
 END; 
 /

-- compilar dados - direto no banco
@$ORACLE_HOME/rdbms/admin/utlrp.sql

-- local listener:
ALTER SYSTEM SET LOCAL_LISTENER='(ADDRESS=(PROTOCOl=TCP)(HOST=NPAA4209.petrobras.biz)(PORT=1521))' SCOPE=memory;

-- analisar jobs:

select * from dba_scheduler_job_run_details where job_name in ('JOB_DUPLO_MV_BIRH_FOTR_PRSE_RECENTE') ORDER BY LOG_DATE DESC;

select * from dba_scheduler_jobs where job_name in ('JOB_DUPLO_MV_BIRH_FOTR_PRSE_RECENTE');

BEGIN DBMS_SCHEDULER.RUN_JOB(job_name => '"AQG"."JOB_APP_REF_CLASSIFICA_COMPOS"', USE_CURRENT_SESSION => FALSE); END;

select OWNER, JOB_NAME from dba_scheduler_running_jobs where JOB_NAME like '%DBMS_JOB$_1069%';

select * from dba_scheduler_jobs where job_name in ('DBMS_JOB$_1069');

BEGIN DBMS_SCHEDULER.RUN_JOB(job_name => '"APR"."DBMS_JOB$_1069"', USE_CURRENT_SESSION => FALSE); END;

show parameter _optimizer_adaptive_plans;

select OWNER, JOB_NAME from dba_scheduler_running_jobs where JOB_NAME like '%JOB_MV_BI_PEDIDOS_GIAEP%';

pode ser que no horario de pico, no qual ocorre BKP, jobs, aponta alguma lentidão no momento do media recovery, em cenarios assim, o media recover fica com o status (transit), cenarios assim aponta o processo MRP0 como Waiting_LOG, desta forma o DDL do Target fica com zero. 


44212021-11-29 16:46:08 export TNS_ADMIN=/u01/app/oracle/admin/rman/tns
44222021-11-29 16:46:09 rman target / catalog rman_ab/Aslaj1i#001@rman.PETROBRAS.COM.BR


select EVENT_TIMESTAMP, ACTION_NAME, RMAN_SESSION_RECID,
RMAN_SESSION_STAMP, RMAN_OPERATION, RMAN_OBJECT_TYPE, RMAN_DEVICE_TYPE
from unified_audit_trail where ACTION_NAME like '%RMAN%' order by 1;

-- maquinas exacc:

PRD:
srjcipdexa1cl1db01
srjcipdexa1cl1db02
srjcipdexa1cl1db03
srjcipdexa1cl1db04
srjcipdexa1cl1db05
srjcipdexa1cl1db06
srjcipdexa1cl1db07
srjcipdexa1cl1db08
rjcipdexa1cl1-scan

DEV-TST-HMG:
srjcipdexa2cl3db01
srjcipdexa2cl3db02
srjcipdexa2cl3db03
srjcipdexa2cl3db04
rjcipdexa2cl3-scan

DG - RIO TIVIT:
srjcptiexa1cl4db01
srjcptiexa1cl4db02
srjcptiexa1cl4db03
srjcptiexa1cl4db04

DG - CCTI- SP
sspcctiexacl1db01
sspcctiexacl1db02
sspcctiexacl1db03
sspcctiexacl1db04


-- Analisar - locks no banco:
set linesize 400
select 'Feito a verificacao e o lock ja nao existe mais conforme evidencias abaixo :' from dual;
select substr(decode (s.lockwait, NULL,'** BLOCKER','== WAITER') || '...............',1,13) ||
substr(' - ' || s.sid || '..........',1,9) ||
substr(' - ' || s.username || '..........................',1,26) ||
substr(' - ' || 'kill -9 ' || p.spid || ' ............',1,25) ||
substr(' - ' || s.lockwait || '.............................',1,25) ||
substr(' - ' || 'kill -9 ' || p.spid || ' ...................',1,25) ||
substr(' - ' || s.status || '..........',1,11)||
substr(' - ' || s.sql_hash_value ||'........',1,30)||
substr(' - ' || s.last_call_et ||'........',1,30) as string_tt
from ( select unique raddr, saddr, request from gv$_lock where request > 0) waiter,
( select raddr, saddr, request from gv$_lock where request = 0) blocker,
gv$session s,
gv$process p
where waiter.raddr = blocker.raddr
and (waiter.saddr= s.saddr or blocker.saddr = s.saddr)
and (s.paddr = p.addr)
/

==============================================================================================================

select h.session_id Sessao_Travadora, ub.username Usuario_Travador ,w.session_id Sessao_Esperando, uw.username Usuario_Esperando,
w.lock_type,
h.mode_held,
w.mode_requested,
w.lock_id1,
w.lock_id2
from dba_locks w, dba_locks h, v$session ub, v$session uw
where h.blocking_others = 'Blocking'
and h.mode_held!= 'None'
and h.mode_held!= 'Null'
and h.session_id = ub.sid
and w.mode_requested != 'None'
and w.lock_type = h.lock_type
and w.lock_id1 = h.lock_id1
and w.lock_id2 = h.lock_id2
and w.session_id = uw.sid;

=====================================================================================================================

select vs.audsid audsid,
to_char(locks.sid) sid,
to_char(vs.serial#) serial,
vs.username oracle_user,
vs.osuser os_user,
vs.program program,
vs.module module,
vs.action action,
vs.process process,
decode(locks.lmode,
 1, NULL,
 2, 'Row Share',
 3, 'Row Exclusive',
 4, 'Share',
 5, 'Share Row Exclusive',
 6, 'Exclusive', 'None') lock_mode_held,
 decode(locks.request,
 1, NULL,
 2, 'Row Share',
 3, 'Row Exclusive',
 4, 'Share',
 5, 'Share Row Exclusive',
 6, 'Exclusive', 'None') lock_mode_requested,
 decode(locks.type,
 'MR', 'Media Recovery',
 'RT', 'Redo Thread',
 'UN', 'User Name',
 'TX', 'Transaction',
 'TM', 'DML',
 'UL', 'PL/SQL User Lock',
 'DX', 'Distributed Xaction',
 'CF', 'Control File',
 'IS', 'Instance State',
 'FS', 'File Set',
 'IR', 'Instance Recovery',
 'ST', 'Disk Space Transaction',
 'TS', 'Temp Segment',
 'IV', 'Library Cache Invalidation',
 'LS', 'Log Start or Log Switch',
 'RW', 'Row Wait',
 'SQ', 'Sequence Number',
 'TE', 'Extend Table',
 'TT', 'Temp Table',
 locks.type) lock_type,
 objs.owner object_owner,
 objs.object_name object_name,
 objs.object_type object_type,
 round( locks.ctime/60, 2 ) lock_time_in_minutes
from v$session vs,
 v$lock locks,
 all_objects objs,
 all_tables tbls
where locks.id1 = objs.object_id
 and vs.sid = locks.sid
 and objs.owner = tbls.owner
 and objs.object_name =tbls.table_name
 and objs.owner != 'SYS'
 and locks.type = 'TM'
 order by lock_time_in_minutes;
 
===============================================================================================================================

select
 c.owner,
 c.object_name,
 c.object_type,
 b.sid,
 b.serial#,
 b.status,
 b.osuser,
 b.machine
from
 v$locked_object a ,
 v$session b,
 dba_objects c
where
 b.sid = a.session_id
and
 a.object_id = c.object_id;

-- select para verificar o select que está ocasionando o lock na sessão:
select /*+ ORDERED USE_NL(st) */ sql_text
from v$session ses,
 v$sqltext st
where st.address = ses.sql_address
 and st.hash_value=ses.sql_hash_value
 and ses.sid= &sid
order by piece;



-- comando para salvar os dados do patch do banco
opatch lsinventory >> opatch_lsinv.txt

-- erros alert pelo adrci
adrci
show homes
set home /diag/intancia.......

-- comando para verificar os 10 ultimos erros ORA no adrci
show incident -last 10

-- comando para salvar o alert do adrci
adrci> ips pack incident 145679 in /tmp

-- Script para o resync logando no catalogo do standby na primaria. 

crontab -e 07 * ** * /u01/app/oracle/admin/rman/scripts/resync.sh >/tmp/resyc.log 2>&1

export ORACLE_HOME=/u01/app/oracle/product/19/db_1
export ORACLE_SID=rcaplabp08b
export RMAN_LOGFILE=/u01/app/oracle/admin/rman/scripts/log/aplabp08logRman${ORACLE_BACKUP_TYPE}-`date +"%d-%m-%Y_%H.%M"`.log


RMAN_BKP_EXITCOD=$?

/u01/app/oracle/product/19/db_1/bin/rman <<EOF

spool log to '${RMAN_LOGFILE}' append ;
connect target /
connect catalog rman_stby/qwerasdf#357@rman

set echo on;

resync catalog;

EOF


RMAN_BKP_EXITCOD=$?

/u01/app/oracle/product/19/db_1/bin/rman <<EOF

spool log to '${RMAN_LOGFILE}' append ;

connect target /
connect catalog rman_stby_bkp/qwerasdf#357@rman_bkp

set echo on;

resync catalog;

EOF


export ORACLE_SID=rcaplabpb
export RMAN_LOGFILE=/u01/app/oracle/admin/rman/scripts/log/aplabplogRman${ORACLE_BACKUP_TYPE}-`date +"%d-%m-%Y_%H.%M"`.log


RMAN_BKP_EXITCOD=$?

/u01/app/oracle/product/19/db_1/bin/rman <<EOF

spool log to '${RMAN_LOGFILE}' append ;
connect target /
connect catalog rman_stby/qwerasdf#357@rman

set echo on;

resync catalog;

EOF


RMAN_BKP_EXITCOD=$?

/u01/app/oracle/product/19/db_1/bin/rman <<EOF

spool log to '${RMAN_LOGFILE}' append ;

connect target /
connect catalog rman_stby_bkp/qwerasdf#357@rman_bkp

set echo on;

resync catalog;

EOF

-- query para verificar objetos no banco:
select OWNER,LAST_DDL_TIME,TIMESTAMP from dba_objects where OBJECT_NAME = 'JOB_MV_BIIN_TEXTO_LONGO_OBJETO';
select OWNER from dba_objects where OBJECT_NAME = 'LOB_REENVIO_MENSAGEM_REME_NM_D';
select OWNER,OBJECT_TYPE,LAST_DDL_TIME,TIMESTAMP from dba_objects where OBJECT_NAME = 'MV_BIDU_FORCA_TRABALHO';

-- query para verificar todas as mviews no banco:
select * from all_mviews
select OWNER,MVIEW_NAME,QUERY,REFRESH_MODE from all_mviews where MVIEW_NAME='MV_PROD_COMPLEMENTO';

-- query para verificar tabelas no banco:
select OWNER,TABLE_NAME from DBA_TABLES where TABLE_NAME like'XLIGMESSAG0_';

-- query para verificar DBA_TAB_PRIVS no banco:
SELECT * FROM DBA_TAB_PRIVS WHERE table_name= 'SYN_BICTR_CONTRATO';
select * from dba_tab_privs where table_name ='MV_BICTR_CONTRATO_FISCAL' and owner='OG94_APLICACAO';
select * from dba_tab_privs where owner='OG94_APLICACAO';

-- senha do sys para todos os containers exacc

owner: sys
Senha: "ENtub4d0s#_"

Senha: E#x46C_FaU

-- analisar o processo do RMAN que esteja running:
set lines 2000 pages 2000
col status for a10
col operation for a12
select SID,OPERATION,STATUS,MBYTES_PROCESSED,START_TIME,END_TIME,INPUT_BYTES/1024/1024 INPUT_MB,OUTPUT_BYTES/1024/1024 OUTPUT_MB from V$RMAN_STATUS where status like 'RUNNING%';

alter session set nls_date_format='dd/mm/yyyy hh24:mi:ss';
set lines 400
col opname format a40
set pages 120
SELECT sid, serial#, opname, sofar, totalwork, round((totalwork-sofar)*8192/1024/1024/1024) GB_rest,
round(sofar/totalwork*100,2) "% Complete", time_remaining, sysdate + TIME_REMAINING/3600/24 end_at
FROM v$session_longops
WHERE opname LIKE 'RMAN:%'
-- AND opname NOT LIKE 'RMAN: aggregate%'
AND sofar <> totalwork
AND totalwork != 0
order by 8;

col i for 9
col sid for 99999
col serial# for 9999999
col username for a20
col osuser for a20
col machine for a20
col sql_start for 999999999
col CN for 99
col LCK for a3
SELECT inst_id i, sid, serial#, username, osuser, replace(machine,'.sky.local','') machine, status, last_call_et last_call, (sysdate-sql_exec_start)*24*60*60 sql_start,
to_char(logon_time,'dd/mm/yyyy hh24:mi') logon_time, sql_id, sql_child_number as CN, decode(lockwait,null,'','YES') as lck, event
FROM gv$session
WHERE username is not null
and (status='ACTIVE' or event='SQL*Net break/reset to client')
AND event not in ('class slave wait','Streams AQ: waiting for messages in the queue')
order by last_call_et DESC;

alter system set result_cache_max_size=0; 
SQL> show parameter result_cache_max_size

NAME TYPEVALUE
------------------------------------ ----------- ------------------------------
result_cache_max_sizebig integer 70784K
SQL>
SQL>
SQL> alter system set result_cache_max_size=0 scope=both sid='*';

System altered.

SQL>
SQL> show parameter result_cache_max_size

NAME TYPEVALUE
------------------------------------ ----------- ------------------------------
result_cache_max_sizebig integer 0
SQL>


-- verificar os privilegios dentro da role:
select * from ROLE_SYS_PRIVS where ROLE = 'RADM_USER';

-- pegar a senha criptografada
select name, password from sys.user$ where name = '';

-- caminho do toad: 
C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Quest Software\Toad for Oracle 15.0


-- atualização do opatch 
unzip -d . /u01/app/oracle/diag/patch/opatch/p6880880_190000_Linux-x86-64.zip

-- instalação do grid:


-- atualização grid
/u01/app/19/grid/OPatch/opatchauto apply /u01/app/oracle/diag/patch/GI/33509923 -oh /u01/app/19/grid -analyze

/u01/app/19/grid/OPatch/opatchauto apply /u01/app/oracle/diag/patch/GI/33509923 -oh /u01/app/19/grid 


-- atualização oracle
chmod -R 777 patch
/u01/app/oracle/diag/patch/GI/33509923/33515361

/u01/app/oracle/diag/patch/GI/33509923/33529556

logar com root

cd /u01/app/oracle/diag 

chmod -R 777 patch

/u01/app/oracle/diag/patch/jdk/

unzip p33497160_190000_Linux-x86-64.zip

logado com oracle:

cd /u01/app/oracle/diag/patch/jdk/33497160 

opatch apply

/u01/app/oracle/diag/patch/ojvm/

unzip p33561310_190000_Linux-x86-64.zip

/u01/app/oracle/diag/patch/ojvm

unzip p33561310_190000_Linux-x86-64.zip

/u01/app/oracle/diag/patch/ojvm/33561310

opatch apply

-- 
/u01/app/oracle/product/19/db_1/OPatch $ ./datapatch -verbose

crsctl status res -t | grep db

-- query de validação de patch aplicado:
select patch_id, status, description from dba_registry_sqlpatch;

-- comando para acertar o serviço roothas.sh
[root] /u01/app/19/grid/crs/install # ./roothas.sh -init
/u01/app/19/grid/crs/install # ./roothas.sh -postpatch
[root] /u01/app/19/grid/bin # ./crsctl start has

-- ponteirar troca de senha no sqlserver
USE SPMRO_INT_REDUC
GO

sp_change_users_login 'update_one','IntelaTracInstall','IntelaTracInstall'
go

-- INSTALAR/ATUALIZAR AHF-TFA 

baixar a midia: https://support.oracle.com/epmos/faces/DocContentDisplay?_afrLoop=284085724271298&id=2832630.1&_afrWindowMode=0&_adf.ctrl-state=sz1p9dxas_4

Logado com o root, validar a atual versão: tfactl status

Criar dentro do /tmp a pasta AHF e dar um chmod -R 777 

dentro da pasta: /tmp/AHF/ realizar o unzip com a midia. Ex: unzip AHF-LINUX_v21.4.2.zip

Depois startar o ahf_setup:

[root@lavadb03 AHF]# pwd
/tmp/AHF
[root@lavadb03 AHF]#
[root@lavadb03 AHF]# ./ahf_setup

Colocar Y nos campos citados e no final do procedimento N para que não seja feito o upload automaticamente. Validar novamente: tfactl status

-- configurar a entrada principal do s.o - banco
da um cd /home/oracle
vi .bash_profile

-- oracle private database
https://www.oracle.com/br/technical-resources/article/idm/virtual-private-databas.html

-- Comando para coletar evidências em Servidor Oracle
select host_name,instance_name from gv$instance;
select id_grupo,profile from orastatus.tbl_grupo_adm where id_grupo='GG_INFRA_SUPORTE_AB_DBA';


-- acessos GOMM:
-- usuários e senha para acessos
Root => ishiyaK1
ORACLE => Or@cle00
SYS => GOM#12ora

--Manabu:
SR 3-29083915801 : root.sh failed after deconfig node

S2783233

+DG_DAT01/INTEGRAT/PARAMETERFILE/spfile.277.1069683325

create spfile='+DG_DAT01/SPFD/PARAMETERFILE/spfile.ora' from pfile='/u01/app/oracle/product/19/db_1/dbs/initspfd.ora';

create spfile='+DG_DAT01/APLABT/spfileaplabt.ora' from pfile='/u01/app/oracle/product/19/db_1/dbs/michael.ora';

-- script de deleção de archive:

#!/bin/bash
export NLS_DATE_FORMAT="dd/mm/yyyy hh24:mi:ss"
export ORACLE_BASE=/u01/app/oracle
export ORACLE_HOME=/u01/app/oracle/product/11.2.0.4/dbhome_1
export PATH=$ORACLE_HOME/bin:$PATH


for i in
do
export ORACLE_SID=$i
sqlplus -S / as sysdba <<EOF
set pagesize 0
set feedback off
set long 1000
set termout off
set serveroutput off
spool /export/home/oracle/scripts/limpa_arch.sql
select 'delete noprompt archivelog until sequence '||max(a.sequence#)||' thread '||thread#||';'
from gv\$archived_log a, v\$database b
where a.applied='YES'
and b.RESETLOGS_CHANGE#=a.RESETLOGS_CHANGE#
group by thread#;
spool off
exit
EOF

DATABKP=`date +%Y%m%d%H%M%S`
rman target / log=/export/home/oracle/scripts/log/limpa_foreign_${ORACLE_SID}_${DATABKP}.log @/export/home/oracle/scripts/limpa_arch.sql

done

-- verificar datafiles corrompidos:

select * from V$DATABASE_BLOCK_CORRUPTION;

SELECT tablespace_name, segment_type, owner, segment_name
FROM dba_extents
 WHERE file_id = 18
 and 91880 between block_id AND block_id + blocks - 1;
 
 
 SELECT e.owner, e.segment_type, e.segment_name, e.partition_name, c.file#
, greatest(e.block_id, c.block#) corr_start_block#
, least(e.block_id+e.blocks-1, c.block#+c.blocks-1) corr_end_block#
, least(e.block_id+e.blocks-1, c.block#+c.blocks-1)
- greatest(e.block_id, c.block#) + 1 blocks_corrupted
, null description
FROM dba_extents e, v$database_block_corruption c
WHERE e.file_id = c.file#
AND e.block_id <= c.block# + c.blocks - 1
AND e.block_id + e.blocks - 1 >= c.block#;
SELECT s.owner, s.segment_type, s.segment_name, s.partition_name, c.file#
, header_block corr_start_block#
, header_block corr_end_block#
, 1 blocks_corrupted
, 'Segment Header' description
FROM dba_segments s, v$database_block_corruption c
WHERE s.header_file = c.file#
AND s.header_block between c.block# and c.block# + c.blocks - 1;
SELECT null owner, null segment_type, null segment_name, null partition_name, c.file#
, greatest(f.block_id, c.block#) corr_start_block#
, least(f.block_id+f.blocks-1, c.block#+c.blocks-1) corr_end_block#
, least(f.block_id+f.blocks-1, c.block#+c.blocks-1)
- greatest(f.block_id, c.block#) + 1 blocks_corrupted
, 'Free Block' description
FROM dba_free_space f, v$database_block_corruption c
WHERE f.file_id = c.file#
AND f.block_id <= c.block# + c.blocks - 1
AND f.block_id + f.blocks - 1 >= c.block#
order by file#, corr_start_block#;


-- ORA-00059: Maximum Number Of DB_FILES Exceeded
ALTER TABLESPACE TS_LO_DATA add datafile '+DATA' size 10g autoextend on next 500M
*
ERROR at line 1:
ORA-00059: maximum number of DB_FILES exceeded

show parameter db_files

select count(*) from dba_data_files;

alter system set db_files=5000 scope=spfile sid='*';

Realizar o stop/start da base;

-- verificar o status da TBS:
SELECT tablespace_name, encrypted, status FROM dba_tablespaces where tablespace_name like '%MOB_LOB%';
SELECT tablespace_name, encrypted, status FROM dba_tablespaces where tablespace_name like '%CCQP_I_01%';

set lines 2000
SELECT t.tablespace
,t.totalspace AS " Totalspace(MB)"
,round((t.totalspace - fs.freespace), 2) AS "Used Space(MB)"
,fs.freespace AS "Freespace(MB)"
,round(((t.totalspace - fs.freespace) / t.totalspace) * 100, 2) AS "% Used"
,round((fs.freespace / t.totalspace) * 100, 2) AS "% Free"
FROM (SELECT round(SUM(d.bytes) / (1024 * 1024)) AS totalspace
,d.tablespace_name tablespace
FROM dba_data_files d
GROUP BY d.tablespace_name) t
,(SELECT round(SUM(f.bytes) / (1024 * 1024)) AS freespace
,f.tablespace_name tablespace
FROM dba_free_space f
GROUP BY f.tablespace_name) fs
WHERE t.tablespace = fs.tablespace and t.tablespace like '%CCQP_I_01%'
ORDER BY t.tablespace;
=======================================================================================================================================
SELECT m.tablespace_name, ROUND(m.used_percent, 2), ROUND((m.tablespace_size - m.used_space)*t.block_size/1024/1024, 3) mb_free
FROM dba_tablespace_usage_metrics m,
dba_tablespaces t,
v$parameter p
WHERE p.name='statistics_level' and p.value!='BASIC'
AND t.contents NOT IN ('TEMPORARY', 'UNDO') AND t.tablespace_name = m.tablespace_name
and t.TABLESPACE_NAME like '%CCQP_D_01%';

-- verificar os dados da TBS:
select owner, segment_type, sum(bytes/1024/1024/1024) GB from dba_segments where tablespace_name in ('MOB_LOB')
group by owner, segment_type;

select owner, segment_name, segment_type from dba_segments where tablespace_name='CCQP';

-- Verificar o nome dos datafiles da tbs:
select file_name from dba_data_files WHERE TABLESPACE_NAME LIKE '%APWB_I_01%';

-- Dropar as tbs:
drop tablespace SCH_IAET_DADOS INCLUDING CONTENTS AND DATAFILES; 
drop tablespace SCH_IAET_INDICES INCLUDING CONTENTS AND DATAFILES;
drop tablespace RAMS_L_01 INCLUDING CONTENTS AND DATAFILES;

-- Verificar as cotas e permissões na tbs:
SELECT TABLESPACE_NAME, USERNAME FROM DBA_TS_QUOTAS WHERE TABLESPACE_NAME ='W1LI_TR_D_01';
SELECT TABLESPACE_NAME, USERNAME FROM DBA_TS_QUOTAS WHERE USERNAME ='W1LI_TR';

-- verificar TBS sem segmentos:
select tablespace_name from dba_tablespaces where tablespace_name not in (select distinct tablespace_name from dba_segments) order by 1;

-- mover os indices de uma tbs. Para aonde vai: "TABLESPACE CCQP_I_01"
select 'ALTER INDEX '||owner||'.'||SEGMENT_NAME||' REBUILD ONLINE TABLESPACE CCQP_I_01 parallel 8 nologging;' 
from dba_segments where tablespace_name='CCQP_D_01' and segment_type = 'INDEX'; 

-- verificar indices inutilizavel:
select 'alter index '||owner||'.'||index_name||' rebuild parallel 8 nologging;'
from dba_indexes
WHERE OWNER like 'CCQP' AND STATUS='UNUSABLE';

select 'alter index '||owner||'.'||index_name||' parallel 1 logging;'
from dba_indexes
WHERE OWNER like 'CCQP'
and index_type <> 'LOB'
AND degree <> 1;

-- verificar o timezone:
SELECT * FROM v$timezone_file;

@?/rdbms/admin/utltz_countstats.sql
@?/rdbms/admin/utltz_countstar.sql
@?/rdbms/admin/utltz_upg_check.sql
### RESTORE POINT
CREATE RESTORE POINT ANTES_TIMEZONE GUARANTEE FLASHBACK DATABASE;
@?/rdbms/admin/utltz_upg_apply.sql
SELECT * FROM v$timezone_file;

-- maiores ofensores pga - sessões ativas:
COLUMN alme HEADING "Allocated MB" FORMAT 99999D9
COLUMN usme HEADING "Used MB" FORMAT 99999D9
COLUMN frme HEADING "Freeable MB" FORMAT 99999D9
COLUMN mame HEADING "Max MB" FORMAT 99999D9
COLUMN username FORMAT a15
COLUMN program FORMAT a22
COLUMN sid FORMAT a5
COLUMN spid FORMAT a8
SET LINESIZE 300
SELECT s.username, SUBSTR(s.sid,1,5) sid, p.spid, logon_time,
SUBSTR(s.program,1,22) program , s.process pid_remote,
s.status,
ROUND(pga_used_mem/1024/1024) usme,
ROUND(pga_alloc_mem/1024/1024) alme,
ROUND(pga_freeable_mem/1024/1024) frme,
ROUND(pga_max_mem/1024/1024) mame
FROM gv$session s,gv$process p
WHERE p.addr=s.paddr and STATUS='ACTIVE'
ORDER BY pga_max_mem,logon_time;

SELECT a.sid
,sql_text
FROM gv$session a
,gv$sql b
WHERE b.sql_id = a.sql_id
AND sid IN (2462)
ORDER BY sid;	

RMAN.PETROBRAS.COM.BR =
(DESCRIPTION =
(ADDRESS =
(PROTOCOL = TCP)
(HOST = viprmanp.petrobras.com.br)
(PORT = 1521))
(CONNECT_DATA =(SERVICE_NAME = RMANP.PETROBRAS.COM.BR)))

RMAN_BKP.PETROBRAS.COM.BR =
(DESCRIPTION =
(ADDRESS =
(PROTOCOL = TCP)
(HOST = viprmanc.petrobras.com.br)
		(PORT = 1521))
(CONNECT_DATA =(SERVICE_NAME = RMANC.PETROBRAS.COM.BR)))


00:00:00			24:00:00
00:00:00	07:00:00	20:00:00	24:00:00
00:00:00	07:00:00	20:00:00	24:00:00
00:00:00	07:00:00	20:00:00	24:00:00
00:00:00	07:00:00		




#!/bin/bash

SQLPLUS=$ORACLE_HOME/bin/sqlplus
SQLPLUS_OPTS="-S"
SQLPLUS_USER="/ as sysdba"
SCRNAME=CatalogoPB
FILE=${​​SCRNAME}​​​​​​​​​.zip
DIR=catalogo
INSTSCR=instcatpb.sh
TMPFILE=/tmp/${​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​FILE}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​
DATE=$(date +"%Y-%m-%d-%H-%M-%S")
LOGFILE="orastatus-$ORACLE_SID-$DATE.log"
$SQLPLUS $SQLPLUS_OPTS $SQLPLUS_USER @${​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​DIR}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/${​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​SCRNAME}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​.sql ${​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​LOGFILE}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​ N


Prezados,

Informo que o servidor NPAA9309 já está em produção.

Verifiquei que o servidor está ainda fora da monitoração. Favor verificar Monitoração e Backup para os servidores NPAA9309.

Informações para o backup
Instância: NPAA9309\PMRO_REPARP
Banco de dados: SPMRO_INT_REPAR

Solicito atualização de BDGC conforme sugestão a seguir:

NPAA9309
Status: Operação
Detalhamento da função: Intelatrac - Servidor SQL Server (Repar)

3ct5nbk5bpd8v
3ct5nbk5bpd8v


Pegamos o SQL_ID: 3ct5nbk5bpd8v e nele é pontuado recomendações de criação de indices no qual é possivel uma estimativa de melhoria de 66.03%:
 
    create index SGCD.IDX$$_529860001 on SGCD.ALTERACAO_SGCD(TRIM(UPPER("ALSG_T
    X_OBSERVACAO")),"ALSG_CD_ID");
 
    create index CCMULTI_OWNER.IDX$$_529860002 on
    CCMULTI_OWNER.CC_ALTERACAO_COTA("ALCO_NR_CONTRATO");

    create index CCMULTI_OWNER.IDX$$_529860003 on
    CCMULTI_OWNER.CC_ALTERACAO_COTA("CLIE_CD_ID","FORN_CD_ID","TISR_CD_ID","ALC
    O_DT_INI_VIGENCIA");

    create index CCMULTI_OWNER.IDX$$_529860006 on
    CCMULTI_OWNER.CC_COTA_DIA("CLIE_CD_ID","FORN_CD_ID","TISR_CD_ID","COTD_DT_C
    OTA_DIA");

    create index CCMULTI_OWNER.IDX$$_529860007 on
    CCMULTI_OWNER.CC_MUNICIPIO("ESTA_CD_ID"||'|'||"MUNI_CD_ID");

Recomendamos analise do time de desenvolvimento sobre esta pauta. 

-- query para verificar o tamanho do banco:
WITH
sizes AS (
SELECT /*+MATERIALIZE NO_MERGE*/ /* 1f.83 */
 'Data' file_type,
 SUM(bytes) bytes
FROM v$datafile
 UNION ALL
SELECT 'Temp' file_type,
 SUM(bytes) bytes
FROM v$tempfile
 UNION ALL
SELECT 'Log' file_type,
 SUM(bytes) * MAX(members) bytes
FROM v$log
 UNION ALL
SELECT 'Control' file_type,
 SUM(block_size * file_size_blks) bytes
FROM v$controlfile
),
dbsize AS (
SELECT /*+MATERIALIZE NO_MERGE*/ /* 1f.83 */
 'Total' file_type,
 SUM(bytes) bytes
FROM sizes
)
SELECT d.dbid,
 d.name db_name,
 s.file_type,
 s.bytes,
 CASE
 WHEN s.bytes > POWER(10,15) THEN ROUND(s.bytes/POWER(10,15),3)||' P'
 WHEN s.bytes > POWER(10,12) THEN ROUND(s.bytes/POWER(10,12),3)||' T'
 WHEN s.bytes > POWER(10,9) THEN ROUND(s.bytes/POWER(10,9),3)||' G'
 WHEN s.bytes > POWER(10,6) THEN ROUND(s.bytes/POWER(10,6),3)||' M'
 WHEN s.bytes > POWER(10,3) THEN ROUND(s.bytes/POWER(10,3),3)||' K'
 WHEN s.bytes > 0 THEN s.bytes||' B' END approx
FROM v$database d,
 sizes s
 UNION ALL
SELECT d.dbid,
 d.name db_name,
 s.file_type,
 s.bytes,
 CASE
 WHEN s.bytes > POWER(10,15) THEN ROUND(s.bytes/POWER(10,15),3)||' P'
 WHEN s.bytes > POWER(10,12) THEN ROUND(s.bytes/POWER(10,12),3)||' T'
 WHEN s.bytes > POWER(10,9) THEN ROUND(s.bytes/POWER(10,9),3)||' G'
 WHEN s.bytes > POWER(10,6) THEN ROUND(s.bytes/POWER(10,6),3)||' M'
 WHEN s.bytes > POWER(10,3) THEN ROUND(s.bytes/POWER(10,3),3)||' K'
 WHEN s.bytes > 0 THEN s.bytes||' B' END approx
FROM v$database d,
 dbsize s;
	 
-- MySql --comandos basicos 
para entrar: sudo mysql
verificar bases: show databases;
acessar banco: USE dbname
comando para baixar e subir bases:
sudo /etc/init.d/mysqld stop
sudo /etc/init.d/mysqld start
acessar tables: show tables
consulta: SELECT 21 * 2 AS significado_de_vida;
execução de script: mysql -u nome de usuário -p nome_do_bd <mysqlscript.txt> output.txt
link: https://www.linuxforce.com.br/comandos-linux/comandos-linux-comando-mysql/

-- banco em restore em sql server:

restore database TESTE with recovery

-- analisar ACL:

############# 8.1.12
SET ECHO ON TIME ON TIMI ON LINES 200
SPOOL ${ORACLE_BASE}/admin/$ORACLE_SID/log/${ORACLE_SID}_NET_DEPENDENCIES_PRE_19c_UPGRD.log
SELECT *
FROM DBA_DEPENDENCIES
WHERE REFERENCED_NAME IN ('UTL_TCP'
,'UTL_SMTP'
,'UTL_MAIL'
,'UTL_HTTP'
,'UTL_INADDR'
,'DBMS_LDAP')
AND OWNER NOT IN ('SYS'
,'PUBLIC'
,'ORDPLUGINS');
SPOOL OFF

set serveroutput on size 999999 pages 0 head off long 999999 feed off
SPOOL ${ORACLE_BASE}/admin/${ORACLE_SID}/log/${ORACLE_SID}_NET_ACL_PRE_19c_UPGRD.log
DECLARE
L_LAST_ACL DBA_NETWORK_ACLS.ACL%TYPE := '~';
L_LAST_PRINCIPAL DBA_NETWORK_ACL_PRIVILEGES.PRINCIPAL%TYPE := '~';
L_LAST_PRIVILEGE DBA_NETWORK_ACL_PRIVILEGES.PRIVILEGE%TYPE := '~';
L_LAST_HOST DBA_NETWORK_ACLS.HOST%TYPE := '~';
FUNCTION GET_TIMESTAMP(P_TIMESTAMP IN TIMESTAMP WITH TIME ZONE)
RETURN VARCHAR2 AS
L_RETURN VARCHAR2(32767);
BEGIN
IF P_TIMESTAMP IS NULL THEN
RETURN 'NULL';
END IF;
RETURN 'TO_TIMESTAMP_TZ(''' || TO_CHAR(P_TIMESTAMP
,'DD-MON-YYYY HH24:MI:SS.FF TZH:TZM') || ''',''DD-MON-YYYY HH24:MI:SS.FF
TZH:TZM'')';
END;
BEGIN
FOR I IN (SELECT A.ACL
,A.HOST
,A.LOWER_PORT
,A.UPPER_PORT
,B.PRINCIPAL
,B.PRIVILEGE
,B.IS_GRANT
,B.START_DATE
,B.END_DATE
FROM DBA_NETWORK_ACLS A
JOIN DBA_NETWORK_ACL_PRIVILEGES B
ON A.ACL = B.ACL
ORDER BY A.ACL
,A.HOST
,A.LOWER_PORT
,A.UPPER_PORT)
LOOP
IF L_LAST_ACL <> I.ACL THEN
-- First time we've seen this ACL, so create a new one.
L_LAST_HOST := '~';
DBMS_OUTPUT.PUT_LINE('-- -------------------------------------------------');
DBMS_OUTPUT.PUT_LINE('-- ' || I.ACL);
DBMS_OUTPUT.PUT_LINE('-- -------------------------------------------------');
DBMS_OUTPUT.PUT_LINE('BEGIN');
DBMS_OUTPUT.PUT_LINE(' DBMS_NETWORK_ACL_ADMIN.drop_acl (');
DBMS_OUTPUT.PUT_LINE(' acl => ''' || I.ACL ||
''');');
DBMS_OUTPUT.PUT_LINE(' COMMIT;');
DBMS_OUTPUT.PUT_LINE('END;');
DBMS_OUTPUT.PUT_LINE('/');
DBMS_OUTPUT.PUT_LINE(' ');
DBMS_OUTPUT.PUT_LINE('BEGIN');
DBMS_OUTPUT.PUT_LINE(' DBMS_NETWORK_ACL_ADMIN.create_acl (');
DBMS_OUTPUT.PUT_LINE(' acl => ''' || I.ACL ||
''',');
DBMS_OUTPUT.PUT_LINE(' description => ''' || I.ACL ||
''',');
DBMS_OUTPUT.PUT_LINE(' principal => ''' ||
I.PRINCIPAL || ''',');
DBMS_OUTPUT.PUT_LINE(' is_grant => ' || I.IS_GRANT || ',');
DBMS_OUTPUT.PUT_LINE(' privilege => ''' ||
I.PRIVILEGE || ''',');
DBMS_OUTPUT.PUT_LINE(' start_date => ' ||
GET_TIMESTAMP(I.START_DATE) || ',');
DBMS_OUTPUT.PUT_LINE(' end_date => ' ||
GET_TIMESTAMP(I.END_DATE) || ');');
DBMS_OUTPUT.PUT_LINE(' COMMIT;');
DBMS_OUTPUT.PUT_LINE('END;');
DBMS_OUTPUT.PUT_LINE('/');
DBMS_OUTPUT.PUT_LINE(' ');
L_LAST_ACL := I.ACL;
L_LAST_PRINCIPAL := I.PRINCIPAL;
L_LAST_PRIVILEGE := I.PRIVILEGE;
END IF;
IF L_LAST_PRINCIPAL <> I.PRINCIPAL
OR (L_LAST_PRINCIPAL = I.PRINCIPAL AND
L_LAST_PRIVILEGE <> I.PRIVILEGE) THEN
-- Add another principal to an existing ACL.
DBMS_OUTPUT.PUT_LINE('BEGIN');
DBMS_OUTPUT.PUT_LINE(' DBMS_NETWORK_ACL_ADMIN.add_privilege (');
DBMS_OUTPUT.PUT_LINE(' acl => ''' || I.ACL ||
''',');
DBMS_OUTPUT.PUT_LINE(' principal => ''' || I.PRINCIPAL ||
''',');
DBMS_OUTPUT.PUT_LINE(' is_grant => ' || I.IS_GRANT || ',');
DBMS_OUTPUT.PUT_LINE(' privilege => ''' || I.PRIVILEGE ||
''',');
DBMS_OUTPUT.PUT_LINE(' start_date => ' ||
GET_TIMESTAMP(I.START_DATE) || ',');
DBMS_OUTPUT.PUT_LINE(' end_date => ' ||
GET_TIMESTAMP(I.END_DATE) || ');');
DBMS_OUTPUT.PUT_LINE(' COMMIT;');
DBMS_OUTPUT.PUT_LINE('END;');
DBMS_OUTPUT.PUT_LINE('/');
DBMS_OUTPUT.PUT_LINE(' ');
L_LAST_PRINCIPAL := I.PRINCIPAL;
L_LAST_PRIVILEGE := I.PRIVILEGE;
END IF;
IF L_LAST_HOST <>
I.HOST || ':' || I.LOWER_PORT || ':' || I.UPPER_PORT THEN
DBMS_OUTPUT.PUT_LINE('BEGIN');
DBMS_OUTPUT.PUT_LINE(' DBMS_NETWORK_ACL_ADMIN.assign_acl (');
DBMS_OUTPUT.PUT_LINE(' acl => ''' || I.ACL ||
''',');
DBMS_OUTPUT.PUT_LINE(' host => ''' || I.HOST ||
''',');
DBMS_OUTPUT.PUT_LINE(' lower_port => ' ||
NVL(TO_CHAR(I.LOWER_PORT)
,'NULL') || ',');
DBMS_OUTPUT.PUT_LINE(' upper_port => ' ||
NVL(TO_CHAR(I.UPPER_PORT)
,'NULL') || ');');
DBMS_OUTPUT.PUT_LINE(' COMMIT;');
DBMS_OUTPUT.PUT_LINE('END;');
DBMS_OUTPUT.PUT_LINE('/');
DBMS_OUTPUT.PUT_LINE(' ');
L_LAST_HOST := I.HOST || ':' || I.LOWER_PORT || ':' ||
I.UPPER_PORT;
END IF;
END LOOP;
END;
/
SPOOL OFF
set head on pages 1000;

-- analisar - roles

set long 9999999
select dbms_metadata.get_ddl('USER','U417')||';' from dual;
SELECT DBMS_METADATA.GET_GRANTED_DDL('ROLE_GRANT','U417')||';' FROM DUAL;
SELECT DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','U417')||';' FROM DUAL;
SELECT DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','U417') ||';' FROM DUAL; 

SELECT 'GRANT SELECT ON ' || OWNER || '.' || OBJECT_NAME || ' TO BISBS;' FROM DBA_OBJECTS WHERE OWNER='BIIN' AND OBJECT_TYPE IN ('TABLE', 'VIEW', 'SEQUENCE');

select object_type, count(*) from dba_objects where owner = 'BISBS' group by object_type order by object_type;

select ROLE, ROLE_ID, AUTHENTICATION_TYPE, EXTERNAL_NAME from DBA_ROLES where role= 'R_USR_UNC9_DRL';

-- select pra ver o que tem dentro da role:
set long 9999999
SELECT DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','REDM_GPCS_DRL') ||';' FROM DUAL;

-- Verificar Roles/Privilégios de um usuário
SELECT * FROM DBA_ROLE_PRIVS WHERE GRANTEE = 'USER';

-- aumentar a velocidade do rman
alter system set large_pool_size=256m scope=both;

-- aumentar a velocidade do exp/imp
alter system set shared_pool_size=256m scope=both;

-- drop job: 

BEGIN DBMS_SCHEDULER.drop_JOB(JOB_NAME => 'UE6LX.JOB_PROC_MACRO_AGENDA');END;
/
BEGIN DBMS_SCHEDULER.drop_JOB(JOB_NAME => 'GRSDS.DBMS_JOB$_22591');END;
/
BEGIN DBMS_SCHEDULER.drop_JOB(JOB_NAME => 'GRSDS.JOB_MV_FCDR_PORTO');END;
/
BEGIN DBMS_SCHEDULER.drop_JOB(JOB_NAME => 'GRSDS.JOB_MV_FCDR_PORTO_ACU');END;
/
BEGIN DBMS_SCHEDULER.drop_JOB(JOB_NAME => 'GRSDS.JOB_MV_FCDR_PORTO_LON');END;
/

-- restart zabixx logado com root:
service zabbix-agent status
service zabbix-agent restart


CREATE TABLE "RDOE"."TURNO_TRABALHO" ("TUTR_SQ_TURNO_TRABALHO" NUMBER(28,0), "TUTR_DS_TURNO_TRABALHO" VARCHAR2(255 BYTE), "TUTR_IN_SITUACAO" NUMBER(1,0), "TUTR_DS_FORMATADA" VARCHAR2(255 BYTE), "TUTR_NR_HIBERNATE" NUMBER(5,0), "CONT_SQ_CONTRATO" NUMBER(28,0) NOT NULL ENABLE, "TUTR_DT_HORA_INICIO" TIMESTAMP (0), "TUTR_DT_HORA_FIM" TIMESTAMP (0), "TUTR_TX_OBSERVACAO" VARCHAR2(255 BYTE), "TUTR_IN_EXTRAORDINARIO" NUMBER(1,0), "TUTR_DT_HORA_DESCONTO" TIMESTAMP (0) DEFAULT '01/01/70 00:00' NOT NULL ENABLE) SEGMENT CREATION IMMEDIATE PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255NOCOMPRESS LOGGING STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645 PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT) TABLESPACE "RDOE_D_01"; 

CREATE tablespace "[JS User]_PPMJAS" datafile '+DG_DAT01/GDPTT/PPM_JASPER_TS.DBF' size 8m autoextend on next 16m maxsize 30g ;

CREATE TABLESPACE JS_User_PPMJAS DATAFILE '+DG_DAT01' size 8m autoextend on next 16m maxsize 30g LOGGING EXTENT MANAGEMENT LOCAL SEGMENT SPACE MANAGEMENT AUTO;

ALTER USER PPMJASPERADMIN QUOTA UNLIMITED ON PPMJASPERADMIN_PPMJAS;

CREATE USER JS_clarity IDENTIFIED BY Cl@riT1Y# DEFAULT SPACE [JS User]_PPMJAS TEMPORARY TABLESPACE TEMP; 

ALTER USER PPMJASPERADMIN QUOTA UNLIMITED ON PPMJASPERADMIN_PPMJAS;

GRANT CONNECT, RESOURCE, CREATE SESSION TO PPMJASPERADMIN; 

GRANT UNLIMITED TABLESPACE, QUERY REWRITE TO PPMJASPERADMIN;


SICARHMG - WE8ISO8859P15 - C5N00H
SICAR - WE8ISO8859P15 - C5N00H
HEPBRF - WE8MSWIN1252 - CWN05H
PEPBRF - WE8MSWIN1252 - CWN00P
PEPBRGIS - WE8ISO8859P1 - C1N0P

sicarhmg - c5n001h - 

sicar - c5n001p

hepbrf - cwn001h

pepbrf - cwn001p

pepbrgis - cwn001p (é p1, mas o we8mswin1252 é superset e base integrada do e&p está sendo consolidada no cw)

sbcldb16 - Agente do OEM porta 3872 indisponivel do ZABIIX que aponta no sigmon. 



SICARHMg, SICAR, 

HEPBRF PEPBRF PEPBRGIS



cxyznna

c -> indicativo que é container

x -> characterset ( we8ms(w)in1252 , we8(d)ec , we8iso8859p1(5), (a)l32utf8, we8mswin1252p(1) )

y -> n ou s, controles sox ou nao (só produção é sox)

z -> 0 -> para banco sem ctg, 1 -> para primário CIPD, 2 -> para contingÊncia síncrona, 3-> para contingÊncia assíncrona

nn -> dois caracteres sequenciais, não tem muito padrão, para diferenciar

a -> ambiente

ecomexp - AL32UTF8 - can101p
ecomexh - AL32UTF8 - can001h



[oracle@npaa5048:/u01/app/oracle/admin/peparba/scripts/backup] $ cat parRman.sh_old
#!/bin/bash

source /u01/app/oracle/product/12.2.0.1/db_1/scripts/oraenv.sh </dev/null

export ORACLE_SID=peparba
export ORACLE_DB_NAME=peparba
export CATALOG_USER=RMAN_APLICAB
export CATALOG_PASS=xexe9a5bbk5yy49
export CATALOG_TNS=rman

export LOG_RETENTION=62

export CATALOG_USER_BKP=RMAN_APLICAB_BKP
export CATALOG_PASS_BKP=xexe9a5bbk5yy49
export CATALOG_TNS_BKP=rman_bkp
export RMAN_NB_ORA_CLIENT=npaa5048.petrobras.biz
export RMAN_NB_ORA_SERV=basileu.petrobras.com.br

export RMAN_NB_ORA_POLICY_ARCH=DB_ORA_RMAN_NPAA5048_PEPARBA_ARCH
export RMAN_NB_ORA_POLICY_ON=DB_ORA_RMAN_NPAA5048_PEPARBA_ON
export RMAN_CPF1_POLICY=DB_ORA_RMAN_NPAA5048_PEPARBA_ARCH1
export RMAN_CPF2_POLICY=DB_ORA_RMAN_NPAA5048_PEPARBA_ARCH2

/u01/app/oracle/product/12.2.0.1/db_1


DB_SCRIPT_PATH = /u01/app/oracle/admin/peparba/scripts/backup
DB_SCRIPT_PATH = /u01/app/oracle/admin/pepcobo/scripts/backup

oraenv_12.2.0.1_oracle_db_1.sh

/u01/app/oracle/product/12.2.0.1/db_1


/u01/app/oracle/product/12.2.0.1/db_1/root.sh

export ORACLE_HOME=/u01/app/oracle/product/12.2.0.1/db_1/network/admin

$ORACLE_HOME/perl/bin/perl $ORACLE_HOME/clone/bin/clone.pl ORACLE_BASE="/u01/app/oracle/"ORACLE_HOME="/u01/app/oracle/product/12.2.0.1/db_1" OSDBA_GROUP=dba -defaultHomeName



CREATE TABLESPACE JSPER_PPMJAS DATAFILE '+DG_DAT01' SIZE 500M REUSE AUTOEXTEND ON NEXT 25M MAXSIZE 10G LOGGING EXTENT MANAGEMENT LOCAL SEGMENT SPACE MANAGEMENT AUTO;

CREATE USER jsper IDENTIFIED BY JS2022# DEFAULT TABLESPACE JSPER_PPMJAS TEMPORARY TABLESPACE TEMP;
ALTER USER jsper QUOTA UNLIMITED ON JSPER_PPMJAS;
GRANT CONNECT, RESOURCE, CREATE SESSION TO jsper;
GRANT UNLIMITED TABLESPACE, QUERY REWRITE TO jsper;

-- analyse no banco:
SELECT SE.INST_ID IID
,DECODE(EVENT
 ,'jobq slave wait'
 ,'zIJQ'
 ,DECODE(SE.STATUS
,'ACTIVE'
,'ACT'
,'INACTIVE'
,'INA'
,SE.STATUS)) STA
,REPLACE(TO_CHAR(FLOOR(LAST_CALL_ET / 3600)
,'00') || ':' ||
 TO_CHAR(FLOOR(MOD(LAST_CALL_ET
,3600) / 60)
,'00') || ':' ||
 TO_CHAR(MOD(MOD(LAST_CALL_ET
,3600)
,60)
,'00')
,' '
,NULL) L_S
,NVL(SE.USERNAME
,PR.PROGRAM) USERNAME
,OSUSER
,'''' || SE.SID || ',' || SE.SERIAL# || '''' SID_SERIAL
,HASH_VALUE SQL_HSH
,SQ.SQL_ID
-- ,SQ.CHILD_NUMBER CN
,EXECUTIONS SQL_EXE
,ROUND(((ELAPSED_TIME + CPU_TIME) /
 DECODE(EXECUTIONS
,0
,1
,EXECUTIONS) / 1000000),5) SQL_ELA
,SQL_PROFILE
--,SQL_PLAN_BASELINE
,PLAN_HASH_VALUE
,SQL_TEXT
,SE.PREV_SQL_ID
,PR.SPID || ' (' || PR.PROGRAM || ')' SPID_PROGRAM
,(SELECT MAX('(' || LON.OPNAME || ') (' || LON.SOFAR || '->' ||
 LON.TOTALWORK || ') : ' || LON.TARGET)
FROM V$SESSION_LONGOPS LON
 WHERE LON.SID = SE.SID
 AND LON.SQL_HASH_VALUE = SE.SQL_HASH_VALUE
 AND SOFAR < TOTALWORK) LO
,' (#W : ' || RPAD(SEQ#
,5) || ' | ST : ' ||
 DECODE(WAIT_TIME
 ,0
 ,'WAIT'
 ,-1
 ,'FAST'
 ,-2
 ,'UNKN'
 ,WAIT_TIME) || ') ' || EVENT W
,SE.BLOCKING_SESSION
,SE.SECONDS_IN_WAIT
,SE.TERMINAL
,SE.OSUSER
,SE.MACHINE
,SE.LOGON_TIME
,SE.PROGRAM
,SE.FAILED_OVER
,SE.SERVER
,SE.SERVICE_NAME
,(SELECT SQL_FULLTEXT
FROM V$SQLAREA
 WHERE SQL_ID = SE.SQL_ID) SQL_FULLTEXT
/*
,(SELECT OWNER || '.' || OBJECT_NAME || '(' || OBJECT_TYPE || ') - ' ||
 SQ.PROGRAM_ID || '(' || SQ.PROGRAM_LINE# || ')'
FROM DBA_OBJECTS OB
,V$SQLSQ
 WHERE HASH_VALUE = SE.SQL_HASH_VALUE
 AND INST_ID = SE.INST_ID
 AND CHILD_NUMBER = SE.SQL_CHILD_NUMBER
 AND OB.OBJECT_ID = SQ.PROGRAM_ID) PRG_O
*/
FROM GV$SESSION SE
,GV$PROCESS PR
,GV$SQLAREA SQ
 WHERE SE.INST_ID = PR.INST_ID
 AND SE.INST_ID = SQ.INST_ID (+)
 AND SE.PADDR = PR.ADDR(+)
 AND SE.SQL_ID = SQ.SQL_ID(+)
 AND SE.TYPE = 'USER'
 ----AND SE.USERNAME='SAAU_APLICACAO'
AND SE.STATUS IN ('ACTIVE')
-- AND SE.SID NOT IN (SELECT SID
--FROM V$MYSTAT)
-- AND SE.USERNAME IN ('ROND_RJ_CENTRO')
-- AND SE.MACHINE = 'moros'
 ORDER BY STA
 ,L_S
 ,SE.USERNAME
 ,SID_SERIAL
			 
SET SERVEROUTPUT ON
declare
stmt_task VARCHAR2(40);

begin
stmt_task := DBMS_SQLTUNE.CREATE_TUNING_TASK(sql_id => '0xnn1sp7q1kq8');
DBMS_OUTPUT.put_line('task_id: ' || stmt_task );
end;
/
 
 
begin
DBMS_SQLTUNE.EXECUTE_TUNING_TASK(task_name => 'TASK_157796');
end;
/
 

SELECT DBMS_SQLTUNE.report_tuning_task('TASK_156921') AS recommendations FROM dual;


-- - tabelas:
SELECT * FROM ALL_ALL_TABLE WHERE TABLE_NAME = 'TABELA_USERS'
-- - sinonimos:
SELECT * FROM ALL_SYNONYMS WHERE SYNONYM_NAME = 'SIN_TABELA_USERS'


--nohup expdp \"/ as sysdba\" parfile=copia.par &
--nohup impdp \"/ as sysdba\" parfile=copia.par &
--nohup impdp \"/ as sysdba\"  directory=DIR_LOG_BKP dumpfile=expdp_S3232006_%U.dmp logfile=expdp_S3232006_IMP_.log cluster=n parallel=10 &

directory=DIR_LOG_BKP
logfile=expdp_S3232006 
dumpfile=expdp_S3232006_%U.dmp
exclude=schema:"IN('SYS','AUD$','APEX_030200','APEX_PUBLIC_USER','APPQOSSYS','ANONYMOUS', 'CTXSYS', 'DIP', 'DBSNMP','MDDATA','MDSYS','MGMT_VIEW','OLAPSYS','OPS$SAUDITUNIX','ORACLE_OCM','ORASTATUS','ORDDATA','ORDPLUGINS','ORDSYS','OUTLN','OWBSYS','OWBSYS_AUDIT','SCOTT','SI_INFORMTN_SCHEMA','SPATIAL_CSW_ADMIN_USR','SPATIAL_WFS_ADMIN_USR','SYSMAN','SYSTEM','WMSYS','XDB','XS$NULL')"
parallel=4
flashback_time=systimestamp
cluster=n

directory=DIR_LOG_BKP
logfile=expdp_CXLP_FULL_meteor_23jul2022
dumpfile=expdp_CXLP_FULL_meteor_23jul2022_%U.dmp
full=yes
exclude=table:"IN('SYS','AUD$')"
parallel=8
flashback_time=systimestamp
cluster=n


RMAN.PETROBRAS.COM.BR=
(DESCRIPTION=
(ADDRESS=
(PROTOCOL=TCP)
(HOST=viprmanp.petrobras.com.br)
(PORT=1521))
(CONNECT_DATA=
(SERVICE_NAME=RMANP.PETROBRAS.COM.BR)))
		
RMAN_BKP.PETROBRAS.COM.BR=
(DESCRIPTION=
(ADDRESS=
(PROTOCOL=TCP)
(HOST=viprmanc.petrobras.com.br)
(PORT=1521))
(CONNECT_DATA=
(SERVICE_NAME=RMANC.PETROBRAS.COM.BR)))

-- screen

criar um screen: screen -h 10000000 -S asd2hr_bdemq
listar o screen: screen -ls
logar no screen: screen -rd asd2hr_bdemq
sair do screen: screen -x 

-- controlfile:

show parameter control_files
select value from v$parameter where name = 'control_files';
select name from v$controlfile;
select rpad(substr(name,1,50),51,' ') "control file name" from gv$controlfile;

-- cemiterio de dados:

srjcptiexa1cl3db01 a 04

create user DBADMIN identified by E#x46C_FaU DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP;


create database link TMP_DBLINK connect to ASD2HR identified by "mnJ#2kop9Z19" using
'(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=sspcctiexa1cl1db04.petrobras.biz)(PORT=1521)))
(CONNECT_DATA=(SERVICE_NAME=sistp.petrobras.com.br)))';



DECLARE
H1 NUMBER;
HSTATUS VARCHAR2(200);
BEGIN
H1 := DBMS_DATAPUMP.OPEN(OPERATION =>'IMPORT', JOB_MODE => 'SCHEMA', REMOTE_LINK => 'TMP_DBLINK');
DBMS_DATAPUMP.METADATA_FILTER(HANDLE =>H1, NAME => 'SCHEMA_LIST', VALUE => '''BDEMQ''');
DBMS_DATAPUMP.METADATA_REMAP(HANDLE =>H1, NAME => 'REMAP_SCHEMA', OLD_VALUE => 'BDEMQ', VALUE =>'BDEMQ_E1');
DBMS_DATAPUMP.START_JOB(HANDLE => H1);
DBMS_DATAPUMP.WAIT_FOR_JOB(HANDLE => H1, JOB_STATE => HSTATUS);
dbms_datapump.set_parallel(handle=> H1, degree => 24);
DBMS_OUTPUT.PUT_LINE('STATUS = ' ||HSTATUS);
dbms_datapump.metadata_filter(handle => H1, name => 'EXCLUDE_PATH_LIST', value => 'STATISTICS');
DBMS_DATAPUMP.ADD_FILE(HANDLE=> H1, FILENAME => 'imp.log', DIRECTORY => 'TMP_DIR', FILETYPE => DBMS_DATAPUMP.KU$_FILE_TYPE_LOG_FILE);
END;
/
 
 dbms_datapump.METADATA_FILTER(handle = your_handle_here,name = 'EXCLUDE_PATH_LIST',value = 'STATISTICS');

--- SISTD: 
66EF7417987CD729 - hash
66EF7417987CD729



DBMS_METADATA.GET_DDL('USER','BDEMQ_E1')||';' 
--------------------------------------------------------------------------------

 ALTER USER "BDEMQ_E1" IDENTIFIED BY VALUES 'S:6FB4BF976BB7E40BBAD95F91750D7
96A58BE6483F49E451776D1421A20D8;66EF7417987CD729'
DEFAULT TABLESPACE "BDEMQ_D_01"
TEMPORARY TABLESPACE "TEMP"
PROFILE "PFL_ADM_APPLICATION"
 ALTER USER "BDEMQ_E1" LOCAL TEMPORARY TABLESPACE "SYSTEM";


1 row selected.

DBMS_METADATA.GET_GRANTED_DDL('ROLE_GRANT','BDEMQ_E1')||';' 
----------------------------------------------------------------------------

 GRANT "RADM_SCHEMA" TO "BDEMQ_E1";


1 row selected.

DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','BDEMQ_E1')||';' 
--------------------------------------------------------------------------------

GRANT CREATE SESSION TO "BDEMQ_E1"
GRANT ALTER SESSION TO "BDEMQ_E1"
GRANT CREATE TABLE TO "BDEMQ_E1"
GRANT CREATE SYNONYM TO "BDEMQ_E1"
GRANT CREATE VIEW TO "BDEMQ_E1"
GRANT CREATE SEQUENCE TO "BDEMQ_E1"
GRANT CREATE DATABASE LINK TO "BDEMQ_E1"
GRANT CREATE TRIGGER TO "BDEMQ_E1"
GRANT CREATE MATERIALIZED VIEW TO "BDEMQ_E1"
GRANT SELECT ANY DICTIONARY TO "BDEMQ_E1"
GRANT DEBUG CONNECT SESSION TO "BDEMQ_E1"
GRANT DEBUG ANY PROCEDURE TO "BDEMQ_E1"
GRANT ADVISOR TO "BDEMQ_E1"
GRANT CREATE JOB TO "BDEMQ_E1"
GRANT ADMINISTER ANY SQL TUNING SET TO "BDEMQ_E1"
GRANT CREATE CREDENTIAL TO "BDEMQ_E1"; 


1 row selected.

DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','BDEMQ_E1')||';' 
--------------------------------------------------------------------------------

GRANT EXECUTE ON "SYS"."DBMS_LOCK" TO "BDEMQ_E1"
GRANT EXECUTE ON "SYS"."DBMS_SQLTUNE" TO "BDEMQ_E1"
GRANT EXECUTE ON "SYS"."JOB" TO "BDEMQ_E1"
GRANT DELETE ON "BDEMQUNIT"."BALANCO_ITEM_BOMBEAMENTO" TO "BDEMQ_E1"
GRANT INSERT ON "BDEMQUNIT"."BALANCO_ITEM_BOMBEAMENTO" TO "BDEMQ_E1"
GRANT SELECT ON "BDEMQUNIT"."BALANCO_ITEM_BOMBEAMENTO" TO "BDEMQ_E1"
GRANT UPDATE ON "BDEMQUNIT"."BALANCO_ITEM_BOMBEAMENTO" TO "BDEMQ_E1"
GRANT EXECUTE ON "SYS"."DBMS_JOB" TO "BDEMQ_E1"
GRANT SELECT ON "TCRP"."MV_TCOW_SEI_CADUSER" TO "BDEMQ_E1" WITH GRANT OPTION
GRANT SELECT ON "TCRP"."MV_BIREF_EMPRESA_GRP_PETROBRAS" TO "BDEMQ_E1"
GRANT SELECT ON "TCRP"."MV_BIRH_ESTRUT_ORG_PB_REC" TO "BDEMQ_E1";


nbcertcmd -getCACertificate -server srjcipdnbu406.petrobras.biz
nbcertcmd -getCertificate -host NPAB0127.petrobras.biz -server srjcipdnbu406.petrobras.biz -force -token RRNKGAGVRJPJJJPK


-- REMO:

Root => ishiyaK1
ORACLE => Or@cle00
SYS => GOM#12ora

REPLAN: http://ctxautreplan/ pasta "LINUX_ORACLE"

--nohup expdp \"/ as sysdba\" schemas=BDEMQ_E1 directory=DIR_BKP_DUMP dumpfile=BKP_BDEMQ_E1_%U.dmp logfile=BKP_BDEMQ_E1_.log flashback_time=systimestamp cluster=n parallel=8 &

--nohup expdp \"/ as sysdba\" schemas=BDEMQ_E1 directory=DIR_LOG_BKP dumpfile=expdp_BDEMQ_DEV_%U.dmp logfile=expdp_BDEMQ_DEV_.log flashback_time=systimestamp cluster=n parallel=8 &

--nohup impdp \"/ as sysdba\" schemas=BDEMQ_E1 directory=DIR_LOG_BKP dumpfile=expdp_BDEMQ_DEV_%U.dmp logfile=expdp_BDEMQ_DEV_IMPORT.log cluster=n parallel=8 &


select max(maxquerylen) from gv$undostat;


select retention from dba_lobs where owner='BDEMQ';


//derruba database
ALTER DATABASE EDMLIBRA_MODELO SET OFFLINE WITH ROLLBACK IMMEDIATE 
GO

//sobe database
ALTER DATABASE EDMLIBRA_MODELO SET ONLINE 
GO

-- load average - exacc setando o nome do container:
dcli -l oracle -g ~/dbs_group ". ~/c1s004p.env;uptime"

-- discard:
ALTER SYSTEM SET "_db_discard_lost_masterkey"=TRUE SCOPE=MEMORY;


4t5uvfqz6ymkh

+DG_DAT01/CXLP/PARAMETER

srvctl modify database -d cxlp -spfile '+DG_DAT01/CXLP/PARAMETER/spfile.423.1113145571'





export CATALOG_USER=rman_ab
export CATALOG_PASS=Aslaj1i#001
export CATALOG_TNS=rman.petrobras.com.br

# Credenciais do catalogo RMAN bkp
export CATALOG_USER_BKP=rman_ab_bkp
export CATALOG_PASS_BKP=Aslaj1i#001
export CATALOG_TNS_BKP=rman_bkp.petrobras.com.br


export ORACLE_SID=sd2h11g
export ORACLE_DB_NAME=sd2h11g

export CATALOG_USER=rman_aplicab
export CATALOG_PASS=xexe9a5bbk5yy49
export CATALOG_TNS=rman.petrobras.com.br
export RMAN_BACKUP_RETENTION=15
export CATALOG_USER_BKP=rman_aplicab_bkp
export CATALOG_PASS_BKP=xexe9a5bbk5yy49
export CATALOG_TNS_BKP=rman_bkp.petrobras.com.br

source /u01/app/oracle/product/11.2.0.4/db_1/scripts/oraenv.sh

--nohup expdp \"/ as sysdba\" schemas=BOEPM_AUDIT,BOEPM_AUDIT_APLICACAO,BOEPM_AUDITOR,BOEPM_CMS,BOEPM_CMS_APLICACAO,BOEPM_DS,BOEPM_DS_APLICACAO,BOEPM_DS_AUX,BOEPM_FIM,BOEPM_FIM_APLICACAO,BOEPM_IC,BOEPM_IC_APLICACAO,BOEPM_IPS directory=DIR_LOG_CEMITERIO dumpfile=expdp_asd2hr_exaprd02_copia_seg_%U.dmp logfile=expdp_asd2hr_exaprd02_copia_seg_.log flashback_time=systimestamp cluster=n parallel=8 &

--nohup impdp \"/ as sysdba\" directory=DIR_LOG_CEMITERIO dumpfile=expdp_asd2hr_exaprd02_copia_seg_%U.dmp logfile=impdp_asd2hr_exaprd02_copia_seg_.log sqlfile=EXAPRD02.sql content = metadata_only cluster=n parallel=8 &

--nohup impdp \"/ as sysdba\" schemas=BOEPM_AUDIT,BOEPM_AUDIT_APLICACAO,BOEPM_AUDITOR,BOEPM_CMS,BOEPM_CMS_APLICACAO,BOEPM_DS,BOEPM_DS_APLICACAO,BOEPM_DS_AUX,BOEPM_FIM,BOEPM_FIM_APLICACAO,BOEPM_IC,BOEPM_IC_APLICACAO,BOEPM_IPS directory=DIR_LOG_CEMITERIO dumpfile=expdp_asd2hr_exaprd02_copia_seg_%U.dmp logfile=imp_asd2hr_exaprd02_copia_seg_.log cluster=n parallel=8 &

BOEPM_AUDIT
BOEPM_AUDIT_APLICACAO
BOEPM_AUDITOR
BOEPM_CMS
BOEPM_CMS_APLICACAO
BOEPM_DS
BOEPM_DS_APLICACAO
BOEPM_DS_AUX
BOEPM_FCPRD * 
BOEPM_FCPRD_APLICACAO * 
BOEPM_FIM
BOEPM_FIM_APLICACAO
BOEPM_IC
BOEPM_IC_
BOEPM_IPS

BOEPM_IC
BOEPM_IC_APLICACAO
BOEPM_FIM
BOEPM_FIM_APLICACAO
BOEPM_CMS_APLICACAO
BOEPM_CMS
BOEPM_AUDIT_APLICACAO
BOEPM_AUDIT
BOEPM_DS_APLICACAO
BOEPM_DS
BOEPM_DS_AUX
BOEPM_IPS
BOEPM_AUDITOR

create tablespace BOEPM_IC_I_01 datafile '+DATAC3';
create tablespace BOEPM_IC_D_01 datafile '+DATAC3';
create tablespace BOEPM_IC_L_01 datafile '+DATAC3';
create tablespace BOEPM_IC_D_01 datafile '+DATAC3';
create tablespace BOEPM_IC_I_01 datafile '+DATAC3';
create tablespace BOEPM_IC_L_01 datafile '+DATAC3';
create tablespace BOEPM_IC_D_01 datafile '+DATAC3';
create tablespace BOEPM_IC_L_01 datafile '+DATAC3';
create tablespace BOEPM_FIM_D_01 datafile '+DATAC3';
create tablespace BOEPM_FIM_L_01 datafile '+DATAC3';
create tablespace BOEPM_IC_I_01 datafile '+DATAC3';
create tablespace BOEPM_FIM_I_01 datafile '+DATAC3';
create tablespace BOEPM_CMS_L_01 datafile '+DATAC3';
create tablespace BOEPM_CMS_I_01 datafile '+DATAC3';
create tablespace BOEPM_CMS_D_01 datafile '+DATAC3';
create tablespace BOEPM_AUDIT_I_01 datafile '+DATAC3';
create tablespace BOEPM_AUDIT_L_01 datafile '+DATAC3';
create tablespace BOEPM_AUDIT_D_01 datafile '+DATAC3';
create tablespace BOEPM_AUDIT_I_01 datafile '+DATAC3';
create tablespace BOEPM_AUDIT_L_01 datafile '+DATAC3';
create tablespace BOEPM_AUDIT_D_01 datafile '+DATAC3';
create tablespace BOEPM_DS_L_01 datafile '+DATAC3';
create tablespace BOEPM_DS_I_01 datafile '+DATAC3';
create tablespace BOEPM_DS_D_01 datafile '+DATAC3';
create BOEPM_DS_AUX_L_01 datafile '+DATAC3';
create BOEPM_DS_AUX_I_01 datafile '+DATAC3';
create BOEPM_DS_AUX_D_01 datafile '+DATAC3';
create tablespace BOEPM_IPS_I_01 datafile '+DATAC3';
create tablespace BOEPM_IPS_D_01 datafile '+DATAC3';
create tablespace BOEPM_AUDITOR_D_01 datafile '+DATAC3';
create tablespace BOEPM_AUDITOR_I_01 datafile '+DATAC3';
create tablespace EMRG_D_01 datafile '+DATAC3';
create tablespace EMRG_L_01 datafile '+DATAC3';
create tablespace EMRG_I_01 datafile '+DATAC3';



create TEMPORARY tablespace TEMP tempfile '+DATAC3';

create role RBOEPM_DS_DML;
create role RBOEPM_DS_DRL;
create role RBOEPM_DS_EXEC;
create role RBOEPM_FIM_DML;
create role RBOEPM_FIM_DRL;
create role RBOEPM_FIM_EXEC;
create role RBOEPM_CMS_DML;
create role RBOEPM_CMS_DRL;
create role RBOEPM_CMS_EXEC;
create role RBOEPM_AUDIT_DML;
create role RBOEPM_AUDIT_DRL;
create role RBOEPM_AUDIT_EXEC;
create role RBOEPM_IC_DML;
create role RBOEPM_IC_DRL;
create role RBOEPM_IC_EXEC;
create role RSPFC_DML;
create role RSPFC_DRL
create role RSPFC_EXEC


select OWNER, DIRECTORY_NAME, DIRECTORY_PATH from dba_directories where directory_name = 'DIR_LOG_CEMITERIO';
CREATE OR REPLACE directory DIR_LOG_CEMITERIO AS '/ora_operacao2/ASD2HR/S3291477';
grant read, write on directory DIR_LOG_CEMITERIO to sys, system;


drop user SP01ADB1 cascade;
drop user BOEPM_DS_APLICACAO cascade;
drop user BOEPM_FIM cascade;
drop user BOEPM_FIM_APLICACAO cascade;
drop user BOEPM_CMS_APLICACAO cascade;
drop user BOEPM_AUDIT_APLICACAO cascade;
drop user BOEPM_DS cascade;
drop user BOEPM_IPS cascade;
drop user BOEPM_IC cascade;
drop user BOEPM_IC_APLICACAO cascade;
drop user BOEPM_CMS cascade;
drop user BOEPM_AUDIT cascade;
drop user BOEPM_AUDITOR cascade;

drop user BOEPM_DS_AUX cascade;
drop user BOEPM_FIM cascade;
drop user BOEPM_IC cascade;


GRANT SELECT ON TCRP.MV_BICL_ESTADO TO RSPME_GLOBAL_DRL;
GRANT SELECT ON TCRP.MV_BICL_MUNICIPIO TO RSPME_GLOBAL_DRL;
GRANT SELECT ON TCRP.MV_BICL_PAIS TO RSPME_GLOBAL_DRL;
GRANT SELECT ON TCRP.MV_BIREF_EMPRESA_GRP_PETROBRAS TO RSPME_GLOBAL_DRL;

c1n103p
c5n101p
cas101p

mount -a rw,bg,hard,nointr,rsize=32768,wsize=32768,proto=tcp,vers=3,timeo=600 s6006fs14:/vol/APL_NFS_SRV_PROD_HOM_DEN_DUMP /BKP_NAS_TICNE_CIPD/ 




###########################################################   ALMENTANDO O TAMANHO DA TABLESPACE   ############################################################################################################################################################################################################




-- COMANDO PARA ENTRAR NO CONTAINER:

      echo $ORACLE_SID

    . NOME DO CONTAINER .env

      sqlplus / as sysdba
	  
	  show pdbs

      alter session set container=NOME DO CONTAINER;
	  
	  set lines 200

	  
	  -- QUERY PARA VER O TAMANHO OU CAPACIDADE DA TABLESPACE :
	  
SELECT tbm.TABLESPACE_NAME,
round(tbm.USED_SPACE * tb.BLOCK_SIZE /(1024*1024),2) USED_SPACE_MB,
round(tbm.TABLESPACE_SIZE * tb.BLOCK_SIZE /(1024*1024*1024),2) TABLESPACE_SIZE_GB,
ROUND((TBM.TABLESPACE_SIZE - TBM.USED_SPACE) * TB.BLOCK_SIZE /(1024*1024*1024),2) TABLESPACE_FREE_GB,
round(tbm.USED_PERCENT ,2) AS "USED_%"
FROM dba_tablespace_usage_metrics tbm,
dba_tablespaces tb
where TB.TABLESPACE_NAME = TBM.TABLESPACE_NAME
AND TBM.TABLESPACE_NAME like '%MOB_LOB%' ORDER BY TB.TABLESPACE_NAME;


-- QUERY PARA VER O TAMANHO OU CAPACIDADE DO DISCO :   ( NAO PRESIZA MODIFICAR NADA E SO COLAR )

SET LINESIZE  145
SET PAGESIZE  9999
SET VERIFY    off
COLUMN group_name             FORMAT a20           HEAD 'Disk Group|Name'
COLUMN sector_size            FORMAT 99,999        HEAD 'Sector|Size'
COLUMN block_size             FORMAT 99,999        HEAD 'Block|Size'
COLUMN allocation_unit_size   FORMAT 999,999,999   HEAD 'Allocation|Unit Size'
COLUMN state                  FORMAT a11           HEAD 'State'
COLUMN type                   FORMAT a6            HEAD 'Type'
COLUMN total_mb               FORMAT 999,999,999   HEAD 'Total Size (MB)'
COLUMN used_mb                FORMAT 999,999,999   HEAD 'Used Size (MB)'
COLUMN pct_used               FORMAT 999.99        HEAD 'Pct. Used'

break on report on disk_group_name skip 1
compute sum label "Grand Total: " of total_mb used_mb on report


SELECT
    name                                     group_name
  , sector_size                              sector_size
  , block_size                               block_size
  , allocation_unit_size                     allocation_unit_size
  , state                                    state
  , type                                     type
  , total_mb                                 total_mb
  , (total_mb - free_mb)                     used_mb
  , ROUND((1- (free_mb / total_mb))*100, 2)  pct_used
FROM
    v$asm_diskgroup
ORDER BY
    name
/

-- QUERY PARA ALMENTAR O TAMANHO DA TABLESPACE OU DATA FILE : ( precisa modificar  O  UE6JO_INDICES E O '+DG_DAT01' )


alter tablespace N2_INTSUB_DADOS add datafile '+DG_FRA01' size 8M autoextend on next 16m maxsize 30g ;


-- QUERY PARA VER O TAMANHO OU CAPACIDADE DA TABLESPACE : ( precisa modificar  O  '%UE6JO_INDICES%' )
	  
SELECT tbm.TABLESPACE_NAME,
round(tbm.USED_SPACE * tb.BLOCK_SIZE /(1024*1024),2) USED_SPACE_MB,
round(tbm.TABLESPACE_SIZE * tb.BLOCK_SIZE /(1024*1024*1024),2) TABLESPACE_SIZE_GB,
ROUND((TBM.TABLESPACE_SIZE - TBM.USED_SPACE) * TB.BLOCK_SIZE /(1024*1024*1024),2) TABLESPACE_FREE_GB,
round(tbm.USED_PERCENT ,2) AS "USED_%"
FROM dba_tablespace_usage_metrics tbm,
dba_tablespaces tb
where TB.TABLESPACE_NAME = TBM.TABLESPACE_NAME
AND TBM.TABLESPACE_NAME like '%N2_INTSUB_DADOS%' ORDER BY TB.TABLESPACE_NAME;


####################################################  SENHA DO OEM ###########################################################################

                                                 senha do oem 

                                                 login= oem_sysman
												  
                                                 senha= oracle17


################################################################################################################################################



################################################     REALIZANDO  UM  DAMP  ########################################################################


***************CRIAR PASTA *************

/ora_operacao/asdx39



********************* CRIAR DIRETORIO NA PASTA **********************************

CREATE OR REPLACE directory BKP_DX39 AS '/oracle_bkp3/cipd/dx39';

***************************  COMANDO DE EXPORT Damp *************************


//producao
nohup expdp \"/ as sysdba\" schemas=BICL directory=BKP_DX39 dumpfile=exp_dx39_S3300920_%U.dmp logfile=exp_dx39_S3300920.log cluster=n flashback_time=systimestamp parallel=8 &


//hmg   copia de segurança 

nohup expdp \"/ as sysdba\" schemas=BICL directory=BKP_DX39 dumpfile=exp_copia_odsch_%U.dmp logfile=exp_copia_odsch.log cluster=n flashback_time=systimestamp parallel=8 &




*************************Limpar Schemas *******************************************

SELECT 'DROP TABLE '|| OWNER||'.'||TABLE_NAME || ' CASCADE CONSTRAINTS PURGE;' FROM DBA_TABLES WHERE OWNER IN ('BICL');
SELECT 'DROP ' || OBJECT_TYPE || ' ' || OWNER||'.'||OBJECT_NAME || ';' FROM DBA_OBJECTS WHERE OWNER IN ('BICL')
AND OBJECT_TYPE NOT IN ('TABLE','INDEX') AND OBJECT_NAME NOT LIKE 'BIN$%' AND OBJECT_NAME NOT LIKE '%$$' ORDER BY object_name;
SELECT 'DROP ' || OBJECT_TYPE || ' ' || OWNER||'.'||OBJECT_NAME || ';' FROM DBA_OBJECTS WHERE OWNER IN ('BICL') AND OBJECT_TYPE='SYNONYM';

**********************************************COMANDO DE IMPORT***********************************************************

nohup impdp \"/ as sysdba\" directory=BKP_DX39 dumpfile=exp_dx39_S3314141_%U.dmp logfile=imp_dx39_S3314141.log cluster=n parallel=8 &



************************** COMPILAR OS DADOS *******************************

BEGIN
  SYS.UTL_RECOMP.RECOMP_SERIAL(SCHEMA => 'BICL');
END;
/

*********************************** COLETAR AS ESTATISTICAS DO ESQUEMA ****************************************

EXEC DBMS_STATS.GATHER_SCHEMA_STATS(OWNNAME=>'BICL',ESTIMATE_PERCENT => NULL, GRANULARITY=> 'ALL', CASCADE=> TRUE, METHOD_OPT=>'FOR ALL COLUMNS SIZE SKEWONLY', degree => 8);


"SMSR_E1"."ACOMPANHAMEN  

TO_RECOMENDACAO"

########################################################### ALMENTANDO O TAMANHO DA TABLESPACE ################################################################

Entrar com :
 sudosu oracle
 
depois dar o comando ( o comando vai listar as dases e usuarios , depois pegar a base que eu vou utilizar e colar  comando ) 
 ps -ef | grep pmon
 
 ( o comando vai listar as bases , depois pegar a base que eu vou utilizar e colar  comando )
 
 usar o comando:
 export ORACLE_SID=pepbc1
 
 depois usar o comando :
 sqlplus / as sysdba
 
 ver o nome da base 
 comando:
 select * from global_name;

Apos tudo isso entrar no TOD e ver o tamanho da TEMP, pois o TOD tem uma visualização melhor da TEMP  

Colar a query para almentar o tamanho da TEMP 

-- QUERI PARA ALMENTAR O TAMANHO DA TABLESPACE 'TEMP' ( temporario )


ALTER TABLESPACE TEMP ADD TEMPFILE '+UE6LX_D_01' size 30G reuse autoextend on next 16m maxsize 30G;




Apoi esta ação a seguinte query a baixo para informar as minhas ações no ambiente de PRODUÇÃO 

begin
   dbms_session.set_identifier('Atendimento ao Chamado: S3314233  '|| to_char (sysdate, 'dd/mm/yyyy HH24:MI'));
end;
/


##############################################################################################################################################################

               set lines 200                        ESTE COMANDO CONSERTA A ESTRUTURA DO ULTIMO COMANDO INSERIDO 
			   /                                       DANDO ASSIM UMA VISUALIZAÇÃO MELHOR DO RESULTADO 
                


##############################################################################################################################################################				

#######################################################    Banco de dados sem BACKUP FULL   ##################################################################

ENTRAR COM O COMANDO 
        sudo su - oracle
		
DAR O COMANDO 
        ls -h

ENTRAR NO CONTAINER 

     . NOME DO CONTAINER.env
EX:  . . c1n004p.env

DAR O COMANDO 
       sqlplus / as sysdba
	   
DAR O COMANDO 

       show pdbs
	   
	   COLAR A QUERY A BAIXO PARA VER SE O BACKUP ESTA RODANDO

-- QUERY PARA VER SE O BACKUP ESTA RODANDO 

	col START_TIME for a20
	col END_TIME for a20
	set lines 200
	select
	   to_char(j.start_time, 'yyyy-mm-dd hh24:mi:ss') start_time,
	   to_char(j.end_time, 'yyyy-mm-dd hh24:mi:ss') end_time,
	   (j.output_bytes/1024/1024) output_mbytes, j.status, j.input_type,
	   decode(to_char(j.start_time, 'd'), 1, 'Sunday', 2, 'Monday',
										  3, 'Tuesday', 4, 'Wednesday',
										  5, 'Thursday', 6, 'Friday',
										  7, 'Saturday') dow
	 from V$RMAN_BACKUP_JOB_DETAILS j
	 where j.start_time > trunc(sysdate) -5
	 order by j.start_time desc;
	 select host_name,instance_name from gv$instance;


##############################################################################################################################################################

cd $ORACLE_BASE/admin/c1n004p/scripts/backup


#############################################################################################################################################################

##################################################    CHAMADO   CPU Idle time menor que 10%   ###############################################################

ENTRAR COM O COMANDO 
      sudo su - oracle 
	  
	  
DAR O COMANDO 
      top           ( Este comando fornece uma visão geral rápida das informações do sistema. Relata dados sobre processos atuais que são atualizados (por padrão) a cada 3 segundos )
	  
DAR O COMANDO 
      df -h

ENTRAR NO CONTAINER QUE ESTA GERANDO O ALERTA 
      . NOME DO CONTAINER.env
EX:   . c1n004p.env

	 
########################################################################    DUMP COPIA DE BANCO  ######################################################################################


EMTRAR COM O COMANDO 
sudo su -

MONTAR O FILE SISTEM PARA TER AREA PARA EXPORTAR O DUMP NA MINHA PASTA  AS DX39
COM A QUERY :

 mount -o rw,bg,hard,rsize=32768,wsize=32768,vers=3,nointr,timeo=600,tcp cipdss01.ep:/ep04/bd/ora_operacao /ora_operacao


ENTRAR NA PASTA ASDX39 
COMANDO:

CD asdx39

DENTRO DA MINHA PASTA CRIAR OUTRA PASTA COM O NUMERO DO CHAMADO PARA GUARDAR A MINHA COPIA 
COMANDO :

 MKDIR (O NUMERO DO CHAMADO )
 
 DAR PERMIÇÃO TOTAL PARA A NOVA PASTA QUE FOI CRIADA NO ASDX39 
 COM O COMANDO:
 
 CHMOD 777 (NOME DA PASTA CRIADA COM O NUMERO DO CHAMADO)
 
 
 DAR O COMANDO
 
 PWD 
 
 COPIAR O CAMINHO GERADO PELO COMANDO PWD  EXEMPLO:  /ora_operacao/asdx39/S3314141
 
 DAR O COMANDO :
 
 ps -ef | grep pmon 
 
PARA VER AS BASES QUE VAI SER FEITO O DUMP

DAR O COMANDO :
su - oracle 

PARA SAIR DO ROOT E ENTRAR NO ORACLE 

DAR O COMANDO:
export ORACLE_SID=NOME DA BASE 


DAR O COMANDO:
  sqlplus / as sysdba
  
  
  CRIAR DIRETORIO NA PASTA
  
 QUERY :
 
CREATE OR REPLACE directory BKP_DX39 AS '/ora_operacao/asdx39/S3314141';


DAR UM exit PARA SAIR DO SQL E ENTRAR NO ORACLE 

exit


COMANDO DE EXPORT Damp


nohup expdp \"/ as sysdba\" schemas=SPF_GEDUTE directory=BKP_DX39 dumpfile=exp_dx39_S3314141_%U.dmp logfile=exp_dx39_S3314141.log cluster=n flashback_time=systimestamp parallel=8 &
 

DAR O COMANDO PARA VER AS ULTIMAS 100 LINHAS 

tail -100f nohup.out


EXIT

COPIA DE SEGURANÇA COM A QUERY A BAIXO ( mudar o nome do esquema para onde eu quero importar )

nohup expdp \"/ as sysdba\" schemas=SPF_GEDUTE directory=BKP_DX39 dumpfile=exp_copia_SPF16D_%U.dmp logfile=exp_copia_SPF16D.log cluster=n flashback_time=systimestamp parallel=8 &



LIMPAR ESQUEMA 


SELECT 'DROP TABLE '|| OWNER||'.'||TABLE_NAME || ' CASCADE CONSTRAINTS PURGE;' FROM DBA_TABLES WHERE OWNER IN ('SPF_GEDUTE');
SELECT 'DROP ' || OBJECT_TYPE || ' ' || OWNER||'.'||OBJECT_NAME || ';' FROM DBA_OBJECTS WHERE OWNER IN ('SPF_GEDUTE')
AND OBJECT_TYPE NOT IN ('TABLE','INDEX') AND OBJECT_NAME NOT LIKE 'BIN$%' AND OBJECT_NAME NOT LIKE '%$$' ORDER BY object_name;
SELECT 'DROP ' || OBJECT_TYPE || ' ' || OWNER||'.'||OBJECT_NAME || ';' FROM DBA_OBJECTS WHERE OWNER IN ('SPF_GEDUTE') AND OBJECT_TYPE='SYNONYM';


SELECIONARE O COMANDO QUE A QUERY A SIMA MOSTROU E COLAR PARA LIMPAR O ESQUEMA 


COMANDO DE IMPORT:

nohup impdp \"/ as sysdba\" directory=BKP_DX39 dumpfile=exp_dx39_S3314141_%U.dmp logfile=imp_dx39_S3314141.log cluster=n parallel=8 &


 COMPILAR OS DADOS 

BEGIN
  SYS.UTL_RECOMP.RECOMP_SERIAL(SCHEMA => 'SGR3');
END;
/

 COLETAR AS ESTATISTICAS DO ESQUEMA 

EXEC DBMS_STATS.GATHER_SCHEMA_STATS(OWNNAME=>'SGR3',ESTIMATE_PERCENT => NULL, GRANULARITY=> 'ALL', CASCADE=> TRUE, METHOD_OPT=>'FOR ALL COLUMNS SIZE SKEWONLY', degree => 8);


#############################################################################################################################################################################################

##########################################################     screen   ##############################################################################################
-- QUERI PARA CRIAR UMA SCREEN PARA SE ACASO A VPN CAIR 


criar um screen: screen -h 10000000 -S asd2hr_bdemq_e1
listar o screen: screen -ls
logar no screen: screen -rd asd2hr_bdemq_e1


##############################################################################################################################################################


/oracle_bkp3/cipd/dx39



CREATE OR REPLACE directory BKP_DX39 AS '/oracle_bkp3/cipd/dx39/S3299605';


nohup expdp \"/ as sysdba\" schemas=ADM directory=BKP_DX39 dumpfile=exp_dx39_S3299605_%U.dmp logfile=exp_dx39_S3299605.log cluster=n flashback_time=systimestamp parallel=8 &



nohup expdp \"/ as sysdba\" schemas=ADM_BC,ADM_ES directory=BKP_DX39 dumpfile=exp_copia_RECBR_%U.dmp logfile=exp_copia_RECBR.log cluster=n flashback_time=systimestamp parallel=8 &



CREATE OR REPLACE directory BKP_DX39 AS '/ora_operacao/asdx39/S3314141';



nohup expdp \"/ as sysdba\" schemas=ADM directory=BKP_DX39 dumpfile=exp_dx39_S3299605_RECES_%U.dmp logfile=exp_dx39_S3299605_RECES.log cluster=n flashback_time=systimestamp parallel=8 &



LIMPAR ESQUEMA 


SELECT 'DROP TABLE '|| OWNER||'.'||TABLE_NAME || ' CASCADE CONSTRAINTS PURGE;' FROM DBA_TABLES WHERE OWNER IN ('ADM_ES');
SELECT 'DROP ' || OBJECT_TYPE || ' ' || OWNER||'.'||OBJECT_NAME || ';' FROM DBA_OBJECTS WHERE OWNER IN ('ADM_ES')
AND OBJECT_TYPE NOT IN ('TABLE','INDEX') AND OBJECT_NAME NOT LIKE 'BIN$%' AND OBJECT_NAME NOT LIKE '%$$' ORDER BY object_name;
SELECT 'DROP ' || OBJECT_TYPE || ' ' || OWNER||'.'||OBJECT_NAME || ';' FROM DBA_OBJECTS WHERE OWNER IN ('ADM_ES') AND OBJECT_TYPE='SYNONYM';



nohup impdp \"/ as sysdba\" remap_schema=ADM:ADM_BC directory=BKP_DX39 dumpfile=exp_dx39_S3299605_%U.dmp logfile=imp_dx39_S3299605.log cluster=n parallel=8 &

nohup impdp \"/ as sysdba\" remap_schema=ADM:ADM_ES directory=BKP_DX39 dumpfile=exp_dx39_S3299605_RECES_%U.dmp logfile=imp_dx39_S3299605_RECES.log cluster=n parallel=8 &



BEGIN
  SYS.UTL_RECOMP.RECOMP_SERIAL(SCHEMA => 'ADM_ES');
  SYS.UTL_RECOMP.RECOMP_SERIAL(SCHEMA => 'ADM_BC');
END;
/


EXEC DBMS_STATS.GATHER_SCHEMA_STATS(OWNNAME=>'ADM_ES',ESTIMATE_PERCENT => NULL, GRANULARITY=> 'ALL', CASCADE=> TRUE, METHOD_OPT=>'FOR ALL COLUMNS SIZE SKEWONLY', degree => 8);
EXEC DBMS_STATS.GATHER_SCHEMA_STATS(OWNNAME=>'ADM_BC',ESTIMATE_PERCENT => NULL, GRANULARITY=> 'ALL', CASCADE=> TRUE, METHOD_OPT=>'FOR ALL COLUMNS SIZE SKEWONLY', degree => 8);


/oracle_bkp3/cipd


#########################################################################################################################################################
 #########################################  ESPAÇO LIVRE MENOR QUE  40% no file system /u01/app/oracle/admin ###########################################
 
 ENTRAR COM O COMANDO 
 sudo su - oracle 
 
 DAR O COMANDO 
 df -h       ( PARA VER O FILE SYSTEM QUE ESTA COM LIVRE MENOR QUE  40% )
 
 ENTRAR DENTRO DO FILE SYSTEM QUE ESTA DANDO PROBLEMA COM O COMANDO CD 
 
 cd /u01/app/oracle/admin
 
 ENTRAR COM O MANDO 
 du -sh *         ( O MESMO VAI ME DAR QUAL A PASTA QUE ESTA OCUPANDO ESPAÇO DENTRO DO /u01/app/oracle/admin )
 
 DAR O COMANDO 
 ls -l 
 
 ENTRAR NA SUB PASTA QUE ESTA OCUPANDO ESPAÇO 
 cd
 
 DAR O COMANDO 
 ls -l

DAR O COMANDO 
du -sh *        (   VER QUAL PASTA ESTA COMSUMINDO MUITO ESPAÇO )


ENTRAR NA PASTA COM O COMANDO CD 
cd

DAR O COMANDO 
ls -h 

ver o que tem na pasta 

DEPENDENDO DO ARQUIVO TEM DUAS OPÇÃO DE RESOLVER O PROBLEMA COMPACTAR OU ALMENTAR O FILE SYSTEM NESTE CASO VAMOS COMPACTAR


ENTRAR COM O ROOT  

[Z5MG-DB-PROD][root@npaa2431 ~]$

DAR O COMANDO 
vgdisplay     (PARA VER O ESPAÇO LIVRE  QUE TEMOS )


ENTRAR NA MINHA PASTA DX39 QUE ESTA NO    /oracle_bkp3/cipd

cd /oracle_bkp3/cipd
cd dx39

////   COMPACTAR ARQUIVOS  

COM ESTE COMANDO O ARQUIVO SERA COMPACTADO DIMINUINDO O ESPAÇO DO FILE SYSTEM, O MESMO PODE SER COMPACTADO  E TRANFERIDO PARA MINHA PASTA NO NAS 

tar -czvf adump_npaa2431_z5mgp_12-09-22.tar.gz  (  MUDAR A DATA E A BASE npaa2431 , E COLOCAR O CAMINHO DE ONDE ESTA O ARQUIVO QUE EU COMPACTAR /u01/app/oracle/admin/z5mgp/adump/ E DAR ENTER )


ENTRAR NA PASTA ONDE ESTAVA O ANTIGO ARQUIVO QUE ESTAVA OCUPANDO ESPAÇO E APAGAR TUDO 

cd /u01/app/oracle/admin/z5mgp/adump/


APAGAR TUDO 
COM O COMANDO 

  rm -rf
  
  
DAR O COMANDO LS NA PASTA /u01/app/oracle/admin/z5mgp/adump/
ls 

DAR O COMANDO 
df -h

DECTANDO QUE A PASTA ESTA  VAZIA E TRANSFERINDO O ARQUIVO COMPACTADO DA PASTA DX39 PARA A PASTA /u01/app/oracle/admin/z5mgp/adump/


ENTRAR NA MINHA PASTA ONDE FOI COMPACTADO O ARQUIVO 
cd 

DAR O COMANDO DU -SH PARA VER QUAL O TAMANHO DO ARQUIVO  
du -sh adump_npaa2431_z5mgp_12-09-22.tar.gz              ( adump_npaa2431_z5mgp_12-09-22.tar.gz  e o nome da pasta )


DAR O COMANDO MV PARA MOVIMENTAR A PASTA COMPACTADA PARA O ANTIGO DESTINO 

mv adump_npaa2431_z5mgp_12-09-22.tar.gz /u01/app/oracle/admin/z5mgp/adump/     ( adump_npaa2431_z5mgp_12-09-22.tar.gz    = NOME DA PASTA COMPACTADA )
                                                                               ( /u01/app/oracle/admin/z5mgp/adump/      = NOME DO DESTINO )

#############################################################################################################################################################																			   

########################################################   IDENTIFIEL  #############################################################################

begin
dbms_session.set_identifier('Atendimento ao Chamado: S3530672   '|| to_char (sysdate, 'dd/mm/yyyy HH24:MI'));
end;
/
	
	
	
	
	
	 alter user SEDPPE GRANT CONNECT THROUGH asdx39;
	 
	 10.28204.109_1521_srpdd
	
#######################################################################################################################################################
##############################################################      SENHA DO SYS  #####################################################################
senha do sys 
Entub#d0sh
E#x46C_FaU

SENHA PARA CRIAÇÃO DE JOB  

logim :snap admin
senha :brsnap

#############################################################################################################################################################

DROP MATERIALIZED VIEW "GRSDS"."MV_FCDR_PORTO_LON";
DROP MATERIALIZED VIEW "GRSDS"."MV_FCDR_PORTO_LON";
DROP MATERIALIZED VIEW "GRSDS"."MV_FCDR_PORTO_LON";
D





##########################################################################################################################################################

#####################################################  alterar a frequencia da execução do Scheduler job em PEPBR  ########################################

BEGIN
DBMS_SCHEDULER.SET_ATTRIBUTE (
   name           =>   'SCH_BIEP.JOB_MV_PETROGRAFIA_CARBONATOS',
   attribute      =>   'repeat_interval',
   value          =>   'FREQ=DAILY;BYHOUR=20');
END;
/


#############################################################################################################################################################

#####################################################   QUERY PARA VER O TAMANHO DO DISCO E SE TEM ESPAÇO ###################################################

SET LINESIZE  145
SET PAGESIZE  9999
SET VERIFY    off
COLUMN group_name             FORMAT a20           HEAD 'Disk Group|Name'
COLUMN sector_size            FORMAT 99,999        HEAD 'Sector|Size'
COLUMN block_size             FORMAT 99,999        HEAD 'Block|Size'
COLUMN allocation_unit_size   FORMAT 999,999,999   HEAD 'Allocation|Unit Size'
COLUMN state                  FORMAT a11           HEAD 'State'
COLUMN type                   FORMAT a6            HEAD 'Type'
COLUMN total_mb               FORMAT 999,999,999   HEAD 'Total Size (MB)'
COLUMN used_mb                FORMAT 999,999,999   HEAD 'Used Size (MB)'
COLUMN pct_used               FORMAT 999.99        HEAD 'Pct. Used'

break on report on disk_group_name skip 1
compute sum label "Grand Total: " of total_mb used_mb on report


SELECT
    name                                     group_name
  , sector_size                              sector_size
  , block_size                               block_size
  , allocation_unit_size                     allocation_unit_size
  , state                                    state
  , type                                     type
  , total_mb                                 total_mb
  , (total_mb - free_mb)                     used_mb
  , ROUND((1- (free_mb / total_mb))*100, 2)  pct_used
FROM
    v$asm_diskgroup
ORDER BY
    name
/

#############################################################################################################################################################
##################################################    PARAR A EXECUÇÃO DA JOB   ################################################################################


exec dbms_scheduler.stop_job('ACO.DBMS_JOB__4508',true);


##############################################################################################################################################################
##########################################  COMANDO PARA VER SE A JOB ESTA RODANDO ##########################################################################


select owner, job_name, session_id, running_instance, elapsed_time, cpu_used
from DBA_scheduler_running_jobs;

################################################################################################################################################################
##########################################   COMANDO PARA EXECUTAR A JOB   ##################################################################################

exec dbms_scheduler.run_job('DRA_REEVALUATE_OPEN_FAILURES',true);


##############################################################################################################################################################
######################################################   ALTERAR O USER E DAR GRANT PARA MINHA CHAVE  ########################################################


alter user  ASDT1N  GRANT CONNECT THROUGH asdx39;


#############################################################################################################################################################
################################################   VER O ESPAÇO LIVRE DA TABLE SPACE  #######################################################################
set lines 200
SELECT tbm.TABLESPACE_NAME,
round(tbm.USED_SPACE * tb.BLOCK_SIZE /(1024*1024),2) USED_SPACE_MB,
round(tbm.TABLESPACE_SIZE * tb.BLOCK_SIZE /(1024*1024*1024),2) TABLESPACE_SIZE_GB,
ROUND((TBM.TABLESPACE_SIZE - TBM.USED_SPACE) * TB.BLOCK_SIZE /(1024*1024*1024),2) TABLESPACE_FREE_GB,
round(tbm.USED_PERCENT ,2) AS "USED_%"
FROM dba_tablespace_usage_metrics tbm,
dba_tablespaces tb
where TB.TABLESPACE_NAME = TBM.TABLESPACE_NAME
AND TBM.TABLESPACE_NAME like '%APRSGA_DADOS%' ORDER BY TB.TABLESPACE_NAME;

##############################################################################################################################################################
#########################################################   ALMENTAR A DATAFILE  ############################################################################



alter tablespace SYSAUX add datafile '+DG_DAT01' size 8m autoextend on next 16m maxsize 30g ;


###############################################################################################################################################################
#########################################   ALMENTANDO O TABLE SPACE  #######################################################################################

ENTRAR COM O COMANDO SUDO 
sudo su - oracle 

DAR O COMANDO PARA LISTAR AS BASES
ps -ef | grep pmon

DAR O COMANDO PARA VER O ARMAZENAMENTO DE CADA ARQUIVO DENTRO DA DASE ONDE ESTA OCORENDO O PROBLEMA 
du -sh *

dar o comando export para entrar na  SQL>
                                     SQL>

export ORACLE_SID=nome do local onde eu quero									 

DAR O COMANDO 
sqlplus / as sysdba

COLAR A QUERI PARA VER O ESPAÇO LIVRE DA TABLESPACE

set lines 200
SELECT tbm.TABLESPACE_NAME,
round(tbm.USED_SPACE * tb.BLOCK_SIZE /(1024*1024),2) USED_SPACE_MB,
round(tbm.TABLESPACE_SIZE * tb.BLOCK_SIZE /(1024*1024*1024),2) TABLESPACE_SIZE_GB,
ROUND((TBM.TABLESPACE_SIZE - TBM.USED_SPACE) * TB.BLOCK_SIZE /(1024*1024*1024),2) TABLESPACE_FREE_GB,
round(tbm.USED_PERCENT ,2) AS "USED_%"
FROM dba_tablespace_usage_metrics tbm,
dba_tablespaces tb
where TB.TABLESPACE_NAME = TBM.TABLESPACE_NAME
AND TBM.TABLESPACE_NAME like '%UNDO02%' ORDER BY TB.TABLESPACE_NAME;



APOS CONFIRMAR QUE NAO A ESPAÇO NO MESMO, COLAR A QUERY PARA ALMENTAR O TAMANHO DO DATAFILE 

alter tablespace UNDO02 add datafile '+DG_DAT01' size 8m autoextend on next 16m maxsize 30g ;


 
 E POSIVEL SOLTAR O MESMO COMANDO COM  / 
 ALMENTANDO ASSIM A TABLESPACE MAIS UMA VEZ 
 
 
 
  APOS ALMENTAR A TABLESPACE VERIFICAR SE A MESMA REALMENTE FOI ALMENTADA, JOGANDO A QUERY VER O ESPAÇO LIVRE DO DATAFILE
  
  
 ##############################################################################################################################################################
###########################################  QUERY BPARA ALMENTAR A TEM ( TEMPORARIO )  ##################################################################### 
  
  ALTER TABLESPACE TEMP3 ADD TEMPFILE '+DG_DAT01' size 30G reuse autoextend on next 16m maxsize 30G;
  
  ############################################################################################################################################################
  ######################################################  CRIANDO USUARIO NO SQL DEVELOPER  #################################################################
  
  
   CREATE USER "ASDX39" IDENTIFIED BY "Nanda00001#" DEFAULT TABLESPACE "USERS" TEMPORARY TABLESPACE "TEMP" PROFILE "PFL_ADM_USER";
grant RADM_USER TO ASDX39;
GRANT "RADM_DBA" TO "ASDX39" WITH ADMIN OPTION;
grant RADM_DBA_DSV TO ASDX39;


##############################################################################################################################################################@
###########################################     VER SE O USUARIO EXISTE NO SQL DEVELOPER ####################################################################


SELECT USERNAME,EXPIRY_DATE, PROFILE,ACCOUNT_STATUS, LOCK_DATE  from dba_users where username like '%MOREJUMP%';

###########################################################################################################################################################
############################################## usuario com privilegios diferentes de select  #############################################################



select  a.username, a.profile
from dba_users a
where a.username in (select distinct b.GRANTEE from DBA_ROLE_PRIVS b where b.GRANTED_ROLE= 'SELECT_CATALOG_ROLE')
and a.profile like '%SABI4DP21%';


##############################################################################################################################################################
###########################################  ver todos os privilegios ########################################################################################

select GRANTEE, GRANTED_ROLE, ADMIN_OPTION from DBA_ROLE_PRIVS where GRANTED_ROLE= 'SABI4DP21';



##########################################################################################################################################################

#####################################    query para compilar os dados   ###############################################################################



select  owner, object_name ,object_type
from DBA_objects
where STATUS LIKE 'INVALID' and owner LIKE '%SATH%';



#############################################################################################################################################################
##############################################     QUERY PARA COLETAR EVIDENCIAS   ###########################################################################


set lines 200
select host_name,instance_name from gv$instance;
select id_grupo,profile from orastatus.tbl_grupo_adm where id_grupo='GG_INFRA_SUPORTE_AB_DBA';


############################################################################################################################################################
##########################################################     ver serviços ativos      ####################################################################



col NETWORK_NAME for a31
col NAME for a31
select inst_id, name, network_name from gv$active_services order by name, inst_id;






###############################################################################################################################################################
#############################################        QUERY PARA VER AS JOB COM FALHA  ######################################################################


SELECT *
FROM dba_scheduler_job_log t1,
     (SELECT job_name, MAX(log_date) last_exec
      FROM dba_scheduler_job_log
      WHERE job_name IN (SELECT job_name
                         FROM dba_scheduler_jobs
                         WHERE state NOT IN ('BROKEN', 'RUNNING', 'DISABLED'))
      GROUP BY job_name) t2,
      dba_scheduler_job_run_details t3
WHERE t1.LOG_ID = t3.LOG_ID
AND t1.job_name = t2.job_name
AND t1.LOG_DATE = t2.last_exec
AND t1.status = 'FAILED';



############################################################################################################################################################3
#################################### CRIANDO USUARIO   ###################################################################################################


create user ASDT1N identified by Wd#hg67#xc default tablespace USERS temporary tablespace TEMP profile PFL_DBA_DSV ;
grant radm_dba_dsv to ASDT1N;
grant radm_user to ASDT1N;
grant unlimited tablespace to ASDT1N;
grant select any dictionary to ASDT1N;
grant SELECT ANY TABLE to ASDT1N;



#####################################################################################################################################################
#########################################    CRIAÇÃO DE USUARIO COM AS MINIMAS PERMIÇÕES #############################################################



create user PMEN_INTEGRACAO_LSTH identified by  Dragon001# default tablespace USERS temporary tablespace TEMP profile PFL_ADM_APPLICATION;
     GRANT RADM_USER TO PMEN_INTEGRACAO_LSTH;
	 
	 
#######################################################################################################################################################
#######################################   


TCRP.petrobras.com.br=
    (DESCRIPTION=
        (ADDRESS=(PROTOCOL=TCP)(HOST=bdodscp.petrobras.com.br)(PORT=1521))
        (CONNECT_DATA=
        (SERVICE_NAME=odscp.petrobras.com.br)(UR=A)))
		
		
		
		##################################################################################################################################################
		##################################### VER OQUE TEM DENTRO DA ROLE  (trocar 'RFIC_DRL') ######################################################################
		
		set long 9999999
SELECT DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','RFIC_DRL') ||';' FROM DUAL;


########################################################################################################################################################
#########################################################  VERIFICAR QUAIS ROLE O USUARIO TEM  #########################################################

SELECT ROLE FROM DBA_ROLES where role like '%SCH_GSON%';

##############################################################################################################################################################
######################################################  CONSEDER A ROLE AO USUARIO #########################################################################


grant RBIREF_DRL TO X4RB,U4UL;



###########################################################################################################################################################
################################################    VER DE QUEM PERTENCE O OBJETO  olhando a dba_objects  #################################################
( COLOCAR E LETRA MAIUSCULA O OBJETO )

select OWNER,OBJECT_TYPE,LAST_DDL_TIME,TIMESTAMP  from dba_objects where OBJECT_NAME = 'vw_giep_elemento_estrutura';  


    

###############################################################################################################################################################
#########################################################   FALHAS NA ROTINA DE BACKUP  #########################################################################



sudo su - oracle



ls -h



ENTRAR NO CONTAINER QUE ESTA A FALHA DO BACKUP 
. c1s1abp.env


sqlplus / as sysdba



SOLTAR A QUERY DE BACKUP  
QUERY PARA VER SE O BACKUP ESTA RODANDO 

	col START_TIME for a20
	col END_TIME for a20
	set lines 200
	select
	   to_char(j.start_time, 'yyyy-mm-dd hh24:mi:ss') start_time,
	   to_char(j.end_time, 'yyyy-mm-dd hh24:mi:ss') end_time,
	   (j.output_bytes/1024/1024) output_mbytes, j.status, j.input_type,
	   decode(to_char(j.start_time, 'd'), 1, 'Sunday', 2, 'Monday',
										  3, 'Tuesday', 4, 'Wednesday',
										  5, 'Thursday', 6, 'Friday',
										  7, 'Saturday') dow
	 from V$RMAN_BACKUP_JOB_DETAILS j
	 where j.start_time > trunc(sysdate) -50
	 order by j.start_time desc;
	 select host_name,instance_name from gv$instance;
	 
	 
	 TALVES TENHA QUE ENTRAR NO BANCO DE ORIGEM DO BACKUP E DAR UM  (resync catalog)
	 srjcipdexa1cl1db02   
	 
	 . c1s1abp.env
	 
	 rman target / catalog rman_stby/qwerasdf#357@rman.PETROBRAS.COM.BR
	                           OU
	rman target / catalog rman_stby_bkp/qwerasdf#357@rman_bkp.petrobras.com.br
	
	resync catalog;
	
AO TERMINO APARECERA ESTA MENSSAGEM
Recovery Manager complete.



	 
	 
	 APOS VERIFICAR A FALHA, ENTRAR NA PASTA ONDE E FEITO O BACKUP 
	 cd /u02/app/oracle/admin/c1s1abp/scripts
	 
	 cd backup
	 
	 
	 DAR O  COMANDO 
	 ls -la

ENTRAR NA PASTA LOG 
cd log


DAR O COMANDO 
ls -ltra

APARECERA UMA LISTA DOS BACKUP, ENTRAR COM O vi NO ULTIMO BACKUP FULL OU ACHIVELOG 

vi logRmanTapeArchive-07-11-2022_12.36.log
                 ou
vi logRmanTapeFullOnline-07-11-2022_00.23.log


VERIFICAR A FALHA E RODAR O BACKUP NOVAMENTE 



VOLTAR UMA PASTA ( IR PARA PASTA BACKUP)
cd ..


DAR UM 
ls -la


RODAR O BACKUP ACHIVELOG NOVAMENTE COM O COMANDO 

nohup ./scrRmanTapeArchive.sh &  TapeFullOnline
nohup ./scrRmanTapeFullOnline.sh &

DAR O COMANDO PARA VER SE O BACKUP ESTA RODANDO (ENTRAR NA PASTA LOG )

cd log

DAR O COMANDO 

ls -lrt

VER AS ULTIMAS LOG 
tail -100f logRmanTapeArchive-07-11-2022_17.33.log

###########################################################################################################################################################
##########################################################  RODANDO O BACKUP NOVAMENTE #################################################################
cd ..    PARA SAIR DO DIRETORIO LOG
NO DIRETORIO BACKUP DA O COMANDO 
ls -la
 DAR UM rm NO ULTIMO BACKUP FULL QUE ESTA EM LOCK
 rm -rf .lckRmanTapeFullOnline.lock
 ps -ef | grep rman
 DAR UM kill -9  NO codigo do ultimo backup FULL 
( oracle    1137 64043  0 Nov13 ?        00:00:00 rman app/oracle/product/19/db_1/bin/rman )
kill -9 1137
CONFIRMAR O KILL
 ps -ef | grep rman
 RODAR O BACKUP NOVAMENTE 
 nohup ./scrRmanTapeFullOnline.sh &
 ls -lrt
 DAR UM TAIL -100F NO ULTIMO BACKUP FULL
 tail -100f logRmanTapeFullOnline-23-11-2022_17.45.log




##########################################################################################################################################################
#################################################     Verificar objetos de um Owner  ################################################################



	select * from dba_objects WHERE owner = 'ASDF';
	
	
	-- query para verificar objetos no banco:
select OWNER,LAST_DDL_TIME,TIMESTAMP from dba_objects where OBJECT_NAME = 'JOB_MV_BIIN_TEXTO_LONGO_OBJETO';
select OWNER from dba_objects where OBJECT_NAME = 'LOB_REENVIO_MENSAGEM_REME_NM_D';
select OWNER,OBJECT_TYPE,LAST_DDL_TIME,TIMESTAMP from dba_objects where OBJECT_NAME = 'MV_BIDU_FORCA_TRABALHO';



##############################################################################################################################################################
#########################################################  VER AS PERMIÇOES DO USUARIO #######################################################################


set long 9999999
select dbms_metadata.get_ddl('USER','SYSTEM')||';' from dual;



SELECT DBMS_METADATA.GET_GRANTED_DDL('ROLE_GRANT','ADM')||';' FROM DUAL;
SELECT DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','ADM')||';' FROM DUAL;
SELECT DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','ADM') ||';' FROM DUAL;


#############################################################################################################################################################
#############################################   SCREEN ( SE A SEÇÃO CAIR, VOUTAR DE ONDE PAROU )#####################################################
			 
	 
screen -h 10000000 -S asdx39_mv



-- SUDO SU - ORACLE
SETO A VARIAVEL  . cwn001d.env
screen -LS
screen -RD 14552.asdx39_mv (COLAR O NUMERO DA SCREEN QUE APARECEL AO DAR O COMANDO SCREEN -LS)


#################################################################################################################################################################
#################################################  VER A SENHA CRIPTOGRAFADA DO USUARIO ###############################################################


set long 9999999
select dbms_metadata.get_ddl('USER','SYSTEM')||';' from dual;



O COMANDO IRA GERAR UM OUTRO COMANDO PARA ESTAR EXECUTANDO ATENÇÃO AO TROCAR O CREATE POR ALTER 



############################################################################################################################################################
#############################################

nohup sqlplus / as sysdba @mv2.sql

PARA SALVAR EXECUTAR O COMANDO NO VI BASTA DAR O COMANDO ACIMA  E NO FINAL COLOCAR O NOME DO ARRQUIVO 

###########################################################################################################################################################3##
###############################################  VER O SERVIÇO DO BANCO #################################################################################3

col NETWORK_NAME for a31
col NAME for a31
select inst_id, name, network_name from gv$active_services order by name, inst_id;

SE ALGUM NO NÃO ESTIVER NO AR RODAR ESTA QUERY 

exec DBMS_SERVICE.START_SERVICE('svc_abastd',DBMS_SERVICE.ALL_INSTANCES);
alter pluggable database abastd save state instances = all;


####################################################################################################################################################3
################################################## COLETA DE STATISTICA  ##################################################################################

QUANDO COLETOU 
SELECT OWNER, TABLE_NAME, LAST_ANALYZED, NUM_ROWS FROM DBA_TABLES WHERE OWNER like '%FZUY%';



COLETAR 
EXEC DBMS_STATS.GATHER_SCHEMA_STATS(OWNNAME=>'FZUY',ESTIMATE_PERCENT => NULL, GRANULARITY=> 'ALL', CASCADE=> TRUE, METHOD_OPT=>'FOR ALL COLUMNS SIZE SKEWONLY', degree => 8);


VER O TAMANHO DE SCHEMA 
Select sum(bytes/1024/1024/1024) GB from dba_segments where owner='FZUY';



########################################################################################################################################################3####
#########################################################     DESABILITAR JOB COM FALHAS   ###########################################################################

select distinct 'begin DBMS_SCHEDULER.disable(NAME => '''||b.owner||'.'||b.job_name||''',FORCE => TRUE);end;' ||CHR(10)||
       '/'||CHR(10)
from  dba_scheduler_job_log b
where b.job_name in ( select c.job_name from dba_scheduler_jobs c where c.failure_count <>0 )
and b.status <> 'SUCCEEDED' order by 1;


#############################################################################################################################################################
#############################################  MATAR SEÇÃO INATIVAS  #####################################################################################



SELECT SE.INST_ID IID      ,DECODE(EVENT             ,'jobq slave wait'             ,'zIJQ'             ,DECODE(SE.STATUS                    ,'ACTIVE'                    ,'ACT'                    ,'INACTIVE'                    ,'INA'                    ,SE.STATUS)) STA      ,REPLACE(TO_CHAR(FLOOR(LAST_CALL_ET / 3600)                      ,'00') || ':' ||               TO_CHAR(FLOOR(MOD(LAST_CALL_ET                                ,3600) / 60)                      ,'00') || ':' ||               TO_CHAR(MOD(MOD(LAST_CALL_ET                              ,3600)                          ,60)                      ,'00')              ,' '              ,NULL) L_S      ,NVL(SE.USERNAME          ,PR.PROGRAM) USERNAME      ,OSUSER      , 'ALTER SYSTEM KILL SESSION ' ||'''' || SE.SID || ',' || SE.SERIAL# || ',@' || SE.INST_ID|| ''''  || ' IMMEDIATE;'SID_SERIAL      ,PR.SPID || ' (' || PR.PROGRAM || ')' SPID_PROGRAM      ,HASH_VALUE SQL_HSH      ,SQ.SQL_ID      -- ,SQ.CHILD_NUMBER CN      ,EXECUTIONS SQL_EXE      ,ROUND(((ELAPSED_TIME + CPU_TIME) /       DECODE(EXECUTIONS              ,0              ,1              ,EXECUTIONS) / 1000000),5) SQL_ELA      ,SQL_PROFILE      ,SQL_PLAN_BASELINE      ,PLAN_HASH_VALUE      ,SQL_TEXT      ,SE.PREV_SQL_ID      ,(SELECT MAX('(' || LON.OPNAME || ') (' || LON.SOFAR || '->' ||                   LON.TOTALWORK || ') : ' || LON.TARGET)          FROM V$SESSION_LONGOPS LON         WHERE LON.SID = SE.SID               AND LON.SQL_HASH_VALUE = SE.SQL_HASH_VALUE               AND SOFAR < TOTALWORK) LO      ,' (#W : ' || RPAD(SEQ#                        ,5) || ' | ST : ' ||       DECODE(WAIT_TIME             ,0             ,'WAIT'             ,-1             ,'FAST'             ,-2             ,'UNKN'             ,WAIT_TIME) || ') ' || EVENT W      ,SE.BLOCKING_SESSION      ,SE.SECONDS_IN_WAIT      ,SE.TERMINAL      ,SE.OSUSER      ,SE.MACHINE      ,SE.LOGON_TIME      ,SE.PROGRAM      ,SE.FAILED_OVER      ,SE.SERVER      ,SE.SERVICE_NAME      ,(SELECT SQL_FULLTEXT          FROM V$SQLAREA         WHERE SQL_ID = SE.SQL_ID) SQL_FULLTEXT
/*      ,(SELECT OWNER || '.' || OBJECT_NAME || '(' || OBJECT_TYPE || ') - ' ||               SQ.PROGRAM_ID || '(' || SQ.PROGRAM_LINE# || ')'          FROM DBA_OBJECTS OB              ,V$SQL      SQ         WHERE HASH_VALUE = SE.SQL_HASH_VALUE           AND INST_ID = SE.INST_ID           AND CHILD_NUMBER = SE.SQL_CHILD_NUMBER           AND OB.OBJECT_ID = SQ.PROGRAM_ID) PRG_O
*/  FROM GV$SESSION SE      ,GV$PROCESS PR      ,GV$SQLAREA     SQ
WHERE SE.INST_ID = PR.INST_ID       AND SE.INST_ID = SQ.INST_ID (+)       AND SE.PADDR = PR.ADDR(+)       AND SE.SQL_ID = SQ.SQL_ID(+)       AND SE.TYPE = 'USER'--       AND SE.USERNAME NOT IN ('SYS', 'DBSNMP')--       AND SE.USERNAME NOT IN ('QIOR_SOAINFRA')
-- AND SE.STATUS IN ('ACTIVE', 'KILLED', 'PSEUDO')
-- AND SE.SID NOT IN (SELECT SID--                        FROM V$MYSTAT)
--AND SE.USERNAME IN ('UBDOC')
-- AND SE.MACHINE = 'moros'
--and osuser like 'sabiaep%'--AND SID in (1532,3043)  
--and SE.INST_ID = 2---and  PR.SPID in ()  24887   ALTER SYSTEM KILL SESSION '5515,40347,@1' IMMEDIATE;
ORDER BY STA         ,L_S         ,SE.USERNAME         ,SID_SERIAL

O COMANDO VAI GERAR OUTRO COMANDO E PARA COPIAR E COLAR E MARAT AS SEÇOES ( E PARA MATAR SOMENTE AS INATIVAS )



############################################################################################################################################################
##########################################   VER SE ESTOU NO DG ( DATA GUARD ) ################################################################################


SQL> show parameter config;




#############################################################################################################################################################
#####################################################   VER SE A BASE ESTA RED ONLY  OU  READ WRITE    ######################################################

select open_mode from gv$database;



#############################################################################################################################################################
###########################################   VER ONDE ESTA A HOST BASE PRIMARIA  ################################################################################


tnsping edmproj ( NOME DA BASE )

O COMANDO IRA MOSTRAR DA SEGUINTE FORMA A BAIXO 

Used TNSNAMES adapter to resolve the alias
Attempting to contact (DESCRIPTION= (ADDRESS_LIST=(ADDRESS=(COMMUNITY=tcp)(PROTOCOL=TCP)(Host=npaa3844.petrobras.biz)(Port=1521))) (CONNECT_DATA=(SERVICE_NAME = edmproj.PETROBRAS.COM.BR)))


##############################################################################################################################################################################################
#####################################   MOSTRA O NOME DO CATALOGO DO Rman  E SE O MESMO ESTA EM STANDBY  ###################################################################



cat parRman.sh



####################################################################################################################################################################
##############################################  CALCULA QUANTO TEM NO DISCO ACHIVE 


dg=RECOC1; for dir in $(asmcmd ls $dg); do echo $dg/$dir; asmcmd du $dg/$dir; done  



################################################################################################################################################################
#######################################3  ENCONTRAR USUARIO NO MOBA  COM A FORMATAÇÃO VISIVEL PARA HUMANO #####################################################


set linesize 200
set pagesize 60
col profile for a30
col USERNAME for a20
col ACCOUNT_STATUS for a10
SELECT USERNAME,EXPIRY_DATE, PROFILE,ACCOUNT_STATUS, LOCK_DATE  from dba_users where username like '%SAAZRDATHUBGSD15%';

##############################################################################################################################################################3
######################################  COLETA DE STATISTICA ##############################################################################################


EXEC DBMS_STATS.GATHER_SCHEMA_STATS(OWNNAME=>'FZUY',ESTIMATE_PERCENT => NULL, GRANULARITY=> 'ALL', CASCADE=> TRUE, METHOD_OPT=>'FOR ALL COLUMNS SIZE SKEWONLY', degree => 8);






############################################################################################################################################################3
#####  EXPORT  
origem

create or replace directory DIR_ADM_BKP as '/ora_operacao3/ASDX39';

nohup expdp \"/ as sysdba\" schemas=SGR3 directory=DIR_ADM_BKP dumpfile=expdp_asdx39_aplabp08_S3633218_%U.dmp logfile=expdp_asdx39_aplabp08_S3633218.log cluster=n flashback_time=systimestamp parallel=8 &



destino copia de segurança


create or replace directory DIR_ADM_BKP as '/ora_operacao3/ASDX39';



nohup expdp \"/ as sysdba\" schemas=SGR3 directory=DIR_ADM_BKP dumpfile=expdp_COPIA_APLABH08_S3633218_%U.dmp logfile=expdp_COPIA_APLABH08_S3633218.log cluster=n flashback_time=systimestamp parallel=8 &




#### IMPORT 

destino


LIMPAR SCHEMA

SELECT 'DROP TABLE '|| OWNER||'.'||TABLE_NAME || ' CASCADE CONSTRAINTS PURGE;' FROM DBA_TABLES WHERE OWNER IN ('SGR3');
SELECT 'DROP ' || OBJECT_TYPE || ' ' || OWNER||'.'||OBJECT_NAME || ';' FROM DBA_OBJECTS WHERE OWNER IN ('SGR3')
AND OBJECT_TYPE NOT IN ('TABLE','INDEX') AND OBJECT_NAME NOT LIKE 'BIN$%' AND OBJECT_NAME NOT LIKE '%$$' ORDER BY object_name;
SELECT 'DROP ' || OBJECT_TYPE || ' ' || OWNER||'.'||OBJECT_NAME || ';' FROM DBA_OBJECTS WHERE OWNER IN ('SGR3') AND OBJECT_TYPE='SYNONYM';





nohup impdp \"/ as sysdba\" directory=DIR_ADM_BKP dumpfile=expdp_asdx39_aplabp08_S3633218_%U.dmp logfile=impdp_APLABH08_S3633218.log cluster=n parallel=8 &

COLETAR ESTATISTICA 
EXEC DBMS_STATS.GATHER_SCHEMA_STATS(OWNNAME=>'SGR3',ESTIMATE_PERCENT => NULL, GRANULARITY=> 'ALL', CASCADE=> TRUE, METHOD_OPT=>'FOR ALL COLUMNS SIZE SKEWONLY', degree => 8);




ENVIANDO PARA O AMBIENTE DE TEXTE COMO PEDE NO CHAMADO 

destino copia de segurança   teste



create or replace directory DIR_ADM_BKP as '/ora_operacao3/ASDX39';



nohup expdp \"/ as sysdba\" schemas=SGR3 directory=DIR_ADM_BKP dumpfile=expdp_COPIA_APLABT08_S3633218_%U.dmp logfile=expdp_COPIA_APLABT08_S3633218.log cluster=n flashback_time=systimestamp parallel=8 &




LIMPAR ESCHEMA ( ESTE COMANDO IRA GERAR OUTRO COMANDO DE DROP PARA LIMPAR O SCHEMA )

SELECT 'DROP TABLE '|| OWNER||'.'||TABLE_NAME || ' CASCADE CONSTRAINTS PURGE;' FROM DBA_TABLES WHERE OWNER IN ('SGR3');
SELECT 'DROP ' || OBJECT_TYPE || ' ' || OWNER||'.'||OBJECT_NAME || ';' FROM DBA_OBJECTS WHERE OWNER IN ('SGR3')
AND OBJECT_TYPE NOT IN ('TABLE','INDEX') AND OBJECT_NAME NOT LIKE 'BIN$%' AND OBJECT_NAME NOT LIKE '%$$' ORDER BY object_name;
SELECT 'DROP ' || OBJECT_TYPE || ' ' || OWNER||'.'||OBJECT_NAME || ';' FROM DBA_OBJECTS WHERE OWNER IN ('SGR3') AND OBJECT_TYPE='SYNONYM';



---IMPORTAR O DADOS
NESTE CASO TEM QUE MUDAR O LOG ( logfile=impdp_APLABT08_S3633218.log ) PARA NÃO SOBESCREVER O OUTRO ACIMA SO COLOCAR O  ( T = APALABT08 ) e soltar o comando no linux

nohup impdp \"/ as sysdba\" directory=DIR_ADM_BKP dumpfile=expdp_asdx39_aplabp08_S3633218_%U.dmp logfile=impdp_APLABT08_S3633218.log cluster=n parallel=8 &



COMPILAR OS DADOS 

BEGIN
  SYS.UTL_RECOMP.RECOMP_SERIAL(SCHEMA => 'SGR3');
END;
/




COLETAR ESTATISTICA 

EXEC DBMS_STATS.GATHER_SCHEMA_STATS(OWNNAME=>'SGR3',ESTIMATE_PERCENT => NULL, GRANULARITY=> 'ALL', CASCADE=> TRUE, METHOD_OPT=>'FOR ALL COLUMNS SIZE SKEWONLY', degree => 8);









##############################################################################################################################################################
#######################################################  BAIXAR O BANCO #################################################################################



srvctl stop database -d epdsv02 -o immediate


srvctl disable database -d epdsv02 

###############################################################################################################################################################
################################################  DUMP  ####################################################################################################
CHAMADO = S3629002       CLIENTE SO PEDIL A COPIA DO BANCO E ENCAMINHAR PARA O DESTINO INFORMADO NO CHAMADO 


emtrar no banco pelo moba e soutar o comando a baixo ( ESTE COMANDO IRA CRIAR UM DIRETORIO NO CAMINHO TAL NA MINHA PASTA )

create or replace directory DUMP_NAS_DIR as '/BKP_NAS_TICNE_CIPD/ascjsp';


NESTE CHAMADO O CLIENTE ESTA PEDINDO PARA FAZER O DUMP COM PARAMETRO VERSION 12 ( IMPORTANTE: realizar expdp passando o parâmetro “Version=12.1") SOLTAR O SEGUINTE COMANDO ABAIXO

nohup expdp \"/ as sysdba\" version=12.1 schemas=SPF3_AM directory=DUMP_NAS_DIR dumpfile=exp_SPF3_AM_SPFP_S3629002.dmp logfile=exp_SPF3_AM_SPFP_S3629002.log cluster=n flashback_time=systimestamp parallel=8 &




------ VER O TAMANHO DO SCHEMA E VER O TANAMHO DA BASE 

Select sum(bytes/1024/1024/1024) GB from dba_segments where owner='SPF3_AM';  ( TAMANHO DO SCHEMA  )
select sum(bytes/1024/1024/1024) GB from v$datafile;  9 TAMANHO DA BASE  )








################################################################################################################################################################
######################################   MOSTRA QUANTOS GIGAS TEM CADA BASE ###############################################################################



du -h | grep G



############################################################################################################################################################
#################################################   FORMATAÇÃO PARA FICAR VISIVEL PARA HUMANO NO MOBA #######################################################


set lines 200
set pages 100
col tabela format a30
col bloqueador format a60
col bloqueado format a60


###############################################################################################################################################################
#####################################################   MATAR A CESSAO QUE ESTA PRENDENDO O OBJETYO 


select 'alter system kill session '''||b.sid||','||b.serial#||''' immediate;'
from gv$locked_object a , gv$session b, dba_objects c
where b.sid = a.session_id
and a.object_id = c.object_id;








